Total files found and listed: 29
List of all files found (paths relative to processing context):
- .github\workflows\android_ci.yml
- .gitignore
- app\build.gradle
- app\src\main\AndroidManifest.xml
- app\src\main\java\com\example\mybasicapp\MainActivity.java
- app\src\main\java\com\example\mybasicapp\NsdHelper.java
- app\src\main\java\com\example\mybasicapp\WebSocketService.java
- app\src\main\res\drawable\ic_stat_message.xml
- app\src\main\res\drawable\ic_stat_service.xml
- app\src\main\res\layout\activity_main.xml
- app\src\main\res\mipmap-hdpi\ic_launcher.png
- app\src\main\res\mipmap-hdpi\ic_launcher_round.png
- app\src\main\res\mipmap-mdpi\ic_launcher.png
- app\src\main\res\mipmap-mdpi\ic_launcher_round.png
- app\src\main\res\mipmap-xhdpi\ic_launcher.png
- app\src\main\res\mipmap-xhdpi\ic_launcher_round.png
- app\src\main\res\mipmap-xxhdpi\ic_launcher.png
- app\src\main\res\mipmap-xxhdpi\ic_launcher_round.png
- app\src\main\res\mipmap-xxxhdpi\ic_launcher.png
- app\src\main\res\mipmap-xxxhdpi\ic_launcher_round.png
- app\src\main\res\values\colors.xml
- app\src\main\res\values\strings.xml
- app\src\main\res\values\themes.xml
- app\src\main\res\xml\backup_rules.xml
- app\src\main\res\xml\data_extraction_rules.xml
- build.gradle
- gradle\wrapper\gradle-wrapper.properties
- gradle.properties
- settings.gradle

Content included for 18 file(s) with extensions: .java, .yml, .xml, .gradle, .properties

================================================================================


#################### START OF FILE: .github\workflows\android_ci.yml ####################

name: Android CI Build (Online Wrapper Init)

on:
  push:
    branches: [ "main", "master" ] # Or your default branch
  pull_request:
    branches: [ "main", "master" ]

jobs:
  build:
    env:
      # Define the Gradle version for the wrapper and build.
      # Choose a version compatible with your Android Gradle Plugin (AGP).
      # For AGP 8.4.0 (used in root build.gradle), Gradle 8.6 or higher is needed.
      # Check AGP release notes for compatibility.
      GRADLE_VERSION_TO_USE: '8.6' # Updated to Gradle 8.6

    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up JDK 17
      uses: actions/setup-java@v4
      with:
        java-version: '17' # Common for modern Android development
        distribution: 'temurin'

    # This step installs the specified version of Gradle and adds the 'gradle' command to the PATH.
    - name: Setup Gradle
      uses: gradle/actions/setup-gradle@v3 # Using setup-gradle v3
      with:
        gradle-version: ${{ env.GRADLE_VERSION_TO_USE }}
        # setup-gradle action has its own caching for Gradle User Home,
        # which can be beneficial. You can further configure it if needed.
        # See https://github.com/gradle/actions/blob/main/setup-gradle/README.md#caching

    # This step uses the 'gradle' command (from Setup Gradle step) to initialize
    # the Gradle wrapper files (gradlew, gradlew.bat, gradle-wrapper.jar, gradle-wrapper.properties)
    # in the runner's workspace. The generated gradle-wrapper.properties will point to GRADLE_VERSION_TO_USE.
    - name: Initialize Gradle Wrapper
      run: gradle wrapper --gradle-version ${{ env.GRADLE_VERSION_TO_USE }} --distribution-type bin
      # Adding --distribution-type bin to ensure it fetches the binary distribution

    - name: Grant execute permission for gradlew
      run: chmod +x ./gradlew

    # Recommended: Cache Gradle dependencies downloaded by the wrapper.
    # This cache uses the wrapper files generated in the previous step and other project build files.
    - name: Cache Gradle packages
      uses: actions/cache@v4
      with:
        path: |
          ~/.gradle/caches
          ~/.gradle/wrapper/dists
        # MODIFIED KEY: Added a version suffix '-v1' to help invalidate the cache if needed.
        # Increment this suffix (e.g., -v2, -v3) or use a dynamic value like ${{ github.run_id }}
        # if you suspect stale cache issues and need to force a fresh download.
        key: ${{ runner.os }}-gradle-${{ env.GRADLE_VERSION_TO_USE }}-${{ hashFiles('**/*.gradle*', '**/gradle-wrapper.properties', '**/libs.versions.toml') }}-v1
        restore-keys: |
          ${{ runner.os }}-gradle-${{ env.GRADLE_VERSION_TO_USE }}-

    - name: Build with Gradle Wrapper
      # Adding --stacktrace for more detailed error output if the build fails
      run: ./gradlew assembleDebug --stacktrace

    - name: Upload Debug APK
      uses: actions/upload-artifact@v4
      with:
        name: MrCoopersESP32 # Name of the artifact
        path: app/build/outputs/apk/debug/MrCoopersESP32.apk # Path to the APK
        if-no-files-found: error # Fail if APK not found

#################### START OF FILE: app\build.gradle ####################

plugins {
    id 'com.android.application'
    // id 'org.jetbrains.kotlin.android' // This project uses Java, so Kotlin plugin is not needed
}

android {
    namespace 'com.example.mybasicapp'
    compileSdk 34

    defaultConfig {
        applicationId "com.example.mybasicapp"
        minSdk 21
        targetSdk 34
        versionCode 1
        versionName "1.0"

        testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
    }

    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
        }
        debug {
            // APK naming is handled by the androidComponents block below
        }
    }

    compileOptions {
        // Align with the JDK version used in the CI workflow (JDK 17)
        sourceCompatibility JavaVersion.VERSION_17
        targetCompatibility JavaVersion.VERSION_17
    }
}

// This block customizes the output APK name for debug builds.
// It was previously (and incorrectly) in the root build.gradle.
androidComponents {
    onVariants(selector().withBuildType("debug")) { variant ->
        variant.outputs.forEach { output ->
            // Ensure we are modifying the main APK output
            // Correctly compare the outputType enum directly
            if (output.outputType == com.android.build.api.variant.VariantOutputConfiguration.OutputType.SINGLE) {
                output.outputFileName.set("MrCoopersESP32.apk")
            }
        }
    }
}

dependencies {
    // Use 'androidx.core:core' for Java projects. 'core-ktx' is for Kotlin.
    implementation 'androidx.core:core:1.12.0'
    implementation 'androidx.appcompat:appcompat:1.6.1'
    implementation 'com.google.android.material:material:1.11.0'
    implementation 'androidx.constraintlayout:constraintlayout:2.1.4'

    // Add OkHttp dependency, required for WebSocketService.java.
    // This was previously (and incorrectly) in the root build.gradle's dependencies.
    implementation("com.squareup.okhttp3:okhttp:4.12.0")

    testImplementation 'junit:junit:4.13.2'
    androidTestImplementation 'androidx.test.ext:junit:1.1.5'
    androidTestImplementation 'androidx.test.espresso:espresso-core:3.5.1'
}


#################### START OF FILE: app\src\main\AndroidManifest.xml ####################

<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools">

    <!-- Standard Network Permissions -->
    <uses-permission android:name="android.permission.INTERNET" />
    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />

    <!-- Permissions for mDNS (Network Service Discovery) -->
    <uses-permission android:name="android.permission.ACCESS_WIFI_STATE" />
    <uses-permission android:name="android.permission.CHANGE_WIFI_MULTICAST_STATE" />

    <!-- Permission for Notifications (Required for Android 13+) -->
    <uses-permission android:name="android.permission.POST_NOTIFICATIONS"/>

    <!-- Permissions for Foreground Service -->
    <uses-permission android:name="android.permission.FOREGROUND_SERVICE" />
    <uses-permission android:name="android.permission.FOREGROUND_SERVICE_DATA_SYNC" />
    <!-- If targeting Android 14 (API 34) or higher and your foreground service type is dataSync,
         you might need to explicitly declare the type again here if issues arise,
         though usually the manifest merge handles it.
    <uses-permission android:name="android.permission.FOREGROUND_SERVICE_TYPE_DATA_SYNC" />
    -->


    <application
        android:allowBackup="true"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/Theme.MyBasicApp"
        tools:targetApi="31"
        android:usesCleartextTraffic="true">
        <!-- usesCleartextTraffic="true" is important for local ws:// connections -->

        <activity
            android:name=".MainActivity"
            android:exported="true"
            android:launchMode="singleTop"> <!-- singleTop is good if opening from notification -->
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>

        <service
            android:name=".WebSocketService"
            android:enabled="true"
            android:exported="false"
            android:foregroundServiceType="dataSync" />
            <!-- foregroundServiceType is required for services targeting Android Q (API 29) and above -->

    </application>

</manifest>

#################### START OF FILE: app\src\main\java\com\example\mybasicapp\MainActivity.java ####################

package com.example.mybasicapp;

import androidx.activity.result.ActivityResultLauncher;
import androidx.activity.result.contract.ActivityResultContracts;
import androidx.appcompat.app.AppCompatActivity;
import androidx.core.content.ContextCompat;
import androidx.localbroadcastmanager.content.LocalBroadcastManager;

import android.Manifest;
import android.content.ActivityNotFoundException;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.pm.PackageManager;
import android.net.nsd.NsdServiceInfo;
import android.net.Uri;
import android.os.Build;
import android.os.Bundle;
import android.util.Log;
import android.view.View;
import android.widget.Button;
import android.widget.EditText;
import android.widget.RadioGroup;
import android.widget.RadioButton;
import android.widget.TextView;
import android.widget.Toast;

import java.io.IOException;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Locale;

public class MainActivity extends AppCompatActivity implements NsdHelper.NsdHelperListener {

    private static final String TAG = "MainActivity";

    // mDNS Configuration Constants
    private static final String OTA_SERVICE_TYPE = "_http._tcp";
    private static final String OTA_SERVICE_NAME_FILTER = "mrcoopersesp";

    private static final String MAIN_APP_WS_SERVICE_TYPE = "_myespwebsocket._tcp";
    private static final String MAIN_APP_WS_SERVICE_NAME_FILTER = "ESP32 Motion WebSocket";
    private static final String ESP_WEBSOCKET_PATH = "/ws";

    private enum MonitorMode {
        OTA,
        MAIN_APP_WS
    }
    private MonitorMode currentMonitorMode = MonitorMode.MAIN_APP_WS; // Default

    private EditText editTextEspIpDisplay;
    private Button buttonStartStopDiscovery;
    private Button buttonAction;
    private Button buttonSaveLog;
    private TextView textViewStatus;
    private TextView textViewLastMessage;
    private RadioGroup radioGroupMonitorMode;
    private RadioButton radioButtonOta, radioButtonMainApp;

    private boolean isServiceReceiverRegistered = false; // For WebSocketService
    private StringBuilder statusLog = new StringBuilder();
    private StringBuilder messageLog = new StringBuilder(); // For WebSocketService

    private ActivityResultLauncher<String> createFileLauncher;
    private NsdHelper nsdHelper;
    private NsdServiceInfo resolvedEspServiceInfo = null;
    private String activeDiscoveryServiceType = null; // Current type being searched by NsdHelper
    private boolean isWebSocketServiceActive = false; // Is WebSocketService started and connected

    private final ActivityResultLauncher<String> requestPermissionLauncher =
            registerForActivityResult(new ActivityResultContracts.RequestPermission(), isGranted -> {
                if (isGranted) {
                    Toast.makeText(this, "Notifications permission granted", Toast.LENGTH_SHORT).show();
                } else {
                    Toast.makeText(this, "Notifications permission denied. App may not show alerts.", Toast.LENGTH_LONG).show();
                }
            });

    private final BroadcastReceiver serviceUpdateReceiver = new BroadcastReceiver() {
        @Override
        public void onReceive(Context context, Intent intent) {
            if (currentMonitorMode != MonitorMode.MAIN_APP_WS) return;

            String action = intent.getAction();
            String timestamp = getCurrentTimestamp();
            String status = "";

            if (WebSocketService.ACTION_STATUS_UPDATE.equals(action)) {
                status = intent.getStringExtra(WebSocketService.EXTRA_STATUS);
                String logEntry = timestamp + " WS_Status: " + status + "\n";
                statusLog.append(logEntry);
                Log.d(TAG, "WebSocket Service Status Update: " + status);

                isWebSocketServiceActive = "Connected to ESP32".equals(status);

                if ("Service Stopped".equals(status)) {
                    isWebSocketServiceActive = false;
                    updateUIForWsDisconnected(); // Or a more specific state
                } else if (status.startsWith("Connection Failed") || "Disconnected".equals(status) || "Disconnected by user".equals(status)) {
                    isWebSocketServiceActive = false;
                    updateUIForWsDisconnected();
                } else if ("Connected to ESP32".equals(status)) {
                    updateUIForWsConnected();
                } else if (status.startsWith("Connecting to")) {
                    updateUIForWsConnecting();
                }
                textViewStatus.setText("Status (WS): " + status);

            } else if (WebSocketService.ACTION_MESSAGE_RECEIVED.equals(action)) {
                String title = intent.getStringExtra(WebSocketService.EXTRA_MESSAGE_TITLE);
                String body = intent.getStringExtra(WebSocketService.EXTRA_MESSAGE_BODY);
                String logEntry = timestamp + " WS_Message: [" + title + "] " + body + "\n";
                messageLog.append(logEntry);
                textViewLastMessage.setText("Last WS Msg: " + title + " - " + body);
                Log.d(TAG, "WebSocket Service Message Received: " + title + " - " + body);
            }
        }
    };

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        editTextEspIpDisplay = findViewById(R.id.editTextEspIp);
        radioGroupMonitorMode = findViewById(R.id.radioGroupMonitorMode);
        radioButtonOta = findViewById(R.id.radioButtonOta);
        radioButtonMainApp = findViewById(R.id.radioButtonMainApp);
        buttonStartStopDiscovery = findViewById(R.id.buttonStartService); // Will rename in UI
        buttonAction = findViewById(R.id.buttonConnect); // Will rename / change function
        buttonSaveLog = findViewById(R.id.buttonSaveLog);
        textViewStatus = findViewById(R.id.textViewStatus);
        textViewLastMessage = findViewById(R.id.textViewLastMessage);

        // --- Initial UI Setup ---
        editTextEspIpDisplay.setHint("Service Info (Auto-Discovering...)");
        editTextEspIpDisplay.setEnabled(false);
        editTextEspIpDisplay.setFocusable(false);
        buttonStartStopDiscovery.setText("Start Discovery");

        askNotificationPermission();
        nsdHelper = new NsdHelper(this, this);

        createFileLauncher = registerForActivityResult(new ActivityResultContracts.CreateDocument("text/plain"), uri -> {
            if (uri != null) {
                saveLogToFile(uri);
            } else {
                Toast.makeText(MainActivity.this, "Log saving cancelled.", Toast.LENGTH_SHORT).show();
            }
        });

        radioGroupMonitorMode.setOnCheckedChangeListener((group, checkedId) -> {
            stopActiveDiscoveryAndReset(); // Stop current discovery and clear resolved service
            if (checkedId == R.id.radioButtonOta) {
                currentMonitorMode = MonitorMode.OTA;
            } else if (checkedId == R.id.radioButtonMainApp) {
                currentMonitorMode = MonitorMode.MAIN_APP_WS;
            }
            updateUIForInitialState(); // Reset UI to reflect new mode
        });

        buttonStartStopDiscovery.setOnClickListener(v -> {
            if (nsdHelper.isDiscoveryActive()) {
                stopActiveDiscoveryAndReset();
            } else {
                startDiscoveryForCurrentMode();
            }
        });

        buttonAction.setOnClickListener(v -> {
            if (resolvedEspServiceInfo == null) {
                Toast.makeText(this, "No service found yet. Start discovery.", Toast.LENGTH_SHORT).show();
                return;
            }

            if (currentMonitorMode == MonitorMode.OTA) {
                // Open Web Page
                String hostAddress = resolvedEspServiceInfo.getHost().getHostAddress();
                int port = resolvedEspServiceInfo.getPort();
                String url = "http://" + hostAddress + ":" + port;
                Intent browserIntent = new Intent(Intent.ACTION_VIEW, Uri.parse(url));
                try {
                    startActivity(browserIntent);
                    statusLog.append(getCurrentTimestamp()).append(" CMD: Opened OTA page at ").append(url).append("\n");
                } catch (ActivityNotFoundException e) {
                    Toast.makeText(this, "No web browser found to open URL.", Toast.LENGTH_LONG).show();
                    statusLog.append(getCurrentTimestamp()).append(" ERR: No browser for OTA page ").append(url).append("\n");
                }
            } else if (currentMonitorMode == MonitorMode.MAIN_APP_WS) {
                // Connect or Disconnect WebSocket
                if (isWebSocketServiceActive) {
                    // Disconnect
                    Intent serviceIntent = new Intent(this, WebSocketService.class);
                    serviceIntent.setAction(WebSocketService.ACTION_DISCONNECT);
                    startService(serviceIntent); // Service handles actual disconnect
                    statusLog.append(getCurrentTimestamp()).append(" CMD: Disconnect WebSocket\n");
                    // UI will be updated by BroadcastReceiver
                } else {
                    // Connect
                    if (resolvedEspServiceInfo.getHost() != null) {
                        String wsUrl = "ws://" + resolvedEspServiceInfo.getHost().getHostAddress() + ":" + resolvedEspServiceInfo.getPort() + ESP_WEBSOCKET_PATH;

                        // Ensure WebSocketService is running in foreground first
                        Intent startFgIntent = new Intent(this, WebSocketService.class);
                        startFgIntent.setAction(WebSocketService.ACTION_START_FOREGROUND_SERVICE);
                        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                            startForegroundService(startFgIntent);
                        } else {
                            startService(startFgIntent);
                        }

                        // Then send connect command
                        Intent connectIntent = new Intent(this, WebSocketService.class);
                        connectIntent.setAction(WebSocketService.ACTION_CONNECT);
                        connectIntent.putExtra(WebSocketService.EXTRA_IP_ADDRESS, wsUrl);
                        startService(connectIntent);
                        statusLog.append(getCurrentTimestamp()).append(" CMD: Connect WebSocket to ").append(wsUrl).append("\n");
                        // UI will update via BroadcastReceiver
                    } else {
                        Toast.makeText(this, "Service resolved but host is null!", Toast.LENGTH_SHORT).show();
                    }
                }
            }
        });

        buttonSaveLog.setOnClickListener(v -> {
            String fileName = "MrCoopersESP32_Log_" + new SimpleDateFormat("yyyyMMdd_HHmmss", Locale.getDefault()).format(new Date()) + ".txt";
            createFileLauncher.launch(fileName);
        });

        // Set initial state based on default mode
        if (currentMonitorMode == MonitorMode.MAIN_APP_WS) {
            radioButtonMainApp.setChecked(true);
        } else {
            radioButtonOta.setChecked(true);
        }
        updateUIForInitialState();
    }

    private void startDiscoveryForCurrentMode() {
        if (nsdHelper.isDiscoveryActive()) {
            Log.d(TAG, "Discovery already active for " + activeDiscoveryServiceType);
            return;
        }
        resolvedEspServiceInfo = null; // Clear previous findings

        if (currentMonitorMode == MonitorMode.OTA) {
            activeDiscoveryServiceType = OTA_SERVICE_TYPE;
            nsdHelper.discoverServices(OTA_SERVICE_NAME_FILTER, OTA_SERVICE_TYPE);
            statusLog.append(getCurrentTimestamp()).append(" CMD: Start Discovery for OTA (").append(OTA_SERVICE_NAME_FILTER).append(")\n");
        } else if (currentMonitorMode == MonitorMode.MAIN_APP_WS) {
            activeDiscoveryServiceType = MAIN_APP_WS_SERVICE_TYPE;
            nsdHelper.discoverServices(MAIN_APP_WS_SERVICE_NAME_FILTER, MAIN_APP_WS_SERVICE_TYPE);
            statusLog.append(getCurrentTimestamp()).append(" CMD: Start Discovery for Main App WS (").append(MAIN_APP_WS_SERVICE_NAME_FILTER).append(")\n");
            textViewLastMessage.setText("Last WS Msg: None"); // Reset
        }
        updateUIForDiscovering();
    }

    private void stopActiveDiscoveryAndReset() {
        if (nsdHelper.isDiscoveryActive()) {
            nsdHelper.stopDiscovery();
            statusLog.append(getCurrentTimestamp()).append(" CMD: Stop Discovery for ").append(activeDiscoveryServiceType).append("\n");
        }
        activeDiscoveryServiceType = null;
        resolvedEspServiceInfo = null;
        // Do not stop WebSocketService here if it's connected, only discovery.
        // WebSocketService stop/disconnect is handled by its own logic or buttonAction.
        // If it was in MAIN_APP_WS mode and WS was connected, it remains connected.
        // If it was OTA, UI simply resets.
        updateUIForInitialState(); // Or a more nuanced "discovery stopped" UI update
    }


    // --- UI Update Methods ---
    private void updateUIForInitialState() {
        textViewStatus.setText("Status: Idle. Select mode and start discovery.");
        editTextEspIpDisplay.setText("");
        buttonStartStopDiscovery.setText("Start Discovery");
        buttonStartStopDiscovery.setEnabled(true);
        radioGroupMonitorMode.setEnabled(true);

        if (currentMonitorMode == MonitorMode.OTA) {
            buttonAction.setText("Open OTA Page");
            buttonAction.setEnabled(false); // Enable when service resolved
            textViewLastMessage.setVisibility(View.GONE);
        } else if (currentMonitorMode == MonitorMode.MAIN_APP_WS) {
            buttonAction.setText("Connect WS");
            buttonAction.setEnabled(false); // Enable when service resolved
            textViewLastMessage.setVisibility(View.VISIBLE);
            textViewLastMessage.setText("Last WS Msg: None");
             if(isWebSocketServiceActive) updateUIForWsConnected(); // Persist connected state if service is active
        }
    }

    private void updateUIForDiscovering() {
        textViewStatus.setText("Status: Discovering " +
                (currentMonitorMode == MonitorMode.OTA ? "OTA Server (" + OTA_SERVICE_NAME_FILTER + ")" : "Main App WS (" + MAIN_APP_WS_SERVICE_NAME_FILTER + ")") + "...");
        editTextEspIpDisplay.setText("");
        buttonStartStopDiscovery.setText("Stop Discovery");
        buttonStartStopDiscovery.setEnabled(true);
        buttonAction.setEnabled(false); // Disabled until a service is resolved
        radioGroupMonitorMode.setEnabled(false); // Disable mode change during discovery
    }

    private void updateUIForOtaServiceResolved() {
        if (resolvedEspServiceInfo == null) return;
        String serviceName = resolvedEspServiceInfo.getServiceName();
        String host = resolvedEspServiceInfo.getHost() != null ? resolvedEspServiceInfo.getHost().getHostAddress() : "N/A";
        int port = resolvedEspServiceInfo.getPort();
        String displayText = String.format(Locale.US, "Found OTA: %s\nHost: %s:%d", serviceName, host, port);
        editTextEspIpDisplay.setText(displayText);
        textViewStatus.setText("Status: OTA Server Found!");
        buttonStartStopDiscovery.setText("Start Discovery"); // Ready for new discovery
        buttonStartStopDiscovery.setEnabled(true);
        buttonAction.setText("Open OTA Page");
        buttonAction.setEnabled(true);
        radioGroupMonitorMode.setEnabled(true);
    }

    private void updateUIForWsServiceResolvedNotConnected() {
        if (resolvedEspServiceInfo == null) return;
        String serviceName = resolvedEspServiceInfo.getServiceName();
        String host = resolvedEspServiceInfo.getHost() != null ? resolvedEspServiceInfo.getHost().getHostAddress() : "N/A";
        int port = resolvedEspServiceInfo.getPort();
        String displayText = String.format(Locale.US, "Found WS: %s\nHost: %s:%d", serviceName, host, port);
        editTextEspIpDisplay.setText(displayText);
        textViewStatus.setText("Status: Main App WS Found. Ready to connect.");
        buttonStartStopDiscovery.setText("Start Discovery"); // Ready for new discovery
        buttonStartStopDiscovery.setEnabled(true);
        buttonAction.setText("Connect WS");
        buttonAction.setEnabled(true);
        radioGroupMonitorMode.setEnabled(true);
    }

    private void updateUIForWsConnecting() {
        textViewStatus.setText("Status (WS): Connecting...");
        // buttonAction might be temporarily disabled or show "Connecting..."
        buttonAction.setEnabled(false); // Disable action while connecting
        radioGroupMonitorMode.setEnabled(false); // Keep disabled
        buttonStartStopDiscovery.setEnabled(false); // Keep disabled
    }

    private void updateUIForWsConnected() {
        if (resolvedEspServiceInfo == null && currentMonitorMode == MonitorMode.MAIN_APP_WS) {
             // If connected but resolvedEspServiceInfo is null (e.g. app restart while service was connected)
             // We don't have the display text, but WebSocketService is connected.
             textViewStatus.setText("Status (WS): Connected");
             editTextEspIpDisplay.setText("Connected (Service was running)");
        } else if (resolvedEspServiceInfo != null) {
            String serviceName = resolvedEspServiceInfo.getServiceName();
            String host = resolvedEspServiceInfo.getHost() != null ? resolvedEspServiceInfo.getHost().getHostAddress() : "N/A";
            int port = resolvedEspServiceInfo.getPort();
            String displayText = String.format(Locale.US, "WS: %s\nHost: %s:%d", serviceName, host, port);
            editTextEspIpDisplay.setText(displayText);
            textViewStatus.setText("Status (WS): Connected to " + serviceName);
        }

        buttonAction.setText("Disconnect WS");
        buttonAction.setEnabled(true);
        buttonStartStopDiscovery.setText("Start Discovery"); // Can still look for other services
        buttonStartStopDiscovery.setEnabled(true);
        radioGroupMonitorMode.setEnabled(true); // Can change mode now
    }

    private void updateUIForWsDisconnected() {
        textViewStatus.setText("Status (WS): Disconnected. Discover or Connect.");
        // editTextEspIpDisplay can retain old info or be cleared
        // If resolvedEspServiceInfo still exists, we can attempt to reconnect
        if (resolvedEspServiceInfo != null && currentMonitorMode == MonitorMode.MAIN_APP_WS) {
            updateUIForWsServiceResolvedNotConnected(); // Revert to "found, ready to connect" state
        } else {
            updateUIForInitialState(); // Or a more specific "WS was disconnected" state
        }
        buttonAction.setText("Connect WS");
        buttonAction.setEnabled(resolvedEspServiceInfo != null);
    }


    // --- NsdHelper.NsdHelperListener Implementation ---
    @Override
    public void onNsdServiceFound(NsdServiceInfo serviceInfo) {
        runOnUiThread(() -> {
            Log.i(TAG, "NSD Candidate Found: " + serviceInfo.getServiceName() + " Type: " + serviceInfo.getServiceType());
            // Update status to show a candidate is being processed, only if discovery is active for this type.
            // This check ensures that if a user quickly switches modes, a "found" message for an old discovery type isn't shown.
            if (nsdHelper.isDiscoveryActive() && serviceInfo.getServiceType().startsWith(activeDiscoveryServiceType.substring(0, activeDiscoveryServiceType.indexOf("."))) ) {
                if (currentMonitorMode == MonitorMode.OTA && OTA_SERVICE_NAME_FILTER.equalsIgnoreCase(serviceInfo.getServiceName())) {
                    textViewStatus.setText("Status: OTA Candidate " + serviceInfo.getServiceName() + " found. Resolving...");
                } else if (currentMonitorMode == MonitorMode.MAIN_APP_WS && MAIN_APP_WS_SERVICE_NAME_FILTER.equalsIgnoreCase(serviceInfo.getServiceName())) {
                    textViewStatus.setText("Status: Main App Candidate " + serviceInfo.getServiceName() + " found. Resolving...");
                }
            }
        });
    }

    @Override
    public void onNsdServiceResolved(NsdServiceInfo serviceInfo, String serviceTypeDiscovered) {
        runOnUiThread(() -> {
            Log.i(TAG, "NSD Service Resolved: " + serviceInfo.getServiceName() +
                    " on host " + serviceInfo.getHost() + ":" + serviceInfo.getPort() +
                    " (Original discovery type: " + serviceTypeDiscovered + ")");

            // Critical: Ensure this resolved service matches the *currently active* discovery type and mode
            if (!nsdHelper.isDiscoveryActive() && !serviceTypeDiscovered.equals(activeDiscoveryServiceType)) {
                 Log.w(TAG, "Resolved service " + serviceInfo.getServiceName() + " for a discovery ("+serviceTypeDiscovered+") that is no longer active or matches current mode. Ignoring.");
                 return;
            }

            resolvedEspServiceInfo = serviceInfo;
            statusLog.append(getCurrentTimestamp()).append(" NSD: Resolved ").append(serviceInfo.getServiceName()).append(" at ").append(serviceInfo.getHost().getHostAddress()).append(":").append(serviceInfo.getPort()).append("\n");

            if (currentMonitorMode == MonitorMode.OTA && OTA_SERVICE_TYPE.equals(serviceTypeDiscovered) && OTA_SERVICE_NAME_FILTER.equalsIgnoreCase(serviceInfo.getServiceName())) {
                updateUIForOtaServiceResolved();
                nsdHelper.stopDiscovery(); // Found our target
            } else if (currentMonitorMode == MonitorMode.MAIN_APP_WS && MAIN_APP_WS_SERVICE_TYPE.equals(serviceTypeDiscovered) && MAIN_APP_WS_SERVICE_NAME_FILTER.equalsIgnoreCase(serviceInfo.getServiceName())) {
                updateUIForWsServiceResolvedNotConnected();
                nsdHelper.stopDiscovery(); // Found our target
            } else {
                Log.w(TAG, "Resolved service '" + serviceInfo.getServiceName() + "' of type '" + serviceTypeDiscovered + "' but current mode/filter does not match. Mode: " + currentMonitorMode);
                // If it doesn't match, don't stop discovery, let it continue for the right service.
            }
        });
    }

    @Override
    public void onNsdServiceLost(NsdServiceInfo serviceInfo) {
        runOnUiThread(() -> {
            Log.w(TAG, "NSD Service Lost: " + serviceInfo.getServiceName());
            statusLog.append(getCurrentTimestamp()).append(" NSD: Lost ").append(serviceInfo.getServiceName()).append("\n");

            if (resolvedEspServiceInfo != null && serviceInfo.getServiceName().equalsIgnoreCase(resolvedEspServiceInfo.getServiceName())) {
                resolvedEspServiceInfo = null;
                Toast.makeText(this, serviceInfo.getServiceName() + " lost.", Toast.LENGTH_SHORT).show();

                if (currentMonitorMode == MonitorMode.MAIN_APP_WS && isWebSocketServiceActive) {
                    // If it was the WebSocket service that got lost, tell WebSocketService to disconnect/handle it
                    Intent serviceIntent = new Intent(this, WebSocketService.class);
                    serviceIntent.setAction(WebSocketService.ACTION_DISCONNECT); // Or a specific "handle_lost_server" action
                    startService(serviceIntent);
                    updateUIForWsDisconnected();
                } else {
                    updateUIForInitialState(); // Reset to allow new discovery
                }
                // Optionally restart discovery for the current mode if desired
                // if (!nsdHelper.isDiscoveryActive()) {
                //     startDiscoveryForCurrentMode();
                // }
            }
        });
    }

    @Override
    public void onNsdDiscoveryFailed(String serviceType, int errorCode) {
        runOnUiThread(() -> {
            Log.e(TAG, "NSD Discovery Failed for " + serviceType + ". Error: " + errorCode);
            statusLog.append(getCurrentTimestamp()).append(" NSD: Discovery Failed (").append(serviceType).append("). Error: ").append(errorCode).append("\n");
            textViewStatus.setText("Status: Discovery Failed (" + serviceTypeToShortName(serviceType) + "). Check Network/Permissions.");
            updateUIForInitialState(); // Reset UI
            buttonStartStopDiscovery.setText("Start Discovery"); // Ensure it says start
            radioGroupMonitorMode.setEnabled(true);
        });
    }

    @Override
    public void onNsdResolveFailed(NsdServiceInfo serviceInfo, int errorCode) {
        runOnUiThread(() -> {
            Log.e(TAG, "NSD Resolve Failed for " + serviceInfo.getServiceName() + ". Error: " + errorCode);
            statusLog.append(getCurrentTimestamp()).append(" NSD: Resolve Failed for ").append(serviceInfo.getServiceName()).append(". Error: ").append(errorCode).append("\n");
            textViewStatus.setText("Status: Failed to resolve " + serviceInfo.getServiceName() + ". Still searching if discovery active...");
            // Don't necessarily change UI too much, discovery might still be running for other candidates.
            // If discovery stops due to this, onNsdDiscoveryStopped will handle UI reset.
        });
    }

    @Override
    public void onNsdDiscoveryStarted(String serviceType) {
        runOnUiThread(() -> {
            Log.i(TAG, "NSD Discovery actually started for " + serviceType);
            activeDiscoveryServiceType = serviceType; // Confirm active discovery type
            updateUIForDiscovering();
        });
    }

    @Override
    public void onNsdDiscoveryStopped(String serviceType) {
        runOnUiThread(() -> {
            Log.i(TAG, "NSD Discovery actually stopped for " + serviceType);
            activeDiscoveryServiceType = null; // Clear active discovery type
            // If discovery stopped and we haven't resolved a service for the current mode, reset UI.
            // If a service IS resolved, the UI should already reflect that.
            if (resolvedEspServiceInfo == null) {
                updateUIForInitialState();
            } else {
                // If a service IS resolved, ensure UI matches (e.g. if stopped manually after resolve)
                if (currentMonitorMode == MonitorMode.OTA) updateUIForOtaServiceResolved();
                else if (currentMonitorMode == MonitorMode.MAIN_APP_WS && !isWebSocketServiceActive) updateUIForWsServiceResolvedNotConnected();
                else if (currentMonitorMode == MonitorMode.MAIN_APP_WS && isWebSocketServiceActive) updateUIForWsConnected();
            }
            buttonStartStopDiscovery.setText("Start Discovery");
            radioGroupMonitorMode.setEnabled(true);
        });
    }

    // --- Helper Methods ---
    private String getCurrentTimestamp() {
        return new SimpleDateFormat("yyyy-MM-dd HH:mm:ss", Locale.getDefault()).format(new Date());
    }

    private String serviceTypeToShortName(String serviceType) {
        if (OTA_SERVICE_TYPE.equals(serviceType)) return "OTA";
        if (MAIN_APP_WS_SERVICE_TYPE.equals(serviceType)) return "MainAppWS";
        return "Unknown";
    }

    private void saveLogToFile(Uri uri) {
        try (OutputStream outputStream = getContentResolver().openOutputStream(uri);
             OutputStreamWriter writer = new OutputStreamWriter(outputStream)) {
            writer.write("--- Status Log ---\n");
            writer.write(statusLog.toString());
            if (currentMonitorMode == MonitorMode.MAIN_APP_WS || messageLog.length() > 0) {
                writer.write("\n--- WebSocket Message Log ---\n");
                writer.write(messageLog.toString());
            }
            writer.flush();
            Toast.makeText(this, "Log saved successfully", Toast.LENGTH_LONG).show();
        } catch (IOException e) {
            Log.e(TAG, "Error saving log to file", e);
            Toast.makeText(this, "Error saving log: " + e.getMessage(), Toast.LENGTH_LONG).show();
        }
    }

    private void askNotificationPermission() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
            if (ContextCompat.checkSelfPermission(this, Manifest.permission.POST_NOTIFICATIONS) !=
                    PackageManager.PERMISSION_GRANTED) {
                requestPermissionLauncher.launch(Manifest.permission.POST_NOTIFICATIONS);
            }
        }
    }

    // --- Lifecycle Methods ---
    @Override
    protected void onResume() {
        super.onResume();
        if (currentMonitorMode == MonitorMode.MAIN_APP_WS && !isServiceReceiverRegistered) {
            IntentFilter filter = new IntentFilter();
            filter.addAction(WebSocketService.ACTION_STATUS_UPDATE);
            filter.addAction(WebSocketService.ACTION_MESSAGE_RECEIVED);
            LocalBroadcastManager.getInstance(this).registerReceiver(serviceUpdateReceiver, filter);
            isServiceReceiverRegistered = true;
        }
        // If discovery was active and app was paused, it might have been stopped by OS or NsdHelper.
        // Re-evaluate UI based on current state.
        if (nsdHelper.isDiscoveryActive()){
            updateUIForDiscovering();
        } else if (resolvedEspServiceInfo != null) {
             if(currentMonitorMode == MonitorMode.OTA) updateUIForOtaServiceResolved();
             else if (currentMonitorMode == MonitorMode.MAIN_APP_WS && isWebSocketServiceActive) updateUIForWsConnected();
             else if (currentMonitorMode == MonitorMode.MAIN_APP_WS && !isWebSocketServiceActive) updateUIForWsServiceResolvedNotConnected();
        } else {
            updateUIForInitialState();
        }
    }

    @Override
    protected void onPause() {
        super.onPause();
        // Optional: Stop discovery when app is paused to save battery,
        // but user might want it running in background if connected to WS.
        // For simplicity, we are not stopping discovery here, but you might want to.
        // if (nsdHelper.isDiscoveryActive()) {
        //     nsdHelper.stopDiscovery();
        // }
    }

    @Override
    protected void onDestroy() {
        if (isServiceReceiverRegistered) {
            LocalBroadcastManager.getInstance(this).unregisterReceiver(serviceUpdateReceiver);
            isServiceReceiverRegistered = false;
        }
        nsdHelper.tearDown(); // Important!

        // Decide if WebSocketService should be stopped
        // If you want it to stop when MainActivity is destroyed:
        if (currentMonitorMode == MonitorMode.MAIN_APP_WS && isWebSocketServiceActive) {
             if (!isChangingConfigurations()) { // Don't stop on rotation
                Log.d(TAG, "onDestroy: Stopping WebSocketService.");
                Intent stopIntent = new Intent(this, WebSocketService.class);
                stopIntent.setAction(WebSocketService.ACTION_STOP_FOREGROUND_SERVICE);
                startService(stopIntent);
                isWebSocketServiceActive = false;
             }
        }
        super.onDestroy();
    }
}

#################### START OF FILE: app\src\main\java\com\example\mybasicapp\NsdHelper.java ####################

package com.example.mybasicapp;

import android.content.Context;
import android.net.nsd.NsdManager;
import android.net.nsd.NsdServiceInfo;
import android.util.Log;

public class NsdHelper {

    private static final String TAG = "NsdHelper";

    private NsdManager nsdManager;
    private NsdManager.DiscoveryListener discoveryListener;
    private NsdManager.ResolveListener currentResolveListener;

    private boolean discoveryActive = false;
    private String serviceNameFilter; // To store the specific service name we are looking for
    private String currentServiceTypeToDiscover; // To store the type of service we are currently looking for

    // Callbacks for the client (e.g., MainActivity)
    public interface NsdHelperListener {
        void onNsdServiceResolved(NsdServiceInfo serviceInfo, String serviceTypeDiscovered); // Pass back type
        void onNsdServiceLost(NsdServiceInfo serviceInfo);
        void onNsdDiscoveryFailed(String serviceType, int errorCode);
        void onNsdResolveFailed(NsdServiceInfo serviceInfo, int errorCode);
        void onNsdServiceFound(NsdServiceInfo serviceInfo); // Candidate found
        void onNsdDiscoveryStarted(String serviceType); // Pass the type discovery started for
        void onNsdDiscoveryStopped(String serviceType); // Pass the type discovery stopped for
    }

    private NsdHelperListener listener;

    public NsdHelper(Context context, NsdHelperListener listener) {
        this.nsdManager = (NsdManager) context.getSystemService(Context.NSD_SERVICE);
        this.listener = listener;
    }

    private void initializeDiscoveryListener() {
        // This listener is re-used, so it's initialized once.
        // The filtering logic inside onServiceFound will use currentServiceTypeToDiscover.
        if (discoveryListener != null) {
            Log.d(TAG, "Discovery listener already initialized.");
            return;
        }
        discoveryListener = new NsdManager.DiscoveryListener() {
            @Override
            public void onDiscoveryStarted(String regType) {
                Log.i(TAG, "NSD Service discovery started for type: " + regType);
                discoveryActive = true;
                if (listener != null) listener.onNsdDiscoveryStarted(regType);
            }

            @Override
            public void onServiceFound(NsdServiceInfo service) {
                Log.d(TAG, "NSD Raw Service candidate found: Name='" + service.getServiceName() + "', Type='" + service.getServiceType() + "'");
                if (listener != null) {
                    listener.onNsdServiceFound(service); // Notify MainActivity about any found service
                }

                // Ensure currentServiceTypeToDiscover is not null before using substring
                if (currentServiceTypeToDiscover == null || currentServiceTypeToDiscover.isEmpty()) {
                    Log.e(TAG, "currentServiceTypeToDiscover is null or empty. Cannot filter by type.");
                    return;
                }
                // The service type from NsdServiceInfo might include ".local." at the end.
                // The currentServiceTypeToDiscover we pass might or might not have the trailing dot.
                // NsdManager expects types like "_http._tcp" or "_myespwebsocket._tcp" (without final dot for registration, with for discovery)
                // For comparison, it's safer to check if the found service type *starts with* our base type.
                String baseServiceTypeToDiscover = currentServiceTypeToDiscover.endsWith(".") ?
                                                   currentServiceTypeToDiscover.substring(0, currentServiceTypeToDiscover.length() -1) :
                                                   currentServiceTypeToDiscover;


                if (service.getServiceType() != null && service.getServiceType().toLowerCase().startsWith(baseServiceTypeToDiscover.toLowerCase())) {
                    // If a serviceNameFilter is set, ensure the found service name matches it.
                    if (serviceNameFilter != null && !serviceNameFilter.isEmpty() &&
                        !service.getServiceName().equalsIgnoreCase(serviceNameFilter)) {
                        Log.d(TAG, "Service candidate '" + service.getServiceName() + "' matches type but not name filter '" + serviceNameFilter + "'. Ignoring for resolution.");
                        return;
                    }

                    Log.i(TAG, "Matching service type (and name if filtered specifically) found: '" + service.getServiceName() + "'. Attempting to resolve.");

                    if (currentResolveListener != null) {
                        // While NsdManager doesn't have a direct "cancel resolve",
                        // creating a new listener for a new resolve request effectively supersedes the old one.
                        Log.d(TAG, "Previous resolve listener existed. A new resolve will use a new listener.");
                    }
                    currentResolveListener = new NsdManager.ResolveListener() {
                        @Override
                        public void onResolveFailed(NsdServiceInfo serviceInfo, int errorCode) {
                            Log.e(TAG, "NSD Resolve FAILED for service: '" + serviceInfo.getServiceName() + "', Error code: " + errorCode);
                            if (listener != null) listener.onNsdResolveFailed(serviceInfo, errorCode);
                            currentResolveListener = null;
                        }

                        @Override
                        public void onServiceResolved(NsdServiceInfo serviceInfo) {
                            Log.i(TAG, "NSD Service RESOLVED: Name='" + serviceInfo.getServiceName() + "', Host='" + serviceInfo.getHost() + "', Port='" + serviceInfo.getPort() + "'");
                            if (listener != null) listener.onNsdServiceResolved(serviceInfo, currentServiceTypeToDiscover); // Pass back the originally requested type
                            currentResolveListener = null;
                        }
                    };
                    nsdManager.resolveService(service, currentResolveListener);
                } else {
                     Log.d(TAG, "Service '" + service.getServiceName() + "' with type '" + service.getServiceType() + "' does not match expected type prefix '" + baseServiceTypeToDiscover + "'. Ignoring resolution.");
                }
            }

            @Override
            public void onServiceLost(NsdServiceInfo service) {
                Log.w(TAG, "NSD Service lost: Name='" + service.getServiceName() + "', Type='" + service.getServiceType() + "'");
                if (listener != null) listener.onNsdServiceLost(service);
            }

            @Override
            public void onDiscoveryStopped(String serviceType) {
                Log.i(TAG, "NSD Service discovery stopped for type: " + serviceType);
                discoveryActive = false; // This callback confirms discovery has stopped
                if (listener != null) listener.onNsdDiscoveryStopped(serviceType);
            }

            @Override
            public void onStartDiscoveryFailed(String serviceType, int errorCode) {
                Log.e(TAG, "NSD Service discovery start FAILED for type '" + serviceType + "', Error code: " + errorCode);
                discoveryActive = false;
                if (listener != null) listener.onNsdDiscoveryFailed(serviceType, errorCode);
            }

            @Override
            public void onStopDiscoveryFailed(String serviceType, int errorCode) {
                Log.e(TAG, "NSD Service discovery stop FAILED for type '" + serviceType + "', Error code: " + errorCode);
                // This can happen if stopServiceDiscovery is called when discovery was not running
                // or if the listener wasn't the one registered.
                // We should ensure our 'discoveryActive' flag is consistent.
                discoveryActive = false; // Assume it's stopped if stop failed.
                 if (listener != null) {
                    // Optionally, notify listener or just log.
                    // listener.onNsdDiscoveryStopped(serviceType); // Or a specific error callback for this
                 }
            }
        };
    }

    public void discoverServices(String targetServiceNameFilter, String serviceTypeToScan) {
        if (serviceTypeToScan == null || serviceTypeToScan.isEmpty()) {
            Log.e(TAG, "Service type to scan cannot be null or empty.");
            if (listener != null) listener.onNsdDiscoveryFailed("", NsdManager.FAILURE_BAD_PARAMETERS);
            return;
        }

        if (discoveryActive) {
            Log.d(TAG, "Discovery already active for " + currentServiceTypeToDiscover + ". Stopping first.");
            stopDiscovery(); // Stop previous before starting new, to ensure clean state.
            // Consider a small delay or a callback mechanism if stopDiscovery is asynchronous and you need to wait.
            // For now, we'll proceed assuming stopDiscovery acts relatively quickly or next discoverServices call handles it.
        }

        this.serviceNameFilter = targetServiceNameFilter;
        this.currentServiceTypeToDiscover = serviceTypeToScan.endsWith(".") ? serviceTypeToScan : serviceTypeToScan + "."; // Ensure trailing dot for discovery type

        if (discoveryListener == null) { // Initialize if not already
            initializeDiscoveryListener();
        }
         if (discoveryListener == null) { // Should not happen if initializeDiscoveryListener works
             Log.e(TAG, "Cannot start discovery: DiscoveryListener is null post-init.");
             if (listener != null) listener.onNsdDiscoveryFailed(currentServiceTypeToDiscover, -1 /* custom error */);
             return;
        }

        Log.d(TAG, "Attempting to start NSD service discovery for type: " + currentServiceTypeToDiscover +
                (serviceNameFilter != null && !serviceNameFilter.isEmpty() ? " with name filter: " + serviceNameFilter : ""));
        try {
            nsdManager.discoverServices(currentServiceTypeToDiscover, NsdManager.PROTOCOL_DNS_SD, discoveryListener);
            // onDiscoveryStarted callback will set discoveryActive = true;
        } catch (Exception e) {
            Log.e(TAG, "Exception during nsdManager.discoverServices call: " + e.getMessage(), e);
            discoveryActive = false; // Ensure it's false if call fails
            if (listener != null) listener.onNsdDiscoveryFailed(currentServiceTypeToDiscover, NsdManager.FAILURE_INTERNAL_ERROR);
        }
    }

    public void stopDiscovery() {
        if (discoveryListener != null && discoveryActive) {
            try {
                Log.d(TAG, "Attempting to stop NSD service discovery for type: " + currentServiceTypeToDiscover);
                nsdManager.stopServiceDiscovery(discoveryListener);
                // onDiscoveryStopped callback will set discoveryActive = false;
            } catch (IllegalArgumentException e) {
                // This can happen if the listener was already unregistered or never registered.
                Log.w(TAG, "Error stopping discovery (IllegalArgumentException): " + e.getMessage() + ". Already stopped or not started correctly?");
                discoveryActive = false; // Force reset if error
            } catch (Exception e) {
                Log.e(TAG, "Exception during nsdManager.stopServiceDiscovery: " + e.getMessage(), e);
                discoveryActive = false; // Force reset if error
            }
        } else {
            Log.d(TAG, "No active NSD discovery to stop, or listener is null, or discoveryActive is false.");
            discoveryActive = false; // Ensure flag is reset
        }
    }

    public void tearDown() {
        Log.d(TAG, "Tearing down NsdHelper.");
        stopDiscovery(); // Ensure discovery is stopped
        this.listener = null;
        this.discoveryListener = null; // Dereference listener
        this.currentResolveListener = null; // Dereference listener
        // NsdManager itself doesn't have a close/unregister method.
        // It's a system service, managed by Android.
        this.nsdManager = null;
        discoveryActive = false;
    }

    public boolean isDiscoveryActive() {
        return discoveryActive;
    }
}

#################### START OF FILE: app\src\main\java\com\example\mybasicapp\WebSocketService.java ####################

package com.example.mybasicapp;

import android.app.Notification;
import android.app.NotificationChannel;
import android.app.NotificationManager;
import android.app.PendingIntent;
import android.app.Service;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.content.pm.ServiceInfo;
import android.os.Build;
import android.os.Handler;
import android.os.IBinder;
import android.os.Looper;
import android.util.Log;

import androidx.annotation.Nullable;
import androidx.core.app.ActivityCompat;
import androidx.core.app.NotificationCompat;
import androidx.core.app.NotificationManagerCompat;
import androidx.localbroadcastmanager.content.LocalBroadcastManager;

import org.json.JSONException;
import org.json.JSONObject;

import java.util.Locale;
import java.util.concurrent.TimeUnit;

import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.Response;
import okhttp3.WebSocket;
import okhttp3.WebSocketListener;
import okio.ByteString;

public class WebSocketService extends Service {

    private static final String TAG = "WebSocketService";
    public static final String ACTION_START_FOREGROUND_SERVICE = "ACTION_START_FOREGROUND_SERVICE";
    public static final String ACTION_STOP_FOREGROUND_SERVICE = "ACTION_STOP_FOREGROUND_SERVICE";
    public static final String ACTION_CONNECT = "ACTION_CONNECT";
    public static final String ACTION_DISCONNECT = "ACTION_DISCONNECT";
    public static final String EXTRA_IP_ADDRESS = "EXTRA_IP_ADDRESS"; // This will be the full ws:// URL

    public static final String ACTION_STATUS_UPDATE = "com.example.mybasicapp.STATUS_UPDATE";
    public static final String ACTION_MESSAGE_RECEIVED = "com.example.mybasicapp.MESSAGE_RECEIVED";
    public static final String EXTRA_STATUS = "EXTRA_STATUS";
    public static final String EXTRA_MESSAGE_TITLE = "EXTRA_MESSAGE_TITLE";
    public static final String EXTRA_MESSAGE_BODY = "EXTRA_MESSAGE_BODY";


    private static final String NOTIFICATION_CHANNEL_ID_SERVICE = "web_socket_service_channel";
    private static final String NOTIFICATION_CHANNEL_ID_MESSAGES = "esp32_notifications"; // For actual alert notifications
    private static final int SERVICE_NOTIFICATION_ID = 1;
    private static final int MESSAGE_NOTIFICATION_ID = 101; // For messages from ESP32

    private OkHttpClient httpClient;
    private WebSocket webSocket;
    private String currentWebSocketUrl; // Changed from currentIpAddress to reflect it's a full URL
    private Handler handler = new Handler(Looper.getMainLooper());
    private boolean isServiceStarted = false;
    private int retryCount = 0;
    private static final int MAX_RETRY_COUNT = 5; // Max number of retries
    private static final long RETRY_DELAY_MS = 5000; // 5 seconds delay

    @Override
    public void onCreate() {
        super.onCreate();
        Log.d(TAG, "Service onCreate");
        httpClient = new OkHttpClient.Builder()
                .pingInterval(30, TimeUnit.SECONDS) // Keep the connection alive
                .connectTimeout(10, TimeUnit.SECONDS)
                .readTimeout(10, TimeUnit.SECONDS)
                .writeTimeout(10, TimeUnit.SECONDS)
                .retryOnConnectionFailure(true)
                .build();
        createNotificationChannel(NOTIFICATION_CHANNEL_ID_SERVICE, "WebSocket Service Status", NotificationManager.IMPORTANCE_LOW);
        createNotificationChannel(NOTIFICATION_CHANNEL_ID_MESSAGES, getString(R.string.channel_name), NotificationManager.IMPORTANCE_HIGH);
    }

    @Override
    public int onStartCommand(Intent intent, int flags, int startId) {
        if (intent != null) {
            String action = intent.getAction();
            Log.d(TAG, "onStartCommand, Action: " + action);

            if (ACTION_START_FOREGROUND_SERVICE.equals(action)) {
                if (!isServiceStarted) {
                    startForegroundServiceWithNotification("Service Active. Not connected.");
                    isServiceStarted = true;
                }
            } else if (ACTION_STOP_FOREGROUND_SERVICE.equals(action)) {
                stopService();
                return START_NOT_STICKY;
            } else if (ACTION_CONNECT.equals(action) && isServiceStarted) {
                String wsUrlFromIntent = intent.getStringExtra(EXTRA_IP_ADDRESS); // This is the full URL
                if (wsUrlFromIntent != null && !wsUrlFromIntent.isEmpty()) {
                    currentWebSocketUrl = wsUrlFromIntent; // Store the full URL
                    connectWebSocket(currentWebSocketUrl);
                    retryCount = 0; // Reset retry count on new manual connect attempt
                } else {
                    Log.e(TAG, "WebSocket URL is null or empty in ACTION_CONNECT");
                    sendBroadcastStatus("Error: WebSocket URL missing");
                }
            } else if (ACTION_DISCONNECT.equals(action) && isServiceStarted) {
                disconnectWebSocket();
            }
        }
        return START_STICKY;
    }


    private void startForegroundServiceWithNotification(String statusText) {
        Intent notificationIntent = new Intent(this, MainActivity.class);
        PendingIntent pendingIntent = PendingIntent.getActivity(this, 0,
                notificationIntent, PendingIntent.FLAG_IMMUTABLE | PendingIntent.FLAG_UPDATE_CURRENT);

        Notification notification = new NotificationCompat.Builder(this, NOTIFICATION_CHANNEL_ID_SERVICE)
                .setContentTitle(getString(R.string.app_name) + " Service")
                .setContentText(statusText)
                .setSmallIcon(R.drawable.ic_stat_service)
                .setContentIntent(pendingIntent)
                .setOngoing(true)
                .setPriority(NotificationCompat.PRIORITY_LOW)
                .build();

        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
            startForeground(SERVICE_NOTIFICATION_ID, notification, ServiceInfo.FOREGROUND_SERVICE_TYPE_DATA_SYNC);
        } else {
            startForeground(SERVICE_NOTIFICATION_ID, notification);
        }
        Log.d(TAG, "Service started in foreground.");
    }

    private void updateServiceNotification(String text) {
        NotificationManager manager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);
        if (manager == null || !isServiceStarted) return;

        Intent notificationIntent = new Intent(this, MainActivity.class);
        PendingIntent pendingIntent = PendingIntent.getActivity(this, 0,
                notificationIntent, PendingIntent.FLAG_IMMUTABLE | PendingIntent.FLAG_UPDATE_CURRENT);

        Notification notification = new NotificationCompat.Builder(this, NOTIFICATION_CHANNEL_ID_SERVICE)
                .setContentTitle(getString(R.string.app_name) + " Service")
                .setContentText(text)
                .setSmallIcon(R.drawable.ic_stat_service)
                .setContentIntent(pendingIntent)
                .setOngoing(true)
                .setPriority(NotificationCompat.PRIORITY_LOW)
                .build();
        manager.notify(SERVICE_NOTIFICATION_ID, notification);
    }


    private void connectWebSocket(String wsUrl) {
        if (wsUrl == null || wsUrl.isEmpty()) {
            Log.e(TAG, "connectWebSocket called with null or empty URL.");
            sendBroadcastStatus("Error: Invalid ESP32 Address");
            return;
        }
        if (webSocket != null) {
            Log.d(TAG, "Closing existing WebSocket before reconnecting.");
            webSocket.close(1001, "Client reconnecting"); // 1001 indicates going away
            webSocket = null;
        }

        Request request = new Request.Builder().url(wsUrl).build();
        final String displayUrl = wsUrl.replaceFirst("ws://", "").replaceFirst("/ws", ""); // For shorter display
        sendBroadcastStatus("Connecting to " + displayUrl + "...");
        updateServiceNotification("Connecting to ESP32...");
        Log.i(TAG, "Attempting to connect to: " + wsUrl);

        webSocket = httpClient.newWebSocket(request, new WebSocketListener() {
            @Override
            public void onOpen(WebSocket ws, Response response) {
                super.onOpen(ws, response);
                Log.i(TAG, "WebSocket Opened with " + displayUrl);
                sendBroadcastStatus("Connected to ESP32");
                updateServiceNotification("Connected to ESP32");
                retryCount = 0; // Reset retry count on successful connection
            }

            @Override
            public void onMessage(WebSocket ws, String text) {
                super.onMessage(ws, text);
                Log.i(TAG, "Receiving from ESP32: " + text);
                try {
                    JSONObject json = new JSONObject(text);
                    String event = json.optString("event");

                    if ("motion_detected".equals(event)) {
                        double distanceCm = json.optDouble("distance_cm", -1.0);
                        //double thresholdCm = json.optDouble("threshold_cm", -1.0); // Also available
                        //long timestamp = json.optLong("timestamp", 0); // Also available

                        String title = "Motion Alert!";
                        String messageBody = String.format(Locale.getDefault(), "Motion detected at %.1f cm.", distanceCm);

                        sendBroadcastMessage(title, messageBody);
                        showDataNotification(title, messageBody);
                    } else {
                        // Handle other event types or generic messages if your ESP32 sends them
                        String title = json.optString("title", "ESP32 Info");
                        String messageBody = json.optString("message", text); // Fallback to raw text
                        sendBroadcastMessage(title, messageBody);
                        // Optionally show notification for other events too
                        // showDataNotification(title, messageBody);
                        Log.d(TAG, "Received non-motion event or generic message: " + text);
                    }

                } catch (JSONException e) {
                    Log.e(TAG, "Error parsing JSON from WebSocket: " + e.getMessage() + ". Raw: " + text);
                    // If not JSON, treat as a simple message
                    sendBroadcastMessage("ESP32 Message", text);
                    showDataNotification("ESP32 Message", text);
                }
            }

            @Override
            public void onMessage(WebSocket ws, ByteString bytes) {
                super.onMessage(ws, bytes);
                Log.i(TAG, "Receiving bytes: " + bytes.hex() + " (not handled)");
            }

            @Override
            public void onClosing(WebSocket ws, int code, String reason) {
                super.onClosing(ws, code, reason);
                Log.i(TAG, "WebSocket Closing: " + code + " / " + reason);
                // ws.close(1000, null); // Not needed, OkHttp handles this
            }

            @Override
            public void onClosed(WebSocket ws, int code, String reason) {
                super.onClosed(ws, code, reason);
                Log.i(TAG, "WebSocket Closed: " + code + " / " + reason + " for URL: " + wsUrl);
                sendBroadcastStatus("Disconnected");
                updateServiceNotification("Disconnected from ESP32");
                if (WebSocketService.this.webSocket == ws) { // Ensure it's the current socket
                    WebSocketService.this.webSocket = null;
                }
            }

            @Override
            public void onFailure(WebSocket ws, Throwable t, Response response) {
                super.onFailure(ws, t, response);
                String errorMsg = (t != null && t.getMessage() != null) ? t.getMessage() : "Unknown connection error";
                Log.e(TAG, "WebSocket Failure for " + wsUrl + ": " + errorMsg, t);
                sendBroadcastStatus("Connection Failed: " + errorMsg);
                updateServiceNotification("Connection Failed");
                if (WebSocketService.this.webSocket == ws) { // Ensure it's the current socket
                    WebSocketService.this.webSocket = null;
                }

                // Implement retry logic with backoff if connection fails and service is still running
                if (isServiceStarted && currentWebSocketUrl != null && !currentWebSocketUrl.isEmpty()) {
                    if (retryCount < MAX_RETRY_COUNT) {
                        retryCount++;
                        long delay = RETRY_DELAY_MS * retryCount; // Exponential backoff could be used too
                        Log.d(TAG, "Retrying connection to: " + currentWebSocketUrl + " (Attempt " + retryCount + ") in " + delay + "ms");
                        sendBroadcastStatus("Connection Failed. Retrying (" + retryCount + "/" + MAX_RETRY_COUNT + ")...");
                        updateServiceNotification("Connection Failed. Retrying...");
                        handler.postDelayed(() -> {
                            if (isServiceStarted) { // Check again if service is still started before retrying
                                connectWebSocket(currentWebSocketUrl);
                            }
                        }, delay);
                    } else {
                        Log.e(TAG, "Max retry attempts reached for " + currentWebSocketUrl + ". Giving up.");
                        sendBroadcastStatus("Connection Failed: Max retries reached.");
                        updateServiceNotification("Connection Failed. Max retries.");
                    }
                }
            }
        });
    }

    private void disconnectWebSocket() {
        handler.removeCallbacksAndMessages(null); // Cancel any pending retries
        retryCount = 0;
        if (webSocket != null) {
            webSocket.close(1000, "User requested disconnect");
            webSocket = null; // Important to nullify immediately
        }
        sendBroadcastStatus("Disconnected by user");
        updateServiceNotification("Disconnected by user");
        Log.i(TAG, "WebSocket Disconnected by user action.");
        currentWebSocketUrl = null; // Clear the URL so it doesn't try to auto-reconnect to old one
    }


    private void sendBroadcastStatus(String status) {
        Intent intent = new Intent(ACTION_STATUS_UPDATE);
        intent.putExtra(EXTRA_STATUS, status);
        LocalBroadcastManager.getInstance(this).sendBroadcast(intent);
    }

    private void sendBroadcastMessage(String title, String body) {
        Intent intent = new Intent(ACTION_MESSAGE_RECEIVED);
        intent.putExtra(EXTRA_MESSAGE_TITLE, title);
        intent.putExtra(EXTRA_MESSAGE_BODY, body);
        LocalBroadcastManager.getInstance(this).sendBroadcast(intent);
    }

    private void createNotificationChannel(String channelId, String channelName, int importance) {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            NotificationChannel channel = new NotificationChannel(channelId, channelName, importance);
            if (channelId.equals(NOTIFICATION_CHANNEL_ID_MESSAGES)) {
                channel.setDescription(getString(R.string.channel_description));
                // Optional: Configure sound, vibration, etc. for alert notifications
                // channel.setSound(RingtoneManager.getDefaultUri(RingtoneManager.TYPE_NOTIFICATION), null);
                // channel.enableVibration(true);
                // channel.setVibrationPattern(new long[]{0, 500, 200, 500});
            } else {
                 channel.setDescription("Channel for ESP32 Sync Service status");
            }
            NotificationManager notificationManager = getSystemService(NotificationManager.class);
            if (notificationManager != null) {
                notificationManager.createNotificationChannel(channel);
            }
        }
    }

    private void showDataNotification(String title, String message) {
        // Check for POST_NOTIFICATIONS permission (Android 13+)
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
            if (ActivityCompat.checkSelfPermission(this, android.Manifest.permission.POST_NOTIFICATIONS) != PackageManager.PERMISSION_GRANTED) {
                Log.w(TAG, "POST_NOTIFICATIONS permission not granted. Cannot show data notification.");
                // Service cannot request permission. Activity must handle it.
                // Optionally send a broadcast to Activity to inform user about missing permission.
                return;
            }
        }

        Intent intent = new Intent(this, MainActivity.class);
        intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP | Intent.FLAG_ACTIVITY_SINGLE_TOP); // Bring to front or launch
        PendingIntent pendingIntent = PendingIntent.getActivity(this,
                (int) System.currentTimeMillis(), // Unique request code to ensure PendingIntent updates if extras change
                intent,
                PendingIntent.FLAG_UPDATE_CURRENT | PendingIntent.FLAG_IMMUTABLE);


        NotificationCompat.Builder builder = new NotificationCompat.Builder(this, NOTIFICATION_CHANNEL_ID_MESSAGES)
                .setSmallIcon(R.drawable.ic_stat_message)
                .setContentTitle(title)
                .setContentText(message)
                .setPriority(NotificationCompat.PRIORITY_HIGH) // Ensure it pops up
                .setAutoCancel(true) // Dismiss notification when tapped
                .setContentIntent(pendingIntent)
                .setDefaults(Notification.DEFAULT_ALL); // Use default sound, vibration, light

        NotificationManagerCompat notificationManager = NotificationManagerCompat.from(this);
        try {
            // MESSAGE_NOTIFICATION_ID should be unique for each type of notification if you want them to stack or update correctly
            // Or use a dynamic ID if you want multiple distinct motion alerts. For now, one ID updates previous.
            notificationManager.notify(MESSAGE_NOTIFICATION_ID, builder.build());
        } catch (SecurityException e) {
            // This can happen if permissions are revoked while app is running.
            Log.e(TAG, "SecurityException while trying to post data notification: " + e.getMessage());
        }
    }


    private void stopService() {
        Log.d(TAG, "stopService called in WebSocketService");
        handler.removeCallbacksAndMessages(null); // Cancel any pending retries
        retryCount = 0;
        disconnectWebSocket(); // Ensure WebSocket is closed first
        if (isServiceStarted) {
            stopForeground(true); // true to remove the notification
            stopSelf(); // Stop the service instance
            isServiceStarted = false; // Update flag
            // sendBroadcastStatus("Service Stopped"); // MainActivity will update based on its own logic
        }
        Log.d(TAG, "WebSocketService fully stopped.");
    }


    @Nullable
    @Override
    public IBinder onBind(Intent intent) {
        return null; // We are not using binding, so return null
    }

    @Override
    public void onDestroy() {
        Log.d(TAG, "Service onDestroy");
        stopService(); // Ensure everything is cleaned up
        if (httpClient != null) {
            // Gracefully shut down OkHttpClient resources
            httpClient.dispatcher().executorService().shutdown();
            httpClient.connectionPool().evictAll();
            try {
                if (httpClient.cache() != null) {
                    httpClient.cache().close();
                }
            } catch (Exception e) {
                Log.e(TAG, "Error closing OkHttp cache", e);
            }
        }
        super.onDestroy();
    }
}

#################### START OF FILE: app\src\main\res\drawable\ic_stat_message.xml ####################

<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24.0"
    android:viewportHeight="24.0"
    android:tint="?attr/colorControlNormal">
  <path
      android:fillColor="@android:color/white"
      android:pathData="M20,2L4,2c-1.1,0 -1.99,0.9 -1.99,2L2,22l4,-4h14c1.1,0 2,-0.9 2,-2L22,4c0,-1.1 -0.9,-2 -2,-2zM18,14L6,14v-2h12v2zM18,11L6,11L6,9h12v2zM18,8L6,8L6,6h12v2z"/>
</vector>

#################### START OF FILE: app\src\main\res\drawable\ic_stat_service.xml ####################

<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24.0"
    android:viewportHeight="24.0"
    android:tint="?attr/colorControlNormal"> <!-- Or a specific color -->
  <path
      android:fillColor="@android:color/white"
      android:pathData="M12,2C6.48,2 2,6.48 2,12s4.48,10 10,10 10,-4.48 10,-10S17.52,2 12,2zM12,20c-4.41,0 -8,-3.59 -8,-8s3.59,-8 8,-8 8,3.59 8,8 -3.59,8 -8,8zM13,7h-2v6h2V7zm0,8h-2v2h2v-2z"/>
</vector>

#################### START OF FILE: app\src\main\res\layout\activity_main.xml ####################

<?xml version="1.0" encoding="utf-8"?>
<androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:padding="16dp"
    tools:context=".MainActivity">

    <EditText
        android:id="@+id/editTextEspIp"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:hint="Service Info (Auto-Discovering...)"
        android:inputType="textMultiLine|textNoSuggestions"
        android:minLines="2"
        android:maxLines="3"
        android:gravity="top|start"
        android:enabled="false"
        android:focusable="false"
        android:background="@android:color/transparent"
        android:paddingTop="8dp"
        android:paddingBottom="8dp"
        android:textSize="14sp"
        app:layout_constraintTop_toTopOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent" />

    <RadioGroup
        android:id="@+id/radioGroupMonitorMode"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:orientation="horizontal"
        android:layout_marginTop="8dp"
        app:layout_constraintTop_toBottomOf="@id/editTextEspIp"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent">

        <RadioButton
            android:id="@+id/radioButtonOta"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:text="Monitor OTA" />

        <RadioButton
            android:id="@+id/radioButtonMainApp"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:checked="true"
            android:text="Monitor Main App (WS)" />
    </RadioGroup>

    <!-- Using a single button for Start/Stop Discovery -->
    <!-- Its ID is buttonStartService, which MainActivity.java (buttonStartStopDiscovery variable) uses -->
    <Button
        android:id="@+id/buttonStartService"
        style="?android:attr/buttonBarButtonStyle"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:layout_marginTop="8dp"
        android:text="Start Discovery"
        app:layout_constraintTop_toBottomOf="@id/radioGroupMonitorMode"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent"/>

    <!-- Using a single button for Action (Open Page / Connect WS / Disconnect WS) -->
    <!-- Its ID is buttonConnect, which MainActivity.java (buttonAction variable) uses -->
    <Button
        android:id="@+id/buttonConnect"
        style="?android:attr/buttonBarButtonStyle"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:layout_marginTop="8dp"
        android:text="Action"
        app:layout_constraintTop_toBottomOf="@id/buttonStartService"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent"/>


    <Button
        android:id="@+id/buttonSaveLog"
        style="?android:attr/buttonBarButtonStyle"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:text="Save Log"
        android:layout_marginTop="8dp"
        app:layout_constraintTop_toBottomOf="@id/buttonConnect"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent" />

    <TextView
        android:id="@+id/textViewStatus"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:text="Status: Idle"
        android:layout_marginTop="16dp"
        android:textSize="16sp"
        android:textAppearance="?attr/textAppearanceBody1"
        app:layout_constraintTop_toBottomOf="@id/buttonSaveLog"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent" />

    <TextView
        android:id="@+id/textViewLastMessage"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:text="Last Message: None"
        android:layout_marginTop="8dp"
        android:textSize="14sp"
        android:textAppearance="?attr/textAppearanceBody2"
        app:layout_constraintTop_toBottomOf="@id/textViewStatus"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent"/>

</androidx.constraintlayout.widget.ConstraintLayout>

#################### START OF FILE: app\src\main\res\values\colors.xml ####################

<?xml version="1.0" encoding="utf-8"?>
<resources>
    <!-- Theme Colors for MyBasicApp -->
    <color name="my_app_primary">#1A535C</color> <!-- A dark teal/green, adjust to your liking -->
    <color name="my_app_primary_dark">#0E3F47</color> <!-- A darker shade for status bar -->
    <color name="my_app_accent">#F7B801</color> <!-- An accent color, e.g., a gold/yellow -->

    <!-- Standard Android/Material Colors (can be used as fallbacks or for other UI elements) -->
    <color name="purple_200">#FFBB86FC</color>
    <color name="purple_500">#FF6200EE</color>
    <color name="purple_700">#FF3700B3</color>
    <color name="teal_200">#FF03DAC5</color>
    <color name="teal_700">#FF018786</color>
    <color name="black">#FF000000</color>
    <color name="white">#FFFFFFFF</color>

    <!-- Text Colors -->
    <color name="text_on_primary">#FFFFFF</color>
    <color name="text_on_accent">#000000</color>
</resources>


#################### START OF FILE: app\src\main\res\values\strings.xml ####################

<resources>
    <string name="app_name">Mr Coopers ESP32</string>
    <!-- For Notification Channel for ESP32 messages -->
    <string name="channel_name">ESP32 Notifications</string>
    <string name="channel_description">Notifications received from the local ESP32 device.</string>
</resources>

#################### START OF FILE: app\src\main\res\values\themes.xml ####################

<?xml version="1.0" encoding="utf-8"?>
<resources xmlns:tools="http://schemas.android.com/tools">
    <!-- Base application theme. -->
    <style name="Theme.MyBasicApp" parent="Theme.MaterialComponents.DayNight.DarkActionBar">
        <!-- Primary brand color. -->
        <item name="colorPrimary">@color/my_app_primary</item>
        <item name="colorPrimaryVariant">@color/my_app_primary_dark</item> <!-- Used for status bar by default -->
        <item name="colorOnPrimary">@color/text_on_primary</item> <!-- Text/icon color on primary color -->

        <!-- Secondary brand color (accent color). -->
        <item name="colorSecondary">@color/my_app_accent</item>
        <item name="colorSecondaryVariant">@color/my_app_accent</item> <!-- Can be a darker/lighter shade of accent -->
        <item name="colorOnSecondary">@color/text_on_accent</item> <!-- Text/icon color on secondary color -->

        <!-- Status bar color. -->
        <!-- By default, uses colorPrimaryVariant. You can override it explicitly. -->
        <item name="android:statusBarColor" tools:targetApi="l">?attr/colorPrimaryVariant</item>

        <!-- Customize your theme here. -->
        <!-- For example, to remove the action bar if you're using a Toolbar in your layout: -->
        <!-- <item name="windowActionBar">false</item> -->
        <!-- <item name="windowNoTitle">true</item> -->

        <!-- You can also define other attributes like windowBackground, textColor, etc. -->
        <!-- <item name="android:windowBackground">@color/white</item> -->
    </style>

    <!-- Optional: A theme for a splash screen if you implement one -->
    <!--
    <style name="Theme.MyBasicApp.Splash" parent="Theme.SplashScreen">
        <item name="windowSplashScreenBackground">@color/my_app_primary</item>
        <item name="windowSplashScreenAnimatedIcon">@mipmap/ic_launcher_round</item> Comment out if no round launcher or use ic_launcher
        <item name="windowSplashScreenAnimationDuration">1000</item>
        <item name="postSplashScreenTheme">@style/Theme.MyBasicApp</item>
    </style>
    -->
</resources>

#################### START OF FILE: app\src\main\res\xml\backup_rules.xml ####################

<?xml version="1.0" encoding="utf-8"?>
<full-backup-content>
    <!-- TODO Remove the following backup rules src/main/AndroidManifext.xml#fullBackupContent-->
    <!-- <include domain="sharedpref" path="."/> -->
    <!-- <exclude domain="sharedpref" path="device.xml"/> -->
</full-backup-content>


#################### START OF FILE: app\src\main\res\xml\data_extraction_rules.xml ####################

<?xml version="1.0" encoding="utf-8"?>
<data-extraction-rules>
    <cloud-backup>
        <!-- TODO: Add cloud backup rules here. -->
        <!--
        <include domain="sharedpref" path="."/>
        <exclude domain="sharedpref" path="device.xml"/>
        -->
    </cloud-backup>
    <device-transfer>
        <!-- TODO: Add device transfer rules here. -->
        <!--
        <include domain="sharedpref" path="."/>
        <exclude domain="sharedpref" path="device.xml"/>
        -->
    </device-transfer>
</data-extraction-rules>


#################### START OF FILE: build.gradle ####################

// Top-level build file where you can add configuration options common to all sub-projects/modules.
plugins {
    // Define the Android Gradle Plugin version. 'apply false' means it's not applied to the root project,
    // but makes this version available to sub-projects like ':app'.
    // AGP 8.4.0 is a stable version compatible with Gradle 8.5.
    id("com.android.application") version "8.4.0" apply false

    // If you were using Kotlin (which this project is not, based on .java files and dependencies):
    // id("org.jetbrains.kotlin.android") version "1.9.23" apply false // Check for latest compatible Kotlin version
}

#################### START OF FILE: gradle\wrapper\gradle-wrapper.properties ####################

distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-8.6-bin.zip
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists

#################### START OF FILE: gradle.properties ####################

# Gradle JVM ARGS
# org.gradle.jvmargs=-Xmx2048m -Dfile.encoding=UTF-8 # Optional: Adjust memory if needed

# AndroidX Properties
android.useAndroidX=true
android.enableJetifier=true


#################### START OF FILE: settings.gradle ####################

pluginManagement {
    repositories {
        google()
        mavenCentral()
        gradlePluginPortal()
    }
}
dependencyResolutionManagement {
    repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)
    repositories {
        google()
        mavenCentral()
    }
}

rootProject.name = "MyBasicApp"
include ':app'
