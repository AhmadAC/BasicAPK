Total files found and listed: 29
List of all files found (paths relative to processing context):
- .github\workflows\android_ci.yml
- .gitignore
- app\build.gradle
- app\src\main\AndroidManifest.xml
- app\src\main\java\com\example\mybasicapp\MainActivity.java
- app\src\main\java\com\example\mybasicapp\NsdHelper.java
- app\src\main\java\com\example\mybasicapp\WebSocketService.java
- app\src\main\res\drawable\ic_stat_message.xml
- app\src\main\res\drawable\ic_stat_service.xml
- app\src\main\res\layout\activity_main.xml
- app\src\main\res\mipmap-hdpi\ic_launcher.png
- app\src\main\res\mipmap-hdpi\ic_launcher_round.png
- app\src\main\res\mipmap-mdpi\ic_launcher.png
- app\src\main\res\mipmap-mdpi\ic_launcher_round.png
- app\src\main\res\mipmap-xhdpi\ic_launcher.png
- app\src\main\res\mipmap-xhdpi\ic_launcher_round.png
- app\src\main\res\mipmap-xxhdpi\ic_launcher.png
- app\src\main\res\mipmap-xxhdpi\ic_launcher_round.png
- app\src\main\res\mipmap-xxxhdpi\ic_launcher.png
- app\src\main\res\mipmap-xxxhdpi\ic_launcher_round.png
- app\src\main\res\values\colors.xml
- app\src\main\res\values\strings.xml
- app\src\main\res\values\themes.xml
- app\src\main\res\xml\backup_rules.xml
- app\src\main\res\xml\data_extraction_rules.xml
- build.gradle
- gradle\wrapper\gradle-wrapper.properties
- gradle.properties
- settings.gradle

Content included for 18 file(s) with extensions: .java, .yml, .xml, .gradle, .properties

================================================================================


#################### START OF FILE: .github\workflows\android_ci.yml ####################

name: Android CI Build (Online Wrapper Init)

on:
  push:
    branches: [ "main", "master" ] # Or your default branch
  pull_request:
    branches: [ "main", "master" ]

jobs:
  build:
    env:
      # Define the Gradle version for the wrapper and build.
      # Choose a version compatible with your Android Gradle Plugin (AGP).
      # For AGP 8.4.0 (used in root build.gradle), Gradle 8.6 or higher is needed.
      # Check AGP release notes for compatibility.
      GRADLE_VERSION_TO_USE: '8.6' # Updated to Gradle 8.6

    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up JDK 17
      uses: actions/setup-java@v4
      with:
        java-version: '17' # Common for modern Android development
        distribution: 'temurin'

    # This step installs the specified version of Gradle and adds the 'gradle' command to the PATH.
    - name: Setup Gradle
      uses: gradle/actions/setup-gradle@v3 # Using setup-gradle v3
      with:
        gradle-version: ${{ env.GRADLE_VERSION_TO_USE }}
        # setup-gradle action has its own caching for Gradle User Home,
        # which can be beneficial. You can further configure it if needed.
        # See https://github.com/gradle/actions/blob/main/setup-gradle/README.md#caching

    # This step uses the 'gradle' command (from Setup Gradle step) to initialize
    # the Gradle wrapper files (gradlew, gradlew.bat, gradle-wrapper.jar, gradle-wrapper.properties)
    # in the runner's workspace. The generated gradle-wrapper.properties will point to GRADLE_VERSION_TO_USE.
    - name: Initialize Gradle Wrapper
      run: gradle wrapper --gradle-version ${{ env.GRADLE_VERSION_TO_USE }} --distribution-type bin
      # Adding --distribution-type bin to ensure it fetches the binary distribution

    - name: Grant execute permission for gradlew
      run: chmod +x ./gradlew

    # Recommended: Cache Gradle dependencies downloaded by the wrapper.
    # This cache uses the wrapper files generated in the previous step and other project build files.
    - name: Cache Gradle packages
      uses: actions/cache@v4
      with:
        path: |
          ~/.gradle/caches
          ~/.gradle/wrapper/dists
        # MODIFIED KEY: Added a version suffix '-v1' to help invalidate the cache if needed.
        # Increment this suffix (e.g., -v2, -v3) or use a dynamic value like ${{ github.run_id }}
        # if you suspect stale cache issues and need to force a fresh download.
        key: ${{ runner.os }}-gradle-${{ env.GRADLE_VERSION_TO_USE }}-${{ hashFiles('**/*.gradle*', '**/gradle-wrapper.properties', '**/libs.versions.toml') }}-v1
        restore-keys: |
          ${{ runner.os }}-gradle-${{ env.GRADLE_VERSION_TO_USE }}-

    - name: Build with Gradle Wrapper
      # Adding --stacktrace for more detailed error output if the build fails
      run: ./gradlew assembleDebug --stacktrace

    - name: Upload Debug APK
      uses: actions/upload-artifact@v4
      with:
        name: MrCoopersESP32 # Name of the artifact
        path: app/build/outputs/apk/debug/MrCoopersESP32.apk # Path to the APK
        if-no-files-found: error # Fail if APK not found

#################### START OF FILE: app\build.gradle ####################

plugins {
    id 'com.android.application'
    // id 'org.jetbrains.kotlin.android' // This project uses Java, so Kotlin plugin is not needed
}

android {
    namespace 'com.example.mybasicapp'
    compileSdk 34

    defaultConfig {
        applicationId "com.example.mybasicapp"
        minSdk 21
        targetSdk 34
        versionCode 1
        versionName "1.0"

        testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
    }

    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
        }
        debug {
            // APK naming is handled by the androidComponents block below
        }
    }

    compileOptions {
        // Align with the JDK version used in the CI workflow (JDK 17)
        sourceCompatibility JavaVersion.VERSION_17
        targetCompatibility JavaVersion.VERSION_17
    }
}

// This block customizes the output APK name for debug builds.
// It was previously (and incorrectly) in the root build.gradle.
androidComponents {
    onVariants(selector().withBuildType("debug")) { variant ->
        variant.outputs.forEach { output ->
            // Ensure we are modifying the main APK output
            // Correctly compare the outputType enum directly
            if (output.outputType == com.android.build.api.variant.VariantOutputConfiguration.OutputType.SINGLE) {
                output.outputFileName.set("MrCoopersESP32.apk")
            }
        }
    }
}

dependencies {
    // Use 'androidx.core:core' for Java projects. 'core-ktx' is for Kotlin.
    implementation 'androidx.core:core:1.12.0'
    implementation 'androidx.appcompat:appcompat:1.6.1'
    implementation 'com.google.android.material:material:1.11.0'
    implementation 'androidx.constraintlayout:constraintlayout:2.1.4'

    // Add OkHttp dependency, required for WebSocketService.java.
    // This was previously (and incorrectly) in the root build.gradle's dependencies.
    implementation("com.squareup.okhttp3:okhttp:4.12.0")

    testImplementation 'junit:junit:4.13.2'
    androidTestImplementation 'androidx.test.ext:junit:1.1.5'
    androidTestImplementation 'androidx.test.espresso:espresso-core:3.5.1'
}


#################### START OF FILE: app\src\main\AndroidManifest.xml ####################

<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools">

    <!-- Standard Network Permissions -->
    <uses-permission android:name="android.permission.INTERNET" />
    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />

    <!-- Permissions for mDNS (Network Service Discovery) -->
    <uses-permission android:name="android.permission.ACCESS_WIFI_STATE" />
    <uses-permission android:name="android.permission.CHANGE_WIFI_MULTICAST_STATE" />

    <!-- Permission for Notifications (Required for Android 13+) -->
    <uses-permission android:name="android.permission.POST_NOTIFICATIONS"/>

    <!-- Permissions for Foreground Service -->
    <uses-permission android:name="android.permission.FOREGROUND_SERVICE" />
    <uses-permission android:name="android.permission.FOREGROUND_SERVICE_DATA_SYNC" />
    <!-- If targeting Android 14 (API 34) or higher and your foreground service type is dataSync,
         you might need to explicitly declare the type again here if issues arise,
         though usually the manifest merge handles it.
    <uses-permission android:name="android.permission.FOREGROUND_SERVICE_TYPE_DATA_SYNC" />
    -->


    <application
        android:allowBackup="true"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/Theme.MyBasicApp"
        tools:targetApi="31"
        android:usesCleartextTraffic="true">
        <!-- usesCleartextTraffic="true" is important for local ws:// connections -->

        <activity
            android:name=".MainActivity"
            android:exported="true"
            android:launchMode="singleTop"> <!-- singleTop is good if opening from notification -->
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>

        <service
            android:name=".WebSocketService"
            android:enabled="true"
            android:exported="false"
            android:foregroundServiceType="dataSync" />
            <!-- foregroundServiceType is required for services targeting Android Q (API 29) and above -->

    </application>

</manifest>

#################### START OF FILE: app\src\main\java\com\example\mybasicapp\MainActivity.java ####################

package com.example.mybasicapp;

import androidx.activity.result.ActivityResultLauncher;
import androidx.activity.result.contract.ActivityResultContracts;
import androidx.appcompat.app.AppCompatActivity;
import androidx.core.content.ContextCompat;
import androidx.localbroadcastmanager.content.LocalBroadcastManager;

import android.Manifest;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.pm.PackageManager;
import android.net.nsd.NsdServiceInfo;
import android.net.Uri;
import android.os.Build;
import android.os.Bundle;
import android.util.Log;
import android.view.View;
import android.widget.Button;
import android.widget.EditText; // Will be repurposed or hidden
import android.widget.TextView;
import android.widget.Toast;

import java.io.IOException;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Locale;

public class MainActivity extends AppCompatActivity implements NsdHelper.NsdHelperListener {

    private static final String TAG = "MainActivity";

    // This MUST match MDNS_WEBSOCKET_SERVICE_NAME in your ESP32 CircuitPython code
    private static final String TARGET_ESP_SERVICE_NAME = "ESP32 Motion WebSocket";
    private static final String ESP_WEBSOCKET_PATH = "/ws"; // Path on ESP32 server for WebSocket

    private EditText editTextEspIp; // Will now display discovered IP or be hidden
    private Button buttonStartService, buttonStopService;
    private Button buttonManualConnect; // Renamed from buttonConnect
    private Button buttonDisconnect, buttonSaveLog;
    private TextView textViewStatus;
    private TextView textViewLastMessage;

    private boolean isServiceReceiverRegistered = false;
    private StringBuilder statusLog = new StringBuilder();
    private StringBuilder messageLog = new StringBuilder();

    private ActivityResultLauncher<String> createFileLauncher;
    private NsdHelper nsdHelper;
    private NsdServiceInfo resolvedEspService = null; // Store the resolved service
    private boolean isWebSocketServiceManuallyStarted = false; // Track if service was started by user

    private final ActivityResultLauncher<String> requestPermissionLauncher =
            registerForActivityResult(new ActivityResultContracts.RequestPermission(), isGranted -> {
                if (isGranted) {
                    Toast.makeText(this, "Notifications permission granted", Toast.LENGTH_SHORT).show();
                } else {
                    Toast.makeText(this, "Notifications permission denied. App may not show alerts.", Toast.LENGTH_LONG).show();
                }
            });

    private final BroadcastReceiver serviceUpdateReceiver = new BroadcastReceiver() {
        @Override
        public void onReceive(Context context, Intent intent) {
            String action = intent.getAction();
            String timestamp = getCurrentTimestamp();

            if (WebSocketService.ACTION_STATUS_UPDATE.equals(action)) {
                String status = intent.getStringExtra(WebSocketService.EXTRA_STATUS);
                String logEntry = timestamp + " Status: " + status + "\n";
                statusLog.append(logEntry);
                textViewStatus.setText("Status: " + status);
                Log.d(TAG, "Service Status Update: " + status);

                if ("Service Stopped".equals(status)) {
                    updateUIForServiceStopped();
                } else if ("Disconnected by user".equals(status) || status.startsWith("Connection Failed") || "Disconnected".equals(status) ) {
                    updateUIForDisconnected();
                } else if ("Connected to ESP32".equals(status)) {
                    updateUIForConnected();
                } else if (status.startsWith("Connecting to")) {
                    updateUIForConnecting();
                }
            } else if (WebSocketService.ACTION_MESSAGE_RECEIVED.equals(action)) {
                String title = intent.getStringExtra(WebSocketService.EXTRA_MESSAGE_TITLE);
                String body = intent.getStringExtra(WebSocketService.EXTRA_MESSAGE_BODY);
                String logEntry = timestamp + " Message: [" + title + "] " + body + "\n";
                messageLog.append(logEntry);
                textViewLastMessage.setText("Last Message: " + title + " - " + body);
                Log.d(TAG, "Service Message Received: " + title + " - " + body);
            }
        }
    };

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        editTextEspIp = findViewById(R.id.editTextEspIp);
        buttonStartService = findViewById(R.id.buttonStartService);
        buttonStopService = findViewById(R.id.buttonStopService);
        buttonManualConnect = findViewById(R.id.buttonConnect); // Assuming ID is still buttonConnect in XML
        buttonDisconnect = findViewById(R.id.buttonDisconnect);
        buttonSaveLog = findViewById(R.id.buttonSaveLog);
        textViewStatus = findViewById(R.id.textViewStatus);
        textViewLastMessage = findViewById(R.id.textViewLastMessage);

        // Repurpose or hide editTextEspIp for mDNS
        editTextEspIp.setHint("ESP32 (Auto-Discovering...)");
        editTextEspIp.setEnabled(false); // Disable input, make it display only
        editTextEspIp.setFocusable(false);


        askNotificationPermission();
        nsdHelper = new NsdHelper(this, this);

        createFileLauncher = registerForActivityResult(new ActivityResultContracts.CreateDocument("text/plain"), uri -> {
            if (uri != null) {
                saveLogToFile(uri);
            } else {
                Toast.makeText(MainActivity.this, "Log saving cancelled.", Toast.LENGTH_SHORT).show();
            }
        });

        buttonStartService.setOnClickListener(v -> {
            startWebSocketService(); // This just starts the foreground service
            isWebSocketServiceManuallyStarted = true;
            // Discovery will be triggered in onResume or if service starts successfully
        });

        buttonStopService.setOnClickListener(v -> {
            nsdHelper.stopDiscovery();
            stopWebSocketService();
            isWebSocketServiceManuallyStarted = false;
        });

        // Button "Connect" is now "Find/Connect ESP32" or can be removed if fully auto
        buttonManualConnect.setText("Find/Connect ESP32");
        buttonManualConnect.setOnClickListener(v -> {
            if (!isWebSocketServiceManuallyStarted) {
                Toast.makeText(this, "Please start the service first.", Toast.LENGTH_SHORT).show();
                return;
            }
            if (nsdHelper.isDiscoveryActive()) {
                Toast.makeText(MainActivity.this, "Already searching...", Toast.LENGTH_SHORT).show();
            } else {
                textViewStatus.setText("Status: Searching for ESP32...");
                editTextEspIp.setText("");
                resolvedEspService = null;
                nsdHelper.discoverServices(TARGET_ESP_SERVICE_NAME);
            }
            updateUIForDiscovery();
        });


        buttonDisconnect.setOnClickListener(v -> {
            Intent serviceIntent = new Intent(this, WebSocketService.class);
            serviceIntent.setAction(WebSocketService.ACTION_DISCONNECT);
            startService(serviceIntent); // Service handles the actual disconnect
        });

        buttonSaveLog.setOnClickListener(v -> {
            String fileName = "MrCoopersESP32_Log_" + new SimpleDateFormat("yyyyMMdd_HHmmss", Locale.getDefault()).format(new Date()) + ".txt";
            createFileLauncher.launch(fileName);
        });

        updateUIForServiceStopped(); // Initial state
    }

    private void updateUIForServiceStopped() {
        textViewStatus.setText("Status: Service Stopped. Tap 'Start Svc'.");
        buttonStartService.setEnabled(true);
        buttonStopService.setEnabled(false);
        buttonManualConnect.setEnabled(false);
        buttonDisconnect.setEnabled(false);
        editTextEspIp.setText("");
        resolvedEspService = null;
    }

    private void updateUIForServiceStarted() {
        textViewStatus.setText("Status: Service Started. Searching ESP32...");
        buttonStartService.setEnabled(false);
        buttonStopService.setEnabled(true);
        buttonManualConnect.setEnabled(true); // Allow manual search trigger
        buttonDisconnect.setEnabled(false);
    }

    private void updateUIForDiscovery() {
        buttonManualConnect.setEnabled(false); // Disable while actively discovering/connecting
        buttonDisconnect.setEnabled(false);
    }
    private void updateUIForConnecting() {
        textViewStatus.setText("Status: Connecting to ESP32...");
        buttonManualConnect.setEnabled(false);
        buttonDisconnect.setEnabled(false); // Can't disconnect if not connected
    }

    private void updateUIForConnected() {
        textViewStatus.setText("Status: Connected to " + (resolvedEspService != null ? resolvedEspService.getServiceName() : "ESP32"));
        if (resolvedEspService != null && resolvedEspService.getHost() != null) {
             editTextEspIp.setText(resolvedEspService.getHost().getHostAddress() + ":" + resolvedEspService.getPort());
        }
        buttonStartService.setEnabled(false); // Assuming service is started if connected
        buttonStopService.setEnabled(true);
        buttonManualConnect.setEnabled(false); // Connected, no need to find
        buttonDisconnect.setEnabled(true);
    }

    private void updateUIForDisconnected() {
        // If service is still running, allow to find/connect again
        if (isWebSocketServiceManuallyStarted) {
            textViewStatus.setText("Status: Disconnected. Tap 'Find/Connect'.");
            buttonManualConnect.setEnabled(true);
            buttonDisconnect.setEnabled(false);
            editTextEspIp.setText(""); // Clear old IP
            resolvedEspService = null;
            // Optionally restart discovery automatically
            // nsdHelper.discoverServices(TARGET_ESP_SERVICE_NAME);
        } else {
            updateUIForServiceStopped(); // If service was stopped, revert to that state
        }
    }


    private String getCurrentTimestamp() {
        return new SimpleDateFormat("yyyy-MM-dd HH:mm:ss", Locale.getDefault()).format(new Date());
    }

    private void saveLogToFile(Uri uri) {
        try (OutputStream outputStream = getContentResolver().openOutputStream(uri);
             OutputStreamWriter writer = new OutputStreamWriter(outputStream)) {
            writer.write("--- Status Log ---\n");
            writer.write(statusLog.toString());
            writer.write("\n--- Message Log ---\n");
            writer.write(messageLog.toString());
            writer.flush();
            Toast.makeText(this, "Log saved successfully", Toast.LENGTH_LONG).show();
        } catch (IOException e) {
            Log.e(TAG, "Error saving log to file", e);
            Toast.makeText(this, "Error saving log: " + e.getMessage(), Toast.LENGTH_LONG).show();
        }
    }

    private void askNotificationPermission() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
            if (ContextCompat.checkSelfPermission(this, Manifest.permission.POST_NOTIFICATIONS) !=
                    PackageManager.PERMISSION_GRANTED) {
                requestPermissionLauncher.launch(Manifest.permission.POST_NOTIFICATIONS);
            }
        }
    }

    private void startWebSocketService() {
        Intent serviceIntent = new Intent(this, WebSocketService.class);
        serviceIntent.setAction(WebSocketService.ACTION_START_FOREGROUND_SERVICE);
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            startForegroundService(serviceIntent);
        } else {
            startService(serviceIntent);
        }
        statusLog.append(getCurrentTimestamp() + " CMD: Start Service\n");
        updateUIForServiceStarted();
        // Automatically start discovery when service starts
        textViewStatus.setText("Status: Service Started. Searching for " + TARGET_ESP_SERVICE_NAME + "...");
        nsdHelper.discoverServices(TARGET_ESP_SERVICE_NAME);
    }

    private void stopWebSocketService() {
        Intent serviceIntent = new Intent(this, WebSocketService.class);
        serviceIntent.setAction(WebSocketService.ACTION_STOP_FOREGROUND_SERVICE);
        startService(serviceIntent); // This will trigger service's stopSelf and cleanup
        statusLog.append(getCurrentTimestamp() + " CMD: Stop Service\n");
        updateUIForServiceStopped();
    }

    @Override
    protected void onResume() {
        super.onResume();
        if (!isServiceReceiverRegistered) {
            IntentFilter filter = new IntentFilter();
            filter.addAction(WebSocketService.ACTION_STATUS_UPDATE);
            filter.addAction(WebSocketService.ACTION_MESSAGE_RECEIVED);
            LocalBroadcastManager.getInstance(this).registerReceiver(serviceUpdateReceiver, filter);
            isServiceReceiverRegistered = true;
        }
        // If service was manually started and not connected, and discovery isn't active, try discovering
        if (isWebSocketServiceManuallyStarted && resolvedEspService == null && !nsdHelper.isDiscoveryActive()) {
            Log.d(TAG, "onResume: Service is started, no resolved ESP, discovery not active. Starting discovery.");
            textViewStatus.setText("Status: Searching for " + TARGET_ESP_SERVICE_NAME + "...");
            nsdHelper.discoverServices(TARGET_ESP_SERVICE_NAME);
            updateUIForDiscovery();
        } else if (resolvedEspService != null) {
            // If we previously resolved a service, refresh UI (e.g. if app was backgrounded and re-opened)
            // Check WebSocketService status to accurately reflect if still connected
             updateUIForConnected(); // This might need to query service for actual connection state
        }
    }

    @Override
    protected void onPause() {
        super.onPause();
        // Optional: stop discovery if app is paused and not connected to save battery
        // if (resolvedEspService == null && nsdHelper.isDiscoveryActive()) {
        //     nsdHelper.stopDiscovery();
        // }
    }

    @Override
    protected void onDestroy() {
        if (isServiceReceiverRegistered) {
            LocalBroadcastManager.getInstance(this).unregisterReceiver(serviceUpdateReceiver);
            isServiceReceiverRegistered = false;
        }
        nsdHelper.tearDown(); // Important to release NsdManager resources
        // Consider stopping the service if the activity is destroyed and you don't want it to run headless.
        // However, the current design implies the service can run independently for notifications.
        // If !isChangingConfigurations() { stopWebSocketService(); } // Example: stop if not rotation
        super.onDestroy();
    }

    // --- NsdHelper.NsdHelperListener Implementation ---
    @Override
    public void onNsdServiceResolved(NsdServiceInfo serviceInfo) {
        runOnUiThread(() -> {
            Log.i(TAG, "NSD Target Service Resolved: " + serviceInfo.getServiceName() + " at " + serviceInfo.getHost() + ":" + serviceInfo.getPort());
            if (TARGET_ESP_SERVICE_NAME.equalsIgnoreCase(serviceInfo.getServiceName())) {
                resolvedEspService = serviceInfo; // Store the successfully resolved service
                editTextEspIp.setText(serviceInfo.getHost().getHostAddress() + ":" + serviceInfo.getPort());
                textViewStatus.setText("Status: Found " + serviceInfo.getServiceName() + ". Connecting...");
                statusLog.append(getCurrentTimestamp() + " NSD: Found " + serviceInfo.getServiceName() + " at " + serviceInfo.getHost().getHostAddress() + ":" + serviceInfo.getPort() + "\n");

                // Automatically connect via the WebSocketService
                if (isWebSocketServiceManuallyStarted) {
                    String wsUrl = "ws://" + serviceInfo.getHost().getHostAddress() + ":" + serviceInfo.getPort() + ESP_WEBSOCKET_PATH;
                    Intent serviceIntent = new Intent(this, WebSocketService.class);
                    serviceIntent.setAction(WebSocketService.ACTION_CONNECT);
                    serviceIntent.putExtra(WebSocketService.EXTRA_IP_ADDRESS, wsUrl); // Service expects full URL
                    startService(serviceIntent);
                    updateUIForConnecting();
                } else {
                     textViewStatus.setText("Status: Found " + serviceInfo.getServiceName() + ". Start Service to connect.");
                     Toast.makeText(this, "ESP32 Found. Please 'Start Service' to connect.", Toast.LENGTH_LONG).show();
                     buttonManualConnect.setEnabled(true); // Allow user to connect if service is not yet started
                }
                nsdHelper.stopDiscovery(); // Found our target, stop further discovery for now
            } else {
                Log.w(TAG, "NSD Resolved a service, but it's not our target: " + serviceInfo.getServiceName());
            }
        });
    }

    @Override
    public void onNsdServiceLost(NsdServiceInfo serviceInfo) {
        runOnUiThread(() -> {
            Log.w(TAG, "NSD Service Lost: " + serviceInfo.getServiceName());
            statusLog.append(getCurrentTimestamp() + " NSD: Lost " + serviceInfo.getServiceName() + "\n");
            if (resolvedEspService != null && serviceInfo.getServiceName().equalsIgnoreCase(resolvedEspService.getServiceName())) {
                textViewStatus.setText("Status: ESP32 " + serviceInfo.getServiceName() + " connection lost. Searching...");
                editTextEspIp.setText("");
                resolvedEspService = null;
                updateUIForDisconnected(); // This will enable connect button if service is started
                // Automatically try to re-discover
                if (isWebSocketServiceManuallyStarted && !nsdHelper.isDiscoveryActive()) {
                    nsdHelper.discoverServices(TARGET_ESP_SERVICE_NAME);
                }
            }
        });
    }

    @Override
    public void onNsdDiscoveryFailed(String serviceType, int errorCode) {
        runOnUiThread(() -> {
            Log.e(TAG, "NSD Discovery Failed for " + serviceType + ". Error: " + errorCode);
            statusLog.append(getCurrentTimestamp() + " NSD: Discovery Failed. Error: " + errorCode + "\n");
            textViewStatus.setText("Status: ESP32 Discovery Failed. Check WiFi/Permissions.");
            if(isWebSocketServiceManuallyStarted) buttonManualConnect.setEnabled(true);
        });
    }

    @Override
    public void onNsdResolveFailed(NsdServiceInfo serviceInfo, int errorCode) {
        runOnUiThread(() -> {
            Log.e(TAG, "NSD Resolve Failed for " + serviceInfo.getServiceName() + ". Error: " + errorCode);
            statusLog.append(getCurrentTimestamp() + " NSD: Resolve Failed for " + serviceInfo.getServiceName() + ". Error: " + errorCode + "\n");
            textViewStatus.setText("Status: Failed to resolve ESP32 ("+serviceInfo.getServiceName()+"). Still searching...");
            // Keep searching if discovery is active
            if (isWebSocketServiceManuallyStarted && !nsdHelper.isDiscoveryActive()) {
                // If discovery stopped due to resolve, restart it.
                nsdHelper.discoverServices(TARGET_ESP_SERVICE_NAME);
            }
        });
    }

    @Override
    public void onNsdDiscoveryStatusChanged(String statusMessage) {
         runOnUiThread(() -> {
            Log.d(TAG, "NSD Status: " + statusMessage);
            // You can update a secondary status view or just log it.
            // textViewStatus might be overwritten by more specific statuses.
            // For now, mainly logging. If status indicates searching, update main status
            if (statusMessage.toLowerCase().contains("searching") || statusMessage.toLowerCase().contains("discovery started")) {
                 if (!textViewStatus.getText().toString().toLowerCase().contains("connected")) { // don't overwrite if connected
                    textViewStatus.setText("Status: " + statusMessage);
                 }
            }
         });
    }

    @Override
    public void onNsdServiceFound(NsdServiceInfo serviceInfo) {
        // This is called when a candidate is found, before resolution.
        // Resolution is attempted automatically by NsdHelper if name filter matches or no filter.
        // MainActivity gets more specific callback onNsdServiceResolved.
        runOnUiThread(() -> {
            Log.d(TAG, "NSD Candidate Found: " + serviceInfo.getServiceName());
             if (!textViewStatus.getText().toString().toLowerCase().contains("connected") && !textViewStatus.getText().toString().toLowerCase().contains("connecting")) {
                textViewStatus.setText("Status: ESP32 Candidate " + serviceInfo.getServiceName() + " found. Resolving...");
             }
        });
    }

    @Override
    public void onNsdDiscoveryStarted() {
        runOnUiThread(() -> {
            Log.d(TAG, "NSD Discovery actually started by NsdManager.");
            if (isWebSocketServiceManuallyStarted) updateUIForDiscovery();
        });
    }
    @Override
    public void onNsdDiscoveryStopped() {
        runOnUiThread(() -> {
            Log.d(TAG, "NSD Discovery actually stopped by NsdManager.");
            // If discovery stopped and we are not connected and service is running, enable manual find
            if (isWebSocketServiceManuallyStarted && resolvedEspService == null) {
                if(!textViewStatus.getText().toString().toLowerCase().contains("failed")) { // don't overwrite failed state
                    textViewStatus.setText("Status: Discovery stopped. Tap 'Find'.");
                }
                buttonManualConnect.setEnabled(true);
            }
        });
    }
}

#################### START OF FILE: app\src\main\java\com\example\mybasicapp\NsdHelper.java ####################

package com.example.mybasicapp;

import android.content.Context;
import android.net.nsd.NsdManager;
import android.net.nsd.NsdServiceInfo;
import android.util.Log;

public class NsdHelper {

    private static final String TAG = "NsdHelper";
    // This MUST match the service type your ESP32 advertises.
    // ESP32 CircuitPython code used: MDNS_WEBSOCKET_SERVICE_TYPE = "_myespwebsocket" and protocol = "_tcp"
    // So, for NsdManager, it's "_myespwebsocket._tcp"
    public static final String SERVICE_TYPE = "_myespwebsocket._tcp";

    private NsdManager nsdManager;
    private NsdManager.DiscoveryListener discoveryListener;
    private NsdManager.ResolveListener currentResolveListener;

    private boolean discoveryActive = false;
    private String serviceNameFilter; // To store the specific service name we are looking for

    // Callbacks for the client (e.g., MainActivity)
    public interface NsdHelperListener {
        void onNsdServiceResolved(NsdServiceInfo serviceInfo); // Called when the *target* service is resolved
        void onNsdServiceLost(NsdServiceInfo serviceInfo);
        void onNsdDiscoveryFailed(String serviceType, int errorCode);
        void onNsdResolveFailed(NsdServiceInfo serviceInfo, int errorCode);
        void onNsdDiscoveryStatusChanged(String statusMessage); // General status updates
    }

    private NsdHelperListener listener;

    public NsdHelper(Context context, NsdHelperListener listener) {
        this.nsdManager = (NsdManager) context.getSystemService(Context.NSD_SERVICE);
        this.listener = listener;
    }

    private void initializeDiscoveryListener() {
        if (discoveryListener != null) {
            Log.d(TAG, "Discovery listener already initialized.");
            return;
        }
        discoveryListener = new NsdManager.DiscoveryListener() {
            @Override
            public void onDiscoveryStarted(String regType) {
                Log.i(TAG, "NSD Service discovery started for type: " + regType);
                discoveryActive = true;
                if (listener != null) listener.onNsdDiscoveryStatusChanged("Discovery started for " + regType);
            }

            @Override
            public void onServiceFound(NsdServiceInfo service) {
                Log.d(TAG, "NSD Service candidate found: Name='" + service.getServiceName() + "', Type='" + service.getServiceType() + "'");
                // The serviceType from NsdServiceInfo can sometimes include the domain, e.g., "_myespwebsocket._tcp.local."
                // Using startsWith is more robust.
                if (service.getServiceType() != null && service.getServiceType().startsWith(SERVICE_TYPE.substring(0, SERVICE_TYPE.indexOf(".")))) {
                    // If we have a specific service name filter, check it now before resolving
                    if (serviceNameFilter != null && !service.getServiceName().equalsIgnoreCase(serviceNameFilter)) {
                        Log.d(TAG, "Service candidate '" + service.getServiceName() + "' does not match filter '" + serviceNameFilter + "'. Ignoring.");
                        return;
                    }
                    Log.i(TAG, "Matching service type (and name if filtered) found: '" + service.getServiceName() + "'. Attempting to resolve.");
                    if (listener != null) listener.onNsdDiscoveryStatusChanged("Found ESP32 candidate: " + service.getServiceName() + ". Resolving...");

                    // Resolve the service. Use a new ResolveListener for each attempt.
                    // Teardown any previous resolve listener
                    if (currentResolveListener != null) {
                        Log.d(TAG, "Cancelling previous resolve operation.");
                        // NsdManager doesn't have a direct cancel for resolve.
                        // We just replace the listener for the new resolve call.
                    }
                    currentResolveListener = new NsdManager.ResolveListener() {
                        @Override
                        public void onResolveFailed(NsdServiceInfo serviceInfo, int errorCode) {
                            Log.e(TAG, "NSD Resolve FAILED for service: '" + serviceInfo.getServiceName() + "', Error code: " + errorCode);
                            if (listener != null) listener.onNsdResolveFailed(serviceInfo, errorCode);
                            currentResolveListener = null; // Clear listener
                        }

                        @Override
                        public void onServiceResolved(NsdServiceInfo serviceInfo) {
                            Log.i(TAG, "NSD Service RESOLVED: Name='" + serviceInfo.getServiceName() + "', Host='" + serviceInfo.getHost() + "', Port='" + serviceInfo.getPort() + "'");
                            if (listener != null) listener.onNsdServiceResolved(serviceInfo);
                            currentResolveListener = null; // Clear listener
                        }
                    };
                    nsdManager.resolveService(service, currentResolveListener);
                } else {
                     Log.d(TAG, "Service '" + service.getServiceName() + "' with type '" + service.getServiceType() + "' does not match expected type '" + SERVICE_TYPE + "'. Ignoring.");
                }
            }

            @Override
            public void onServiceLost(NsdServiceInfo service) {
                Log.w(TAG, "NSD Service lost: Name='" + service.getServiceName() + "', Type='" + service.getServiceType() + "'");
                if (listener != null) listener.onNsdServiceLost(service);
            }

            @Override
            public void onDiscoveryStopped(String serviceType) {
                Log.i(TAG, "NSD Service discovery stopped for type: " + serviceType);
                discoveryActive = false;
                if (listener != null) listener.onNsdDiscoveryStatusChanged("Discovery stopped.");
            }

            @Override
            public void onStartDiscoveryFailed(String serviceType, int errorCode) {
                Log.e(TAG, "NSD Service discovery start FAILED for type '" + serviceType + "', Error code: " + errorCode);
                discoveryActive = false;
                if (listener != null) listener.onNsdDiscoveryFailed(serviceType, errorCode);
            }

            @Override
            public void onStopDiscoveryFailed(String serviceType, int errorCode) {
                Log.e(TAG, "NSD Service discovery stop FAILED for type '" + serviceType + "', Error code: " + errorCode);
                // This usually means the listener wasn't registered or an issue with NsdManager.
            }
        };
    }

    public void discoverServices(String targetServiceName) {
        this.serviceNameFilter = targetServiceName;
        stopDiscovery(); // Stop any previous discovery first

        if (discoveryListener == null) {
            initializeDiscoveryListener();
        }
        if (discoveryListener == null) { // Check again
             Log.e(TAG, "Cannot start discovery: DiscoveryListener is null.");
             if (listener != null) listener.onNsdDiscoveryFailed(SERVICE_TYPE, -1); // Custom error
             return;
        }

        Log.d(TAG, "Attempting to start NSD service discovery for type: " + SERVICE_TYPE + " (will filter for name: " + targetServiceName + ")");
        try {
            nsdManager.discoverServices(SERVICE_TYPE, NsdManager.PROTOCOL_DNS_SD, discoveryListener);
        } catch (Exception e) {
            Log.e(TAG, "Exception during nsdManager.discoverServices call: " + e.getMessage(), e);
            if (listener != null) listener.onNsdDiscoveryFailed(SERVICE_TYPE, NsdManager.FAILURE_INTERNAL_ERROR);
        }
    }

    public void stopDiscovery() {
        if (discoveryListener != null && discoveryActive) {
            try {
                Log.d(TAG, "Attempting to stop NSD service discovery.");
                nsdManager.stopServiceDiscovery(discoveryListener);
                // discoveryListener itself is not nulled here to allow reuse
            } catch (IllegalArgumentException e) {
                Log.w(TAG, "Error stopping discovery (IllegalArgumentException): " + e.getMessage() + ". Likely already stopped or not started.");
            } catch (Exception e) {
                Log.e(TAG, "Exception during nsdManager.stopServiceDiscovery: " + e.getMessage(), e);
            }
        } else {
            Log.d(TAG, "No active NSD discovery listener to stop or listener is null.");
        }
        discoveryActive = false; // Ensure flag is reset
    }

    public void tearDown() {
        Log.d(TAG, "Tearing down NsdHelper.");
        stopDiscovery();
        this.listener = null; // Clear listener to prevent leaks
        this.discoveryListener = null; // Clear discovery listener
        this.currentResolveListener = null; // Clear resolve listener
        this.nsdManager = null; // Allow NsdManager to be GC'd if context is gone
    }

    public boolean isDiscoveryActive() {
        return discoveryActive;
    }
}

#################### START OF FILE: app\src\main\java\com\example\mybasicapp\WebSocketService.java ####################

package com.example.mybasicapp;

import android.app.Notification;
import android.app.NotificationChannel;
import android.app.NotificationManager;
import android.app.PendingIntent;
import android.app.Service;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.content.pm.ServiceInfo;
import android.os.Build;
import android.os.Handler;
import android.os.IBinder;
import android.os.Looper;
import android.util.Log;

import androidx.annotation.Nullable;
import androidx.core.app.ActivityCompat;
import androidx.core.app.NotificationCompat;
import androidx.core.app.NotificationManagerCompat;
import androidx.localbroadcastmanager.content.LocalBroadcastManager;

import org.json.JSONException;
import org.json.JSONObject;

import java.util.Locale;
import java.util.concurrent.TimeUnit;

import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.Response;
import okhttp3.WebSocket;
import okhttp3.WebSocketListener;
import okio.ByteString;

public class WebSocketService extends Service {

    private static final String TAG = "WebSocketService";
    public static final String ACTION_START_FOREGROUND_SERVICE = "ACTION_START_FOREGROUND_SERVICE";
    public static final String ACTION_STOP_FOREGROUND_SERVICE = "ACTION_STOP_FOREGROUND_SERVICE";
    public static final String ACTION_CONNECT = "ACTION_CONNECT";
    public static final String ACTION_DISCONNECT = "ACTION_DISCONNECT";
    public static final String EXTRA_IP_ADDRESS = "EXTRA_IP_ADDRESS"; // This will be the full ws:// URL

    public static final String ACTION_STATUS_UPDATE = "com.example.mybasicapp.STATUS_UPDATE";
    public static final String ACTION_MESSAGE_RECEIVED = "com.example.mybasicapp.MESSAGE_RECEIVED";
    public static final String EXTRA_STATUS = "EXTRA_STATUS";
    public static final String EXTRA_MESSAGE_TITLE = "EXTRA_MESSAGE_TITLE";
    public static final String EXTRA_MESSAGE_BODY = "EXTRA_MESSAGE_BODY";


    private static final String NOTIFICATION_CHANNEL_ID_SERVICE = "web_socket_service_channel";
    private static final String NOTIFICATION_CHANNEL_ID_MESSAGES = "esp32_notifications"; // For actual alert notifications
    private static final int SERVICE_NOTIFICATION_ID = 1;
    private static final int MESSAGE_NOTIFICATION_ID = 101; // For messages from ESP32

    private OkHttpClient httpClient;
    private WebSocket webSocket;
    private String currentWebSocketUrl; // Changed from currentIpAddress to reflect it's a full URL
    private Handler handler = new Handler(Looper.getMainLooper());
    private boolean isServiceStarted = false;
    private int retryCount = 0;
    private static final int MAX_RETRY_COUNT = 5; // Max number of retries
    private static final long RETRY_DELAY_MS = 5000; // 5 seconds delay

    @Override
    public void onCreate() {
        super.onCreate();
        Log.d(TAG, "Service onCreate");
        httpClient = new OkHttpClient.Builder()
                .pingInterval(30, TimeUnit.SECONDS) // Keep the connection alive
                .connectTimeout(10, TimeUnit.SECONDS)
                .readTimeout(10, TimeUnit.SECONDS)
                .writeTimeout(10, TimeUnit.SECONDS)
                .retryOnConnectionFailure(true)
                .build();
        createNotificationChannel(NOTIFICATION_CHANNEL_ID_SERVICE, "WebSocket Service Status", NotificationManager.IMPORTANCE_LOW);
        createNotificationChannel(NOTIFICATION_CHANNEL_ID_MESSAGES, getString(R.string.channel_name), NotificationManager.IMPORTANCE_HIGH);
    }

    @Override
    public int onStartCommand(Intent intent, int flags, int startId) {
        if (intent != null) {
            String action = intent.getAction();
            Log.d(TAG, "onStartCommand, Action: " + action);

            if (ACTION_START_FOREGROUND_SERVICE.equals(action)) {
                if (!isServiceStarted) {
                    startForegroundServiceWithNotification("Service Active. Not connected.");
                    isServiceStarted = true;
                }
            } else if (ACTION_STOP_FOREGROUND_SERVICE.equals(action)) {
                stopService();
                return START_NOT_STICKY;
            } else if (ACTION_CONNECT.equals(action) && isServiceStarted) {
                String wsUrlFromIntent = intent.getStringExtra(EXTRA_IP_ADDRESS); // This is the full URL
                if (wsUrlFromIntent != null && !wsUrlFromIntent.isEmpty()) {
                    currentWebSocketUrl = wsUrlFromIntent; // Store the full URL
                    connectWebSocket(currentWebSocketUrl);
                    retryCount = 0; // Reset retry count on new manual connect attempt
                } else {
                    Log.e(TAG, "WebSocket URL is null or empty in ACTION_CONNECT");
                    sendBroadcastStatus("Error: WebSocket URL missing");
                }
            } else if (ACTION_DISCONNECT.equals(action) && isServiceStarted) {
                disconnectWebSocket();
            }
        }
        return START_STICKY;
    }


    private void startForegroundServiceWithNotification(String statusText) {
        Intent notificationIntent = new Intent(this, MainActivity.class);
        PendingIntent pendingIntent = PendingIntent.getActivity(this, 0,
                notificationIntent, PendingIntent.FLAG_IMMUTABLE | PendingIntent.FLAG_UPDATE_CURRENT);

        Notification notification = new NotificationCompat.Builder(this, NOTIFICATION_CHANNEL_ID_SERVICE)
                .setContentTitle(getString(R.string.app_name) + " Service")
                .setContentText(statusText)
                .setSmallIcon(R.drawable.ic_stat_service)
                .setContentIntent(pendingIntent)
                .setOngoing(true)
                .setPriority(NotificationCompat.PRIORITY_LOW)
                .build();

        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
            startForeground(SERVICE_NOTIFICATION_ID, notification, ServiceInfo.FOREGROUND_SERVICE_TYPE_DATA_SYNC);
        } else {
            startForeground(SERVICE_NOTIFICATION_ID, notification);
        }
        Log.d(TAG, "Service started in foreground.");
    }

    private void updateServiceNotification(String text) {
        NotificationManager manager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);
        if (manager == null || !isServiceStarted) return;

        Intent notificationIntent = new Intent(this, MainActivity.class);
        PendingIntent pendingIntent = PendingIntent.getActivity(this, 0,
                notificationIntent, PendingIntent.FLAG_IMMUTABLE | PendingIntent.FLAG_UPDATE_CURRENT);

        Notification notification = new NotificationCompat.Builder(this, NOTIFICATION_CHANNEL_ID_SERVICE)
                .setContentTitle(getString(R.string.app_name) + " Service")
                .setContentText(text)
                .setSmallIcon(R.drawable.ic_stat_service)
                .setContentIntent(pendingIntent)
                .setOngoing(true)
                .setPriority(NotificationCompat.PRIORITY_LOW)
                .build();
        manager.notify(SERVICE_NOTIFICATION_ID, notification);
    }


    private void connectWebSocket(String wsUrl) {
        if (wsUrl == null || wsUrl.isEmpty()) {
            Log.e(TAG, "connectWebSocket called with null or empty URL.");
            sendBroadcastStatus("Error: Invalid ESP32 Address");
            return;
        }
        if (webSocket != null) {
            Log.d(TAG, "Closing existing WebSocket before reconnecting.");
            webSocket.close(1001, "Client reconnecting"); // 1001 indicates going away
            webSocket = null;
        }

        Request request = new Request.Builder().url(wsUrl).build();
        final String displayUrl = wsUrl.replaceFirst("ws://", "").replaceFirst("/ws", ""); // For shorter display
        sendBroadcastStatus("Connecting to " + displayUrl + "...");
        updateServiceNotification("Connecting to ESP32...");
        Log.i(TAG, "Attempting to connect to: " + wsUrl);

        webSocket = httpClient.newWebSocket(request, new WebSocketListener() {
            @Override
            public void onOpen(WebSocket ws, Response response) {
                super.onOpen(ws, response);
                Log.i(TAG, "WebSocket Opened with " + displayUrl);
                sendBroadcastStatus("Connected to ESP32");
                updateServiceNotification("Connected to ESP32");
                retryCount = 0; // Reset retry count on successful connection
            }

            @Override
            public void onMessage(WebSocket ws, String text) {
                super.onMessage(ws, text);
                Log.i(TAG, "Receiving from ESP32: " + text);
                try {
                    JSONObject json = new JSONObject(text);
                    String event = json.optString("event");

                    if ("motion_detected".equals(event)) {
                        double distanceCm = json.optDouble("distance_cm", -1.0);
                        //double thresholdCm = json.optDouble("threshold_cm", -1.0); // Also available
                        //long timestamp = json.optLong("timestamp", 0); // Also available

                        String title = "Motion Alert!";
                        String messageBody = String.format(Locale.getDefault(), "Motion detected at %.1f cm.", distanceCm);

                        sendBroadcastMessage(title, messageBody);
                        showDataNotification(title, messageBody);
                    } else {
                        // Handle other event types or generic messages if your ESP32 sends them
                        String title = json.optString("title", "ESP32 Info");
                        String messageBody = json.optString("message", text); // Fallback to raw text
                        sendBroadcastMessage(title, messageBody);
                        // Optionally show notification for other events too
                        // showDataNotification(title, messageBody);
                        Log.d(TAG, "Received non-motion event or generic message: " + text);
                    }

                } catch (JSONException e) {
                    Log.e(TAG, "Error parsing JSON from WebSocket: " + e.getMessage() + ". Raw: " + text);
                    // If not JSON, treat as a simple message
                    sendBroadcastMessage("ESP32 Message", text);
                    showDataNotification("ESP32 Message", text);
                }
            }

            @Override
            public void onMessage(WebSocket ws, ByteString bytes) {
                super.onMessage(ws, bytes);
                Log.i(TAG, "Receiving bytes: " + bytes.hex() + " (not handled)");
            }

            @Override
            public void onClosing(WebSocket ws, int code, String reason) {
                super.onClosing(ws, code, reason);
                Log.i(TAG, "WebSocket Closing: " + code + " / " + reason);
                // ws.close(1000, null); // Not needed, OkHttp handles this
            }

            @Override
            public void onClosed(WebSocket ws, int code, String reason) {
                super.onClosed(ws, code, reason);
                Log.i(TAG, "WebSocket Closed: " + code + " / " + reason + " for URL: " + wsUrl);
                sendBroadcastStatus("Disconnected");
                updateServiceNotification("Disconnected from ESP32");
                if (WebSocketService.this.webSocket == ws) { // Ensure it's the current socket
                    WebSocketService.this.webSocket = null;
                }
            }

            @Override
            public void onFailure(WebSocket ws, Throwable t, Response response) {
                super.onFailure(ws, t, response);
                String errorMsg = (t != null && t.getMessage() != null) ? t.getMessage() : "Unknown connection error";
                Log.e(TAG, "WebSocket Failure for " + wsUrl + ": " + errorMsg, t);
                sendBroadcastStatus("Connection Failed: " + errorMsg);
                updateServiceNotification("Connection Failed");
                if (WebSocketService.this.webSocket == ws) { // Ensure it's the current socket
                    WebSocketService.this.webSocket = null;
                }

                // Implement retry logic with backoff if connection fails and service is still running
                if (isServiceStarted && currentWebSocketUrl != null && !currentWebSocketUrl.isEmpty()) {
                    if (retryCount < MAX_RETRY_COUNT) {
                        retryCount++;
                        long delay = RETRY_DELAY_MS * retryCount; // Exponential backoff could be used too
                        Log.d(TAG, "Retrying connection to: " + currentWebSocketUrl + " (Attempt " + retryCount + ") in " + delay + "ms");
                        sendBroadcastStatus("Connection Failed. Retrying (" + retryCount + "/" + MAX_RETRY_COUNT + ")...");
                        updateServiceNotification("Connection Failed. Retrying...");
                        handler.postDelayed(() -> {
                            if (isServiceStarted) { // Check again if service is still started before retrying
                                connectWebSocket(currentWebSocketUrl);
                            }
                        }, delay);
                    } else {
                        Log.e(TAG, "Max retry attempts reached for " + currentWebSocketUrl + ". Giving up.");
                        sendBroadcastStatus("Connection Failed: Max retries reached.");
                        updateServiceNotification("Connection Failed. Max retries.");
                    }
                }
            }
        });
    }

    private void disconnectWebSocket() {
        handler.removeCallbacksAndMessages(null); // Cancel any pending retries
        retryCount = 0;
        if (webSocket != null) {
            webSocket.close(1000, "User requested disconnect");
            webSocket = null; // Important to nullify immediately
        }
        sendBroadcastStatus("Disconnected by user");
        updateServiceNotification("Disconnected by user");
        Log.i(TAG, "WebSocket Disconnected by user action.");
        currentWebSocketUrl = null; // Clear the URL so it doesn't try to auto-reconnect to old one
    }


    private void sendBroadcastStatus(String status) {
        Intent intent = new Intent(ACTION_STATUS_UPDATE);
        intent.putExtra(EXTRA_STATUS, status);
        LocalBroadcastManager.getInstance(this).sendBroadcast(intent);
    }

    private void sendBroadcastMessage(String title, String body) {
        Intent intent = new Intent(ACTION_MESSAGE_RECEIVED);
        intent.putExtra(EXTRA_MESSAGE_TITLE, title);
        intent.putExtra(EXTRA_MESSAGE_BODY, body);
        LocalBroadcastManager.getInstance(this).sendBroadcast(intent);
    }

    private void createNotificationChannel(String channelId, String channelName, int importance) {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            NotificationChannel channel = new NotificationChannel(channelId, channelName, importance);
            if (channelId.equals(NOTIFICATION_CHANNEL_ID_MESSAGES)) {
                channel.setDescription(getString(R.string.channel_description));
                // Optional: Configure sound, vibration, etc. for alert notifications
                // channel.setSound(RingtoneManager.getDefaultUri(RingtoneManager.TYPE_NOTIFICATION), null);
                // channel.enableVibration(true);
                // channel.setVibrationPattern(new long[]{0, 500, 200, 500});
            } else {
                 channel.setDescription("Channel for ESP32 Sync Service status");
            }
            NotificationManager notificationManager = getSystemService(NotificationManager.class);
            if (notificationManager != null) {
                notificationManager.createNotificationChannel(channel);
            }
        }
    }

    private void showDataNotification(String title, String message) {
        // Check for POST_NOTIFICATIONS permission (Android 13+)
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
            if (ActivityCompat.checkSelfPermission(this, android.Manifest.permission.POST_NOTIFICATIONS) != PackageManager.PERMISSION_GRANTED) {
                Log.w(TAG, "POST_NOTIFICATIONS permission not granted. Cannot show data notification.");
                // Service cannot request permission. Activity must handle it.
                // Optionally send a broadcast to Activity to inform user about missing permission.
                return;
            }
        }

        Intent intent = new Intent(this, MainActivity.class);
        intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP | Intent.FLAG_ACTIVITY_SINGLE_TOP); // Bring to front or launch
        PendingIntent pendingIntent = PendingIntent.getActivity(this,
                (int) System.currentTimeMillis(), // Unique request code to ensure PendingIntent updates if extras change
                intent,
                PendingIntent.FLAG_UPDATE_CURRENT | PendingIntent.FLAG_IMMUTABLE);


        NotificationCompat.Builder builder = new NotificationCompat.Builder(this, NOTIFICATION_CHANNEL_ID_MESSAGES)
                .setSmallIcon(R.drawable.ic_stat_message)
                .setContentTitle(title)
                .setContentText(message)
                .setPriority(NotificationCompat.PRIORITY_HIGH) // Ensure it pops up
                .setAutoCancel(true) // Dismiss notification when tapped
                .setContentIntent(pendingIntent)
                .setDefaults(Notification.DEFAULT_ALL); // Use default sound, vibration, light

        NotificationManagerCompat notificationManager = NotificationManagerCompat.from(this);
        try {
            // MESSAGE_NOTIFICATION_ID should be unique for each type of notification if you want them to stack or update correctly
            // Or use a dynamic ID if you want multiple distinct motion alerts. For now, one ID updates previous.
            notificationManager.notify(MESSAGE_NOTIFICATION_ID, builder.build());
        } catch (SecurityException e) {
            // This can happen if permissions are revoked while app is running.
            Log.e(TAG, "SecurityException while trying to post data notification: " + e.getMessage());
        }
    }


    private void stopService() {
        Log.d(TAG, "stopService called in WebSocketService");
        handler.removeCallbacksAndMessages(null); // Cancel any pending retries
        retryCount = 0;
        disconnectWebSocket(); // Ensure WebSocket is closed first
        if (isServiceStarted) {
            stopForeground(true); // true to remove the notification
            stopSelf(); // Stop the service instance
            isServiceStarted = false; // Update flag
            // sendBroadcastStatus("Service Stopped"); // MainActivity will update based on its own logic
        }
        Log.d(TAG, "WebSocketService fully stopped.");
    }


    @Nullable
    @Override
    public IBinder onBind(Intent intent) {
        return null; // We are not using binding, so return null
    }

    @Override
    public void onDestroy() {
        Log.d(TAG, "Service onDestroy");
        stopService(); // Ensure everything is cleaned up
        if (httpClient != null) {
            // Gracefully shut down OkHttpClient resources
            httpClient.dispatcher().executorService().shutdown();
            httpClient.connectionPool().evictAll();
            try {
                if (httpClient.cache() != null) {
                    httpClient.cache().close();
                }
            } catch (Exception e) {
                Log.e(TAG, "Error closing OkHttp cache", e);
            }
        }
        super.onDestroy();
    }
}

#################### START OF FILE: app\src\main\res\drawable\ic_stat_message.xml ####################

<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24.0"
    android:viewportHeight="24.0"
    android:tint="?attr/colorControlNormal">
  <path
      android:fillColor="@android:color/white"
      android:pathData="M20,2L4,2c-1.1,0 -1.99,0.9 -1.99,2L2,22l4,-4h14c1.1,0 2,-0.9 2,-2L22,4c0,-1.1 -0.9,-2 -2,-2zM18,14L6,14v-2h12v2zM18,11L6,11L6,9h12v2zM18,8L6,8L6,6h12v2z"/>
</vector>

#################### START OF FILE: app\src\main\res\drawable\ic_stat_service.xml ####################

<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24.0"
    android:viewportHeight="24.0"
    android:tint="?attr/colorControlNormal"> <!-- Or a specific color -->
  <path
      android:fillColor="@android:color/white"
      android:pathData="M12,2C6.48,2 2,6.48 2,12s4.48,10 10,10 10,-4.48 10,-10S17.52,2 12,2zM12,20c-4.41,0 -8,-3.59 -8,-8s3.59,-8 8,-8 8,3.59 8,8 -3.59,8 -8,8zM13,7h-2v6h2V7zm0,8h-2v2h2v-2z"/>
</vector>

#################### START OF FILE: app\src\main\res\layout\activity_main.xml ####################

<?xml version="1.0" encoding="utf-8"?>
<androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:padding="16dp"
    tools:context=".MainActivity">

    <EditText
        android:id="@+id/editTextEspIp"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:hint="ESP32 (Auto-Discovering...)"
        android:inputType="textNoSuggestions"
        android:enabled="false"
        android:focusable="false"
        android:background="@android:color/transparent"
        android:paddingTop="8dp"
        android:paddingBottom="8dp"
        android:textSize="16sp"
        app:layout_constraintTop_toTopOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent" />

    <LinearLayout
        android:id="@+id/layoutServiceControls"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:orientation="horizontal"
        android:layout_marginTop="8dp"
        app:layout_constraintTop_toBottomOf="@id/editTextEspIp"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent">

        <Button
            android:id="@+id/buttonStartService"
            style="?android:attr/buttonBarButtonStyle"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:text="Start Svc"
            android:layout_marginEnd="4dp"/>

        <Button
            android:id="@+id/buttonStopService"
            style="?android:attr/buttonBarButtonStyle"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:text="Stop Svc"
            android:layout_marginStart="4dp"/>
    </LinearLayout>

    <LinearLayout
        android:id="@+id/layoutConnectionControls"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:orientation="horizontal"
        android:layout_marginTop="8dp"
        app:layout_constraintTop_toBottomOf="@id/layoutServiceControls"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent">

        <!-- This button's ID is referenced as buttonManualConnect in MainActivity.java
             Make sure the ID matches what's used in findViewById. -->
        <Button
            android:id="@+id/buttonConnect"
            style="?android:attr/buttonBarButtonStyle"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:text="Find/Connect ESP32"
            android:layout_marginEnd="4dp"/>

        <Button
            android:id="@+id/buttonDisconnect"
            style="?android:attr/buttonBarButtonStyle"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:text="Disconnect"
            android:layout_marginStart="4dp"/>
    </LinearLayout>

    <Button
        android:id="@+id/buttonSaveLog"
        style="?android:attr/buttonBarButtonStyle"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:text="Save Log"
        android:layout_marginTop="8dp"
        app:layout_constraintTop_toBottomOf="@id/layoutConnectionControls"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent" />

    <TextView
        android:id="@+id/textViewStatus"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:text="Status: Idle"
        android:layout_marginTop="16dp"
        android:textSize="18sp"
        android:textAppearance="?attr/textAppearanceBody1"
        app:layout_constraintTop_toBottomOf="@id/buttonSaveLog"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent" />

    <TextView
        android:id="@+id/textViewLastMessage"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:text="Last Message: None"
        android:layout_marginTop="8dp"
        android:textAppearance="?attr/textAppearanceBody2"
        app:layout_constraintTop_toBottomOf="@id/textViewStatus"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent"/>

</androidx.constraintlayout.widget.ConstraintLayout>

#################### START OF FILE: app\src\main\res\values\colors.xml ####################

<?xml version="1.0" encoding="utf-8"?>
<resources>
    <!-- Theme Colors for MyBasicApp -->
    <color name="my_app_primary">#1A535C</color> <!-- A dark teal/green, adjust to your liking -->
    <color name="my_app_primary_dark">#0E3F47</color> <!-- A darker shade for status bar -->
    <color name="my_app_accent">#F7B801</color> <!-- An accent color, e.g., a gold/yellow -->

    <!-- Standard Android/Material Colors (can be used as fallbacks or for other UI elements) -->
    <color name="purple_200">#FFBB86FC</color>
    <color name="purple_500">#FF6200EE</color>
    <color name="purple_700">#FF3700B3</color>
    <color name="teal_200">#FF03DAC5</color>
    <color name="teal_700">#FF018786</color>
    <color name="black">#FF000000</color>
    <color name="white">#FFFFFFFF</color>

    <!-- Text Colors -->
    <color name="text_on_primary">#FFFFFF</color>
    <color name="text_on_accent">#000000</color>
</resources>


#################### START OF FILE: app\src\main\res\values\strings.xml ####################

<resources>
    <string name="app_name">Mr Coopers ESP32</string>
    <!-- For Notification Channel for ESP32 messages -->
    <string name="channel_name">ESP32 Notifications</string>
    <string name="channel_description">Notifications received from the local ESP32 device.</string>
</resources>

#################### START OF FILE: app\src\main\res\values\themes.xml ####################

<?xml version="1.0" encoding="utf-8"?>
<resources xmlns:tools="http://schemas.android.com/tools">
    <!-- Base application theme. -->
    <style name="Theme.MyBasicApp" parent="Theme.MaterialComponents.DayNight.DarkActionBar">
        <!-- Primary brand color. -->
        <item name="colorPrimary">@color/my_app_primary</item>
        <item name="colorPrimaryVariant">@color/my_app_primary_dark</item> <!-- Used for status bar by default -->
        <item name="colorOnPrimary">@color/text_on_primary</item> <!-- Text/icon color on primary color -->

        <!-- Secondary brand color (accent color). -->
        <item name="colorSecondary">@color/my_app_accent</item>
        <item name="colorSecondaryVariant">@color/my_app_accent</item> <!-- Can be a darker/lighter shade of accent -->
        <item name="colorOnSecondary">@color/text_on_accent</item> <!-- Text/icon color on secondary color -->

        <!-- Status bar color. -->
        <!-- By default, uses colorPrimaryVariant. You can override it explicitly. -->
        <item name="android:statusBarColor" tools:targetApi="l">?attr/colorPrimaryVariant</item>

        <!-- Customize your theme here. -->
        <!-- For example, to remove the action bar if you're using a Toolbar in your layout: -->
        <!-- <item name="windowActionBar">false</item> -->
        <!-- <item name="windowNoTitle">true</item> -->

        <!-- You can also define other attributes like windowBackground, textColor, etc. -->
        <!-- <item name="android:windowBackground">@color/white</item> -->
    </style>

    <!-- Optional: A theme for a splash screen if you implement one -->
    <!--
    <style name="Theme.MyBasicApp.Splash" parent="Theme.SplashScreen">
        <item name="windowSplashScreenBackground">@color/my_app_primary</item>
        <item name="windowSplashScreenAnimatedIcon">@mipmap/ic_launcher_round</item> Comment out if no round launcher or use ic_launcher
        <item name="windowSplashScreenAnimationDuration">1000</item>
        <item name="postSplashScreenTheme">@style/Theme.MyBasicApp</item>
    </style>
    -->
</resources>

#################### START OF FILE: app\src\main\res\xml\backup_rules.xml ####################

<?xml version="1.0" encoding="utf-8"?>
<full-backup-content>
    <!-- TODO Remove the following backup rules src/main/AndroidManifext.xml#fullBackupContent-->
    <!-- <include domain="sharedpref" path="."/> -->
    <!-- <exclude domain="sharedpref" path="device.xml"/> -->
</full-backup-content>


#################### START OF FILE: app\src\main\res\xml\data_extraction_rules.xml ####################

<?xml version="1.0" encoding="utf-8"?>
<data-extraction-rules>
    <cloud-backup>
        <!-- TODO: Add cloud backup rules here. -->
        <!--
        <include domain="sharedpref" path="."/>
        <exclude domain="sharedpref" path="device.xml"/>
        -->
    </cloud-backup>
    <device-transfer>
        <!-- TODO: Add device transfer rules here. -->
        <!--
        <include domain="sharedpref" path="."/>
        <exclude domain="sharedpref" path="device.xml"/>
        -->
    </device-transfer>
</data-extraction-rules>


#################### START OF FILE: build.gradle ####################

// Top-level build file where you can add configuration options common to all sub-projects/modules.
plugins {
    // Define the Android Gradle Plugin version. 'apply false' means it's not applied to the root project,
    // but makes this version available to sub-projects like ':app'.
    // AGP 8.4.0 is a stable version compatible with Gradle 8.5.
    id("com.android.application") version "8.4.0" apply false

    // If you were using Kotlin (which this project is not, based on .java files and dependencies):
    // id("org.jetbrains.kotlin.android") version "1.9.23" apply false // Check for latest compatible Kotlin version
}

#################### START OF FILE: gradle\wrapper\gradle-wrapper.properties ####################

distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-8.6-bin.zip
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists

#################### START OF FILE: gradle.properties ####################

# Gradle JVM ARGS
# org.gradle.jvmargs=-Xmx2048m -Dfile.encoding=UTF-8 # Optional: Adjust memory if needed

# AndroidX Properties
android.useAndroidX=true
android.enableJetifier=true


#################### START OF FILE: settings.gradle ####################

pluginManagement {
    repositories {
        google()
        mavenCentral()
        gradlePluginPortal()
    }
}
dependencyResolutionManagement {
    repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)
    repositories {
        google()
        mavenCentral()
    }
}

rootProject.name = "MyBasicApp"
include ':app'
