Total files found and listed: 32
List of all files found (paths relative to processing context):
- .github\workflows\android_ci.yml
- .gitignore
- app\build.gradle
- app\src\main\AndroidManifest.xml
- app\src\main\java\com\example\mybasicapp\DiscoveredService.java
- app\src\main\java\com\example\mybasicapp\DiscoveredServicesAdapter.java
- app\src\main\java\com\example\mybasicapp\MainActivity.java
- app\src\main\java\com\example\mybasicapp\NsdHelper.java
- app\src\main\java\com\example\mybasicapp\WebSocketService.java
- app\src\main\res\drawable\ic_stat_message.xml
- app\src\main\res\drawable\ic_stat_service.xml
- app\src\main\res\layout\activity_main.xml
- app\src\main\res\layout\list_item_discovered_service.xml
- app\src\main\res\mipmap-hdpi\ic_launcher.png
- app\src\main\res\mipmap-hdpi\ic_launcher_round.png
- app\src\main\res\mipmap-mdpi\ic_launcher.png
- app\src\main\res\mipmap-mdpi\ic_launcher_round.png
- app\src\main\res\mipmap-xhdpi\ic_launcher.png
- app\src\main\res\mipmap-xhdpi\ic_launcher_round.png
- app\src\main\res\mipmap-xxhdpi\ic_launcher.png
- app\src\main\res\mipmap-xxhdpi\ic_launcher_round.png
- app\src\main\res\mipmap-xxxhdpi\ic_launcher.png
- app\src\main\res\mipmap-xxxhdpi\ic_launcher_round.png
- app\src\main\res\values\colors.xml
- app\src\main\res\values\strings.xml
- app\src\main\res\values\themes.xml
- app\src\main\res\xml\backup_rules.xml
- app\src\main\res\xml\data_extraction_rules.xml
- build.gradle
- gradle\wrapper\gradle-wrapper.properties
- gradle.properties
- settings.gradle

Content included for 21 file(s) with extensions: .java, .yml, .xml, .gradle, .properties

================================================================================


#################### START OF FILE: .github\workflows\android_ci.yml ####################

name: Android CI Build (Online Wrapper Init)

on:
  push:
    branches: [ "main", "master" ] # Or your default branch
  pull_request:
    branches: [ "main", "master" ]

jobs:
  build:
    env:
      # Define the Gradle version for the wrapper and build.
      # Choose a version compatible with your Android Gradle Plugin (AGP).
      # For AGP 8.4.0 (used in root build.gradle), Gradle 8.6 or higher is needed.
      # Check AGP release notes for compatibility.
      GRADLE_VERSION_TO_USE: '8.6' # Updated to Gradle 8.6

    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up JDK 17
      uses: actions/setup-java@v4
      with:
        java-version: '17' # Common for modern Android development
        distribution: 'temurin'

    # This step installs the specified version of Gradle and adds the 'gradle' command to the PATH.
    - name: Setup Gradle
      uses: gradle/actions/setup-gradle@v3 # Using setup-gradle v3
      with:
        gradle-version: ${{ env.GRADLE_VERSION_TO_USE }}
        # setup-gradle action has its own caching for Gradle User Home,
        # which can be beneficial. You can further configure it if needed.
        # See https://github.com/gradle/actions/blob/main/setup-gradle/README.md#caching

    # This step uses the 'gradle' command (from Setup Gradle step) to initialize
    # the Gradle wrapper files (gradlew, gradlew.bat, gradle-wrapper.jar, gradle-wrapper.properties)
    # in the runner's workspace. The generated gradle-wrapper.properties will point to GRADLE_VERSION_TO_USE.
    - name: Initialize Gradle Wrapper
      run: gradle wrapper --gradle-version ${{ env.GRADLE_VERSION_TO_USE }} --distribution-type bin
      # Adding --distribution-type bin to ensure it fetches the binary distribution

    - name: Grant execute permission for gradlew
      run: chmod +x ./gradlew

    # Recommended: Cache Gradle dependencies downloaded by the wrapper.
    # This cache uses the wrapper files generated in the previous step and other project build files.
    - name: Cache Gradle packages
      uses: actions/cache@v4
      with:
        path: |
          ~/.gradle/caches
          ~/.gradle/wrapper/dists
        # MODIFIED KEY: Added a version suffix '-v1' to help invalidate the cache if needed.
        # Increment this suffix (e.g., -v2, -v3) or use a dynamic value like ${{ github.run_id }}
        # if you suspect stale cache issues and need to force a fresh download.
        key: ${{ runner.os }}-gradle-${{ env.GRADLE_VERSION_TO_USE }}-${{ hashFiles('**/*.gradle*', '**/gradle-wrapper.properties', '**/libs.versions.toml') }}-v1
        restore-keys: |
          ${{ runner.os }}-gradle-${{ env.GRADLE_VERSION_TO_USE }}-

    - name: Build with Gradle Wrapper
      # Adding --stacktrace for more detailed error output if the build fails
      run: ./gradlew assembleDebug --stacktrace

    - name: Upload Debug APK
      uses: actions/upload-artifact@v4
      with:
        name: MrCoopersESP32 # Name of the artifact
        path: app/build/outputs/apk/debug/MrCoopersESP32.apk # Path to the APK
        if-no-files-found: error # Fail if APK not found

#################### START OF FILE: app\build.gradle ####################

plugins {
    id 'com.android.application'
    // id 'org.jetbrains.kotlin.android' // This project uses Java, so Kotlin plugin is not needed
}

android {
    namespace 'com.example.mybasicapp'
    compileSdk 34

    defaultConfig {
        applicationId "com.example.mybasicapp"
        minSdk 21
        targetSdk 34
        versionCode 1
        versionName "1.0"

        testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
    }

    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
        }
        debug {
            // APK naming is handled by the androidComponents block below
        }
    }

    compileOptions {
        // Align with the JDK version used in the CI workflow (JDK 17)
        sourceCompatibility JavaVersion.VERSION_17
        targetCompatibility JavaVersion.VERSION_17
    }
}

// This block customizes the output APK name for debug builds.
// It was previously (and incorrectly) in the root build.gradle.
androidComponents {
    onVariants(selector().withBuildType("debug")) { variant ->
        variant.outputs.forEach { output ->
            // Ensure we are modifying the main APK output
            // Correctly compare the outputType enum directly
            if (output.outputType == com.android.build.api.variant.VariantOutputConfiguration.OutputType.SINGLE) {
                output.outputFileName.set("MrCoopersESP32.apk")
            }
        }
    }
}

dependencies {
    // Use 'androidx.core:core' for Java projects. 'core-ktx' is for Kotlin.
    implementation 'androidx.core:core:1.12.0'
    implementation 'androidx.appcompat:appcompat:1.6.1'
    implementation 'com.google.android.material:material:1.11.0'
    implementation 'androidx.constraintlayout:constraintlayout:2.1.4'

    // Add OkHttp dependency, required for WebSocketService.java.
    // This was previously (and incorrectly) in the root build.gradle's dependencies.
    implementation("com.squareup.okhttp3:okhttp:4.12.0")

    testImplementation 'junit:junit:4.13.2'
    androidTestImplementation 'androidx.test.ext:junit:1.1.5'
    androidTestImplementation 'androidx.test.espresso:espresso-core:3.5.1'
}


#################### START OF FILE: app\src\main\AndroidManifest.xml ####################

<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools">

    <!-- Standard Network Permissions -->
    <uses-permission android:name="android.permission.INTERNET" />
    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />

    <!-- Permissions for mDNS (Network Service Discovery) -->
    <uses-permission android:name="android.permission.ACCESS_WIFI_STATE" />
    <uses-permission android:name="android.permission.CHANGE_WIFI_MULTICAST_STATE" />

    <!-- Permission for Notifications (Required for Android 13+) -->
    <uses-permission android:name="android.permission.POST_NOTIFICATIONS"/>

    <!-- Permissions for Foreground Service -->
    <uses-permission android:name="android.permission.FOREGROUND_SERVICE" />
    <uses-permission android:name="android.permission.FOREGROUND_SERVICE_DATA_SYNC" />
    <!-- If targeting Android 14 (API 34) or higher and your foreground service type is dataSync,
         you might need to explicitly declare the type again here if issues arise,
         though usually the manifest merge handles it.
    <uses-permission android:name="android.permission.FOREGROUND_SERVICE_TYPE_DATA_SYNC" />
    -->


    <application
        android:allowBackup="true"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/Theme.MyBasicApp"
        tools:targetApi="31"
        android:usesCleartextTraffic="true">
        <!-- usesCleartextTraffic="true" is important for local ws:// connections -->

        <activity
            android:name=".MainActivity"
            android:exported="true"
            android:launchMode="singleTop"> <!-- singleTop is good if opening from notification -->
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>

        <service
            android:name=".WebSocketService"
            android:enabled="true"
            android:exported="false"
            android:foregroundServiceType="dataSync" />
            <!-- foregroundServiceType is required for services targeting Android Q (API 29) and above -->

    </application>

</manifest>

#################### START OF FILE: app\src\main\java\com\example\mybasicapp\DiscoveredService.java ####################

package com.example.mybasicapp;

import android.net.nsd.NsdServiceInfo;

public class DiscoveredService {
    private String serviceName;
    private String hostAddress;
    private int port;
    private String type; // e.g., _myespwebsocket._tcp

    public DiscoveredService(NsdServiceInfo nsdServiceInfo) {
        this.serviceName = nsdServiceInfo.getServiceName();
        this.hostAddress = nsdServiceInfo.getHost() != null ? nsdServiceInfo.getHost().getHostAddress() : null;
        this.port = nsdServiceInfo.getPort();
        this.type = nsdServiceInfo.getServiceType();
    }

    // Minimal constructor for manual entries or future use
    public DiscoveredService(String serviceName, String hostAddress, int port, String type) {
        this.serviceName = serviceName;
        this.hostAddress = hostAddress;
        this.port = port;
        this.type = type;
    }


    public String getServiceName() {
        return serviceName;
    }

    public String getHostAddress() {
        return hostAddress;
    }

    public int getPort() {
        return port;
    }

    public String getType() { return type; }

    public boolean isValid() {
        return hostAddress != null && !hostAddress.isEmpty() && port > 0;
    }

    @Override
    public String toString() {
        return serviceName + " (" + (hostAddress != null ? hostAddress : "Resolving...") + ":" + port + ")";
    }

    // Implement equals and hashCode to avoid duplicates in a list if necessary
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        DiscoveredService that = (DiscoveredService) o;
        return port == that.port &&
                java.util.Objects.equals(serviceName, that.serviceName) &&
                java.util.Objects.equals(hostAddress, that.hostAddress) &&
                java.util.Objects.equals(type, that.type);
    }

    @Override
    public int hashCode() {
        return java.util.Objects.hash(serviceName, hostAddress, port, type);
    }
}

#################### START OF FILE: app\src\main\java\com\example\mybasicapp\DiscoveredServicesAdapter.java ####################

package com.example.mybasicapp;

import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.TextView;
import androidx.annotation.NonNull;
import androidx.recyclerview.widget.RecyclerView;
import java.util.ArrayList;
import java.util.List;

public class DiscoveredServicesAdapter extends RecyclerView.Adapter<DiscoveredServicesAdapter.ViewHolder> {

    private List<DiscoveredService> discoveredServices = new ArrayList<>();
    private OnServiceClickListener listener;

    public interface OnServiceClickListener {
        void onServiceClick(DiscoveredService service);
    }

    public DiscoveredServicesAdapter(OnServiceClickListener listener) {
        this.listener = listener;
    }

    public void setServices(List<DiscoveredService> services) {
        this.discoveredServices.clear();
        if (services != null) {
            this.discoveredServices.addAll(services);
        }
        notifyDataSetChanged(); // Use DiffUtil for better performance in complex apps
    }

    public void addService(DiscoveredService service) {
        if (!discoveredServices.contains(service)) { // Avoid duplicates
            discoveredServices.add(service);
            notifyItemInserted(discoveredServices.size() - 1);
        } else { // If it exists, maybe update it (e.g. IP resolved)
           int index = discoveredServices.indexOf(service);
           if (index != -1) {
               discoveredServices.set(index, service);
               notifyItemChanged(index);
           }
        }
    }

    public void clearServices() {
        discoveredServices.clear();
        notifyDataSetChanged();
    }


    @NonNull
    @Override
    public ViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {
        View view = LayoutInflater.from(parent.getContext())
                .inflate(R.layout.list_item_discovered_service, parent, false);
        return new ViewHolder(view);
    }

    @Override
    public void onBindViewHolder(@NonNull ViewHolder holder, int position) {
        DiscoveredService service = discoveredServices.get(position);
        holder.bind(service, listener);
    }

    @Override
    public int getItemCount() {
        return discoveredServices.size();
    }

    static class ViewHolder extends RecyclerView.ViewHolder {
        TextView textViewServiceName;
        TextView textViewServiceAddress;

        ViewHolder(View itemView) {
            super(itemView);
            textViewServiceName = itemView.findViewById(R.id.textViewServiceName);
            textViewServiceAddress = itemView.findViewById(R.id.textViewServiceAddress);
        }

        void bind(final DiscoveredService service, final OnServiceClickListener listener) {
            textViewServiceName.setText(service.getServiceName());
            if (service.isValid()) {
                textViewServiceAddress.setText(service.getHostAddress() + ":" + service.getPort());
            } else {
                textViewServiceAddress.setText("Resolving or invalid...");
            }
            itemView.setOnClickListener(v -> listener.onServiceClick(service));
        }
    }
}

#################### START OF FILE: app\src\main\java\com\example\mybasicapp\MainActivity.java ####################

package com.example.mybasicapp;

import androidx.activity.result.ActivityResultLauncher;
import androidx.activity.result.contract.ActivityResultContracts;
import androidx.appcompat.app.AppCompatActivity;
import androidx.core.content.ContextCompat;
import androidx.localbroadcastmanager.content.LocalBroadcastManager;
import androidx.recyclerview.widget.LinearLayoutManager;
import androidx.recyclerview.widget.RecyclerView;

import android.Manifest;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.pm.PackageManager;
import android.net.Uri;
import android.net.nsd.NsdServiceInfo; // Keep for NsdHelperListener if it uses raw NsdServiceInfo for some callbacks
import android.os.Build;
import android.os.Bundle;
import android.text.Editable;
import android.text.TextUtils;
import android.text.TextWatcher;
import android.util.Log;
import android.view.View;
import android.widget.Button;
import android.widget.TextView;
import android.widget.Toast;

import com.google.android.material.textfield.TextInputEditText;
import com.google.android.material.textfield.TextInputLayout;

import java.io.IOException;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.Locale;
import java.util.Objects;

public class MainActivity extends AppCompatActivity implements NsdHelper.NsdHelperListener, DiscoveredServicesAdapter.OnServiceClickListener {

    private static final String TAG = "MainActivity";
    // mDNS Configuration Constants for WebSocket
    private static final String ESP_WEBSOCKET_SERVICE_TYPE = "_myespwebsocket._tcp";
    private static final String ESP_SERVICE_NAME_FILTER = "mrcoopersesp"; // Your ESP32's mDNS instance name
    private static final String ESP_WEBSOCKET_PATH = "/ws"; // Default path on your ESP
    private static final int ESP_DEFAULT_PORT = 80; // Default port for WS if not specified

    private TextInputLayout textInputLayoutEspAddress;
    private TextInputEditText editTextEspAddress;
    private Button buttonConnectManual, buttonDisconnect, buttonStartStopDiscovery, buttonSaveLog;
    private TextView textViewStatus, textViewLastMessage, textViewDiscoveredServicesTitle;
    private RecyclerView recyclerViewDiscoveredServices;
    private DiscoveredServicesAdapter discoveredServicesAdapter;
    private List<DiscoveredService> discoveredServiceList = new ArrayList<>();

    private NsdHelper nsdHelper;
    private StringBuilder statusLog = new StringBuilder(); // For saving to file
    private StringBuilder messageLog = new StringBuilder(); // For saving to file
    private ActivityResultLauncher<String> createFileLauncher;
    private boolean isWebSocketServiceActive = false;
    private boolean isServiceReceiverRegistered = false;
    private String lastAttemptedUrl = null;


    private final ActivityResultLauncher<String> requestPermissionLauncher =
            registerForActivityResult(new ActivityResultContracts.RequestPermission(), isGranted -> {
                if (isGranted) {
                    Toast.makeText(this, "Notifications permission granted.", Toast.LENGTH_SHORT).show();
                } else {
                    Toast.makeText(this, "Notifications permission denied. App may not show alerts.", Toast.LENGTH_LONG).show();
                }
            });

    private final BroadcastReceiver serviceUpdateReceiver = new BroadcastReceiver() {
        @Override
        public void onReceive(Context context, Intent intent) {
            String action = intent.getAction();
            String timestamp = getCurrentTimestamp();
            String statusMessage;

            if (WebSocketService.ACTION_STATUS_UPDATE.equals(action)) {
                statusMessage = intent.getStringExtra(WebSocketService.EXTRA_STATUS);
                if (statusMessage == null) statusMessage = "Unknown status";
                String logEntry = timestamp + " WS_Service_Status: " + statusMessage + "\n";
                statusLog.append(logEntry);
                Log.d(TAG, "BroadcastReceiver WS_Status: " + statusMessage);

                if (statusMessage.toLowerCase().startsWith("connected to")) {
                    isWebSocketServiceActive = true;
                    updateUIForWsConnected(statusMessage);
                } else if (statusMessage.toLowerCase().startsWith("connecting to")) {
                    isWebSocketServiceActive = false;
                    updateUIForWsConnecting(statusMessage);
                } else if (statusMessage.toLowerCase().startsWith("disconnected") ||
                        statusMessage.toLowerCase().startsWith("connection failed") ||
                        statusMessage.toLowerCase().startsWith("error:") ||
                        statusMessage.toLowerCase().equals("service stopped")) { // "service stopped" added
                    isWebSocketServiceActive = false;
                    updateUIForWsDisconnected(statusMessage);
                } else {
                    textViewStatus.setText("WS: " + statusMessage); // Generic update
                }

            } else if (WebSocketService.ACTION_MESSAGE_RECEIVED.equals(action)) {
                String title = intent.getStringExtra(WebSocketService.EXTRA_MESSAGE_TITLE);
                String body = intent.getStringExtra(WebSocketService.EXTRA_MESSAGE_BODY);
                String logEntry = timestamp + " WS_Message_Received: [" + title + "] " + body + "\n";
                messageLog.append(logEntry); // Log to separate message log
                statusLog.append(logEntry); // Also append to main status log for chronological order
                textViewLastMessage.setText(String.format(Locale.getDefault(),"Last WS Msg: [%s] %s", title, body));
                Log.d(TAG, "BroadcastReceiver WS_Message: " + title + " - " + body);
            }
        }
    };


    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        // Initialize UI elements
        textInputLayoutEspAddress = findViewById(R.id.textInputLayoutEspAddress);
        editTextEspAddress = findViewById(R.id.editTextEspAddress);
        buttonConnectManual = findViewById(R.id.buttonConnectManual);
        buttonDisconnect = findViewById(R.id.buttonDisconnect);
        buttonStartStopDiscovery = findViewById(R.id.buttonStartStopDiscovery);
        buttonSaveLog = findViewById(R.id.buttonSaveLog);
        textViewStatus = findViewById(R.id.textViewStatus);
        textViewLastMessage = findViewById(R.id.textViewLastMessage);
        textViewDiscoveredServicesTitle = findViewById(R.id.textViewDiscoveredServicesTitle);
        recyclerViewDiscoveredServices = findViewById(R.id.recyclerViewDiscoveredServices);

        setupRecyclerView();
        askNotificationPermission();
        nsdHelper = new NsdHelper(this, this);

        createFileLauncher = registerForActivityResult(new ActivityResultContracts.CreateDocument("text/plain"), uri -> {
            if (uri != null) {
                saveLogToFile(uri);
            } else {
                Toast.makeText(MainActivity.this, "Log saving cancelled.", Toast.LENGTH_SHORT).show();
            }
        });

        editTextEspAddress.addTextChangedListener(new TextWatcher() {
            @Override public void beforeTextChanged(CharSequence s, int start, int count, int after) {}
            @Override public void onTextChanged(CharSequence s, int start, int before, int count) {}
            @Override public void afterTextChanged(Editable s) {
                buttonConnectManual.setEnabled(!TextUtils.isEmpty(s.toString().trim()) && !isWebSocketServiceActive);
            }
        });

        buttonConnectManual.setOnClickListener(v -> connectToEspFromInput());
        buttonDisconnect.setOnClickListener(v -> disconnectFromEsp());
        buttonStartStopDiscovery.setOnClickListener(v -> toggleDiscovery());
        buttonSaveLog.setOnClickListener(v -> saveLog());

        updateUIForInitialState(); // Set initial UI state
        registerServiceReceiver();
    }

    private void setupRecyclerView() {
        discoveredServicesAdapter = new DiscoveredServicesAdapter(this);
        recyclerViewDiscoveredServices.setLayoutManager(new LinearLayoutManager(this));
        recyclerViewDiscoveredServices.setAdapter(discoveredServicesAdapter);
        // Initially hide the list and its title
        textViewDiscoveredServicesTitle.setVisibility(View.GONE);
        recyclerViewDiscoveredServices.setVisibility(View.GONE);
    }

    private void connectToEspFromInput() {
        String address = Objects.requireNonNull(editTextEspAddress.getText()).toString().trim();
        if (TextUtils.isEmpty(address)) {
            Toast.makeText(this, "Please enter ESP32 address or select from scan.", Toast.LENGTH_SHORT).show();
            return;
        }
        if (isWebSocketServiceActive) {
            Toast.makeText(this, "Already connected. Please disconnect first.", Toast.LENGTH_SHORT).show();
            return;
        }

        String wsUrl;
        if (address.matches("wss?://.*")) {
            wsUrl = address; // Assume full URL including path if schema is present
        } else {
            String hostPart = address;
            int portPart = ESP_DEFAULT_PORT;
            if (address.contains(":")) {
                String[] parts = address.split(":", 2);
                hostPart = parts[0];
                try {
                    if (parts.length > 1 && !TextUtils.isEmpty(parts[1])) {
                        // Check if the port part also contains the path
                        if (parts[1].contains("/")) {
                            String[] portAndPath = parts[1].split("/", 2);
                            portPart = Integer.parseInt(portAndPath[0]);
                            // Path is already implicitly handled by ESP_WEBSOCKET_PATH,
                            // but this structure would be for ws://host:port/customPath
                            // For now, we assume ESP_WEBSOCKET_PATH is standard
                        } else {
                            portPart = Integer.parseInt(parts[1]);
                        }
                    }
                } catch (NumberFormatException e) {
                    Toast.makeText(this, "Invalid port in address: " + address, Toast.LENGTH_LONG).show();
                    return;
                }
            }
            wsUrl = "ws://" + hostPart + ":" + portPart + ESP_WEBSOCKET_PATH;
        }
        lastAttemptedUrl = wsUrl;
        initiateWebSocketConnection(wsUrl);
    }

    private void initiateWebSocketConnection(String wsUrl) {
        statusLog.append(getCurrentTimestamp()).append(" CMD: Attempting WS connect to ").append(wsUrl).append("\n");
        Log.i(TAG, "Initiating WS connection to: " + wsUrl);

        Intent startFgIntent = new Intent(this, WebSocketService.class);
        startFgIntent.setAction(WebSocketService.ACTION_START_FOREGROUND_SERVICE);
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            startForegroundService(startFgIntent);
        } else {
            startService(startFgIntent);
        }

        // Short delay to give service time to start if it wasn't running
        new android.os.Handler(Looper.getMainLooper()).postDelayed(() -> {
            Intent connectIntent = new Intent(this, WebSocketService.class);
            connectIntent.setAction(WebSocketService.ACTION_CONNECT);
            connectIntent.putExtra(WebSocketService.EXTRA_IP_ADDRESS, wsUrl);
            startService(connectIntent);
        }, 250); // 250ms delay

        updateUIForWsConnecting("Connecting to " + wsUrl.replaceFirst("ws://", "").replaceFirst(ESP_WEBSOCKET_PATH, ""));
    }

    private void disconnectFromEsp() {
        statusLog.append(getCurrentTimestamp()).append(" CMD: User requested WS Disconnect\n");
        Log.i(TAG, "Requesting WS disconnect.");
        Intent serviceIntent = new Intent(this, WebSocketService.class);
        serviceIntent.setAction(WebSocketService.ACTION_DISCONNECT);
        startService(serviceIntent);
    }

    private void toggleDiscovery() {
        if (nsdHelper.isDiscoveryActive()) {
            nsdHelper.stopDiscovery();
        } else {
            discoveredServiceList.clear();
            discoveredServicesAdapter.clearServices(); // Clear adapter data
            textViewDiscoveredServicesTitle.setVisibility(View.GONE);
            recyclerViewDiscoveredServices.setVisibility(View.GONE);
            nsdHelper.discoverServices(ESP_SERVICE_NAME_FILTER, ESP_WEBSOCKET_SERVICE_TYPE);
        }
    }

    private void saveLog() {
        String fileName = "MrCoopersESP32_Log_" + new SimpleDateFormat("yyyyMMdd_HHmmss", Locale.getDefault()).format(new Date()) + ".txt";
        createFileLauncher.launch(fileName);
        statusLog.append(getCurrentTimestamp()).append(" CMD: Log Save Requested to ").append(fileName).append("\n");
    }

    // --- UI Update Methods ---
    private void updateUIForInitialState() {
        textViewStatus.setText("Status: Idle. Enter address or scan.");
        String currentAddress = editTextEspAddress.getText() != null ? editTextEspAddress.getText().toString().trim() : "";
        buttonConnectManual.setEnabled(!TextUtils.isEmpty(currentAddress));
        buttonDisconnect.setEnabled(false);
        textInputLayoutEspAddress.setEnabled(true);
        editTextEspAddress.setEnabled(true);
        buttonStartStopDiscovery.setText("Scan Network for ESP32");
        buttonStartStopDiscovery.setEnabled(true);
        textViewLastMessage.setText("Last WS Msg: None");
    }

    private void updateUIForWsConnecting(String statusText) {
        textViewStatus.setText(statusText); // Status text is already prefixed by service "Connecting to..."
        buttonConnectManual.setEnabled(false);
        buttonDisconnect.setEnabled(false);
        textInputLayoutEspAddress.setEnabled(false);
        editTextEspAddress.setEnabled(false);
        // Keep discovery button as is, or disable:
        // buttonStartStopDiscovery.setEnabled(false);
    }

    private void updateUIForWsConnected(String statusText) {
        textViewStatus.setText(statusText); // Status text is already prefixed by service "Connected to..."
        buttonConnectManual.setEnabled(false);
        buttonDisconnect.setEnabled(true);
        textInputLayoutEspAddress.setEnabled(false);
        editTextEspAddress.setEnabled(false);
        // If discovery was running, it might be good to stop it now, or let user stop it.
        // buttonStartStopDiscovery.setEnabled(!nsdHelper.isDiscoveryActive());
    }

    private void updateUIForWsDisconnected(String statusText) {
        textViewStatus.setText(statusText); // Status text from service "Disconnected..." or "Connection Failed..."
        String currentAddress = editTextEspAddress.getText() != null ? editTextEspAddress.getText().toString().trim() : "";
        buttonConnectManual.setEnabled(!TextUtils.isEmpty(currentAddress));
        buttonDisconnect.setEnabled(false);
        textInputLayoutEspAddress.setEnabled(true);
        editTextEspAddress.setEnabled(true);
        buttonStartStopDiscovery.setText("Scan Network for ESP32");
        buttonStartStopDiscovery.setEnabled(true);
    }

    private void updateUIDiscoveryState(boolean isDiscovering, String serviceType) {
        if (isDiscovering) {
            textViewStatus.setText("Status: Scanning for " + ESP_SERVICE_NAME_FILTER + " (" + serviceType + ")...");
            buttonStartStopDiscovery.setText("Stop Scan");
            buttonStartStopDiscovery.setEnabled(true);
        } else {
            // textViewStatus might be updated by connection status, so only update if not connected/connecting
            if (!isWebSocketServiceActive && (textViewStatus.getText().toString().toLowerCase().contains("scanning") || textViewStatus.getText().toString().toLowerCase().contains("idle"))) {
                 textViewStatus.setText("Status: Scan stopped. " + (discoveredServiceList.isEmpty() ? "No matching services found." : "Select from list or enter address."));
            }
            buttonStartStopDiscovery.setText("Scan Network for ESP32");
            buttonStartStopDiscovery.setEnabled(true);
        }
    }

    // --- NsdHelper.NsdHelperListener Implementation ---
    @Override
    public void onNsdServiceCandidateFound(NsdServiceInfo serviceInfo) {
        runOnUiThread(() -> {
            Log.i(TAG, "NSD Candidate (raw): " + serviceInfo.getServiceName() + " Type: " + serviceInfo.getServiceType());
            // We can add a temporary "Resolving..." item to the RecyclerView here if desired
            // DiscoveredService tempService = new DiscoveredService(serviceInfo); // Uses constructor that sets hostAddress to null initially
            // discoveredServicesAdapter.addService(tempService); // Adapter handles duplicates or updates
            // if (recyclerViewDiscoveredServices.getVisibility() == View.GONE) {
            //     textViewDiscoveredServicesTitle.setVisibility(View.VISIBLE);
            //     recyclerViewDiscoveredServices.setVisibility(View.VISIBLE);
            // }
        });
    }

    @Override
    public void onNsdServiceResolved(DiscoveredService service) {
        runOnUiThread(() -> {
            Log.i(TAG, "NSD Resolved: " + service.getServiceName() + " at " + service.getHostAddress() + ":" + service.getPort());
            statusLog.append(getCurrentTimestamp()).append(" NSD: Resolved '").append(service.getServiceName()).append("' at ").append(service.getHostAddress()).append(":").append(service.getPort()).append(" Type: ").append(service.getType()).append("\n");

            if (ESP_WEBSOCKET_SERVICE_TYPE.startsWith(service.getType().replaceFirst("\\.$", ""))) { // Check if it's our WS type
                discoveredServicesAdapter.addService(service); // Adapter handles duplicates
                if (recyclerViewDiscoveredServices.getVisibility() == View.GONE && discoveredServicesAdapter.getItemCount() > 0) {
                    textViewDiscoveredServicesTitle.setVisibility(View.VISIBLE);
                    recyclerViewDiscoveredServices.setVisibility(View.VISIBLE);
                }
            }
        });
    }

    @Override
    public void onNsdServiceLost(DiscoveredService service) {
        runOnUiThread(() -> {
            Log.w(TAG, "NSD Lost: " + service.getServiceName());
            statusLog.append(getCurrentTimestamp()).append(" NSD: Lost '").append(service.getServiceName()).append("' Type: ").append(service.getType()).append("\n");

            // Create a list to hold current items, remove the lost one, then update adapter
            List<DiscoveredService> currentServices = new ArrayList<>(discoveredServiceList); // Assuming discoveredServiceList is the source for the adapter
            boolean removed = currentServices.remove(service); // Use DiscoveredService.equals()
            if(removed){
                discoveredServiceList = currentServices; // Update the main list
                discoveredServicesAdapter.setServices(discoveredServiceList); // Update adapter with the new list
            }

            if (discoveredServicesAdapter.getItemCount() == 0) {
                textViewDiscoveredServicesTitle.setVisibility(View.GONE);
                recyclerViewDiscoveredServices.setVisibility(View.GONE);
            }

            if (isWebSocketServiceActive && lastAttemptedUrl != null &&
                    ((service.getHostAddress() != null && lastAttemptedUrl.contains(service.getHostAddress())) ||
                            lastAttemptedUrl.contains(service.getServiceName()))) {
                Toast.makeText(this, service.getServiceName() + " connection may be lost.", Toast.LENGTH_LONG).show();
                // The WebSocketService itself will handle actual connection loss and broadcast updates.
                // MainActivity just notes the mDNS service is gone.
            }
        });
    }

    @Override
    public void onNsdDiscoveryFailed(String serviceType, int errorCode) {
        runOnUiThread(() -> {
            Log.e(TAG, "NSD Discovery Failed for '" + serviceType + "'. Error: " + errorCode);
            statusLog.append(getCurrentTimestamp()).append(" NSD: Discovery Failed ('").append(serviceType).append("'). Error: ").append(errorCode).append("\n");
            Toast.makeText(this, "Network Discovery Failed. Check Wi-Fi/Permissions.", Toast.LENGTH_LONG).show();
            updateUIDiscoveryState(false, serviceType);
        });
    }

    @Override
    public void onNsdResolveFailed(NsdServiceInfo serviceInfo, int errorCode) {
        runOnUiThread(() -> {
            Log.e(TAG, "NSD Resolve Failed for '" + serviceInfo.getServiceName() + "'. Error: " + errorCode);
            statusLog.append(getCurrentTimestamp()).append(" NSD: Resolve Failed for '").append(serviceInfo.getServiceName()).append("'. Error: ").append(errorCode).append("\n");
            // Optionally remove from RecyclerView if it was added as a "resolving" item
            // DiscoveredService tempService = new DiscoveredService(serviceInfo);
            // List<DiscoveredService> currentServices = new ArrayList<>(discoveredServiceList);
            // if(currentServices.remove(tempService)) {
            //     discoveredServiceList = currentServices;
            //     discoveredServicesAdapter.setServices(discoveredServiceList);
            // }
        });
    }

    @Override
    public void onNsdDiscoveryLifecycleChange(boolean active, String serviceType) {
        runOnUiThread(() -> {
            Log.i(TAG, "NSD Discovery Lifecycle: " + (active ? "STARTED" : "STOPPED") + " for " + serviceType);
            statusLog.append(getCurrentTimestamp()).append(" NSD: Discovery ").append(active ? "STARTED" : "STOPPED").append(" for '").append(serviceType).append("'\n");
            updateUIDiscoveryState(active, serviceType);
        });
    }

    // --- DiscoveredServicesAdapter.OnServiceClickListener ---
    @Override
    public void onServiceClick(DiscoveredService service) {
        if (service.isValid()) {
            Log.d(TAG, "Service clicked: " + service.getServiceName() + " at " + service.getHostAddress() + ":" + service.getPort());
            // Use IP address for direct connection attempt. Hostname.local might be better for browsers.
            editTextEspAddress.setText(service.getHostAddress() != null ? service.getHostAddress() : service.getServiceName());
            Toast.makeText(this, "'" +service.getServiceName() + "' address (" + service.getHostAddress() + ") copied. Tap 'Connect'.", Toast.LENGTH_SHORT).show();
            if (nsdHelper.isDiscoveryActive()) { // Stop discovery once a service is selected
                nsdHelper.stopDiscovery();
            }
        } else {
            Toast.makeText(this, service.getServiceName() + " is not fully resolved. Please wait.", Toast.LENGTH_SHORT).show();
        }
    }

    // --- Helper Methods & Lifecycle ---
    private String getCurrentTimestamp() {
        return new SimpleDateFormat("yyyy-MM-dd HH:mm:ss", Locale.getDefault()).format(new Date());
    }

    private void saveLogToFile(Uri uri) {
        try (OutputStream outputStream = getContentResolver().openOutputStream(uri);
             OutputStreamWriter writer = new OutputStreamWriter(Objects.requireNonNull(outputStream))) { // Added Objects.requireNonNull
            writer.write("--- Activity, Status & NSD Log ---\n");
            writer.write(statusLog.toString());
            writer.write("\n--- WebSocket Message Log ---\n");
            writer.write(messageLog.toString());
            writer.flush();
            Toast.makeText(this, "Log saved successfully to " + uri.getPath(), Toast.LENGTH_LONG).show();
        } catch (IOException e) {
            Log.e(TAG, "Error saving log to file", e);
            Toast.makeText(this, "Error saving log: " + e.getMessage(), Toast.LENGTH_LONG).show();
        }  catch (NullPointerException e) {
            Log.e(TAG, "Error getting output stream for URI: " + uri.toString(), e);
            Toast.makeText(this, "Error preparing log file for saving.", Toast.LENGTH_LONG).show();
        }
    }

    private void askNotificationPermission() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
            if (ContextCompat.checkSelfPermission(this, Manifest.permission.POST_NOTIFICATIONS) !=
                    PackageManager.PERMISSION_GRANTED) {
                Log.d(TAG, "Requesting POST_NOTIFICATIONS permission.");
                requestPermissionLauncher.launch(Manifest.permission.POST_NOTIFICATIONS);
            }
        }
    }

    private void registerServiceReceiver() {
        if (!isServiceReceiverRegistered) {
            IntentFilter filter = new IntentFilter();
            filter.addAction(WebSocketService.ACTION_STATUS_UPDATE);
            filter.addAction(WebSocketService.ACTION_MESSAGE_RECEIVED);
            LocalBroadcastManager.getInstance(this).registerReceiver(serviceUpdateReceiver, filter);
            isServiceReceiverRegistered = true;
            Log.d(TAG, "ServiceUpdateReceiver registered.");
        }
    }

    private void unregisterServiceReceiver() {
        if (isServiceReceiverRegistered) {
            LocalBroadcastManager.getInstance(this).unregisterReceiver(serviceUpdateReceiver);
            isServiceReceiverRegistered = false;
            Log.d(TAG, "ServiceUpdateReceiver unregistered.");
        }
    }

    @Override
    protected void onResume() {
        super.onResume();
        Log.d(TAG, "onResume");
        registerServiceReceiver();
        // Optionally, refresh UI state based on WebSocketService's current state if it was running
        // This is tricky as service state isn't directly queried. Broadcasts are preferred.
        // For now, UI updates based on its own `isWebSocketServiceActive` flag which is set by broadcasts.
        if (isWebSocketServiceActive) {
            updateUIForWsConnected("WS: Still connected (assumed)"); // Or fetch last known status
        } else {
             String currentAddress = editTextEspAddress.getText() != null ? editTextEspAddress.getText().toString().trim() : "";
             buttonConnectManual.setEnabled(!TextUtils.isEmpty(currentAddress));
             buttonDisconnect.setEnabled(false);
        }
    }

    @Override
    protected void onPause() {
        super.onPause();
        Log.d(TAG, "onPause");
        // Consider if discovery should be stopped when app is paused to save battery
        // if (nsdHelper.isDiscoveryActive()) {
        //     nsdHelper.stopDiscovery();
        // }
    }

    @Override
    protected void onStop() {
        super.onStop();
        Log.d(TAG, "onStop");
        // If discovery is battery intensive, definitely stop it here.
        if (nsdHelper.isDiscoveryActive()) {
             Log.d(TAG, "Stopping NSD discovery in onStop.");
             nsdHelper.stopDiscovery();
        }
    }

    @Override
    protected void onDestroy() {
        Log.d(TAG, "onDestroy");
        unregisterServiceReceiver();
        nsdHelper.tearDown(); // Stop discovery and release NsdManager resources

        // Decide if service should be stopped when MainActivity is destroyed
        // If you want the service to continue running (e.g. receiving notifications)
        // then do not stop it here unless it's explicitly desired (e.g. by user action).
        // If the service is only for when app is active, then stop it:
        // Intent stopServiceIntent = new Intent(this, WebSocketService.class);
        // stopServiceIntent.setAction(WebSocketService.ACTION_STOP_FOREGROUND_SERVICE);
        // startService(stopServiceIntent);
        // Log.d(TAG, "Requested WebSocketService stop in onDestroy.");

        super.onDestroy();
    }
}

#################### START OF FILE: app\src\main\java\com\example\mybasicapp\NsdHelper.java ####################

package com.example.mybasicapp;

import android.content.Context;
import android.net.nsd.NsdManager;
import android.net.nsd.NsdServiceInfo;
import android.util.Log;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.ConcurrentLinkedQueue;

public class NsdHelper {

    private static final String TAG = "NsdHelper";

    private NsdManager nsdManager;
    private NsdManager.DiscoveryListener discoveryListener;

    private boolean discoveryActive = false;
    private String serviceNameFilter; // Specific name like "mrcoopersesp"
    private String currentServiceTypeToDiscover; // e.g. "_myespwebsocket._tcp."

    public interface NsdHelperListener {
        // Called when a service matching the type and name (if specified) is initially found, before IP resolution
        void onNsdServiceCandidateFound(NsdServiceInfo serviceInfo);
        // Called when a service has been successfully resolved (IP and port obtained)
        void onNsdServiceResolved(DiscoveredService discoveredService);
        // Called when a previously resolved service is lost
        void onNsdServiceLost(DiscoveredService discoveredService); // Use DiscoveredService for consistency
        // Called when discovery fails to start
        void onNsdDiscoveryFailed(String serviceType, int errorCode);
        // Called when resolving a specific service fails
        void onNsdResolveFailed(NsdServiceInfo serviceInfo, int errorCode);
        // Called when discovery starts or stops
        void onNsdDiscoveryLifecycleChange(boolean active, String serviceType);
    }

    private NsdHelperListener listener;
    // Queue for services pending resolution. ConcurrentLinkedQueue is thread-safe.
    private ConcurrentLinkedQueue<NsdServiceInfo> resolveQueue = new ConcurrentLinkedQueue<>();
    private boolean isCurrentlyResolving = false; // Flag to prevent multiple concurrent resolve calls on NsdManager

    public NsdHelper(Context context, NsdHelperListener listener) {
        this.nsdManager = (NsdManager) context.getSystemService(Context.NSD_SERVICE);
        this.listener = listener;
        initializeDiscoveryListener(); // Initialize listener once
    }

    private void initializeDiscoveryListener() {
        discoveryListener = new NsdManager.DiscoveryListener() {
            @Override
            public void onDiscoveryStarted(String regType) {
                Log.i(TAG, "NSD Discovery STARTED for type: " + regType);
                discoveryActive = true;
                if (listener != null) listener.onNsdDiscoveryLifecycleChange(true, regType);
            }

            @Override
            public void onServiceFound(NsdServiceInfo service) {
                Log.i(TAG, "NSD Candidate Found (Raw): Name='" + service.getServiceName() + "', Type='" + service.getServiceType() + "'");

                if (currentServiceTypeToDiscover == null || currentServiceTypeToDiscover.isEmpty()) {
                    Log.e(TAG, "currentServiceTypeToDiscover is null or empty. Cannot filter by type.");
                    return;
                }
                // Normalize both types for comparison (remove trailing dot if present)
                String foundServiceTypeNormalized = service.getServiceType().replaceFirst("\\.$", "");
                String expectedServiceTypeNormalized = currentServiceTypeToDiscover.replaceFirst("\\.$", "");

                if (foundServiceTypeNormalized.equalsIgnoreCase(expectedServiceTypeNormalized)) {
                    // If a specific service name filter is set, ensure the found service name matches it.
                    if (serviceNameFilter != null && !serviceNameFilter.isEmpty() &&
                            !service.getServiceName().equalsIgnoreCase(serviceNameFilter)) {
                        Log.d(TAG, "Service candidate '" + service.getServiceName() + "' matches type but NOT name filter '" + serviceNameFilter + "'. Ignoring for resolution queue.");
                        return;
                    }
                    Log.i(TAG, "Matching service candidate '" + service.getServiceName() + "' (Type: " + service.getServiceType() + "). Adding to resolve queue.");
                    if (listener != null) listener.onNsdServiceCandidateFound(service);
                    addToResolveQueue(service);
                } else {
                    Log.d(TAG, "Service '" + service.getServiceName() + "' type '" + foundServiceTypeNormalized + "' does not match expected type '" + expectedServiceTypeNormalized + "'.");
                }
            }

            @Override
            public void onServiceLost(NsdServiceInfo service) {
                Log.w(TAG, "NSD Service LOST (Raw): Name='" + service.getServiceName() + "', Type='" + service.getServiceType() + "'");
                if (listener != null) listener.onNsdServiceLost(new DiscoveredService(service));
                // Remove from resolve queue if it was pending
                resolveQueue.remove(service);
            }

            @Override
            public void onDiscoveryStopped(String serviceType) {
                Log.i(TAG, "NSD Discovery STOPPED for type: " + serviceType);
                discoveryActive = false;
                resolveQueue.clear(); // Clear queue when discovery stops
                isCurrentlyResolving = false; // Reset resolving flag
                if (listener != null) listener.onNsdDiscoveryLifecycleChange(false, serviceType);
            }

            @Override
            public void onStartDiscoveryFailed(String serviceType, int errorCode) {
                Log.e(TAG, "NSD Discovery START FAILED for type '" + serviceType + "', Error code: " + errorCode);
                discoveryActive = false;
                if (listener != null) listener.onNsdDiscoveryFailed(serviceType, errorCode);
            }

            @Override
            public void onStopDiscoveryFailed(String serviceType, int errorCode) {
                Log.e(TAG, "NSD Discovery STOP FAILED for type '" + serviceType + "', Error code: " + errorCode);
                // Even if stop fails, assume it's no longer reliably active from app's perspective
                discoveryActive = false;
                resolveQueue.clear();
                isCurrentlyResolving = false;
                if (listener != null) listener.onNsdDiscoveryLifecycleChange(false, serviceType);
            }
        };
    }

    private void addToResolveQueue(NsdServiceInfo serviceInfo) {
        // Avoid adding duplicates to the queue if a simple check is sufficient
        // For NsdServiceInfo, reference equality or checking name/type might be needed if re-found
        if (!resolveQueue.contains(serviceInfo)) {
            resolveQueue.offer(serviceInfo); // Add to the end of the queue
            processNextInResolveQueue();
        } else {
            Log.d(TAG, "Service " + serviceInfo.getServiceName() + " already in resolve queue.");
        }
    }

    private void processNextInResolveQueue() {
        synchronized (this) { // Synchronize access to isCurrentlyResolving and queue polling
            if (isCurrentlyResolving || resolveQueue.isEmpty()) {
                return; // Either already resolving or queue is empty
            }
            isCurrentlyResolving = true;
        }

        NsdServiceInfo serviceToResolve = resolveQueue.poll(); // Retrieves and removes the head
        if (serviceToResolve == null) { // Should not happen if queue wasn't empty
             synchronized (this) { isCurrentlyResolving = false; }
            return;
        }

        Log.d(TAG, "Attempting to resolve: " + serviceToResolve.getServiceName() + " from queue.");
        nsdManager.resolveService(serviceToResolve, new NsdManager.ResolveListener() {
            @Override
            public void onResolveFailed(NsdServiceInfo serviceInfo, int errorCode) {
                Log.e(TAG, "NSD Resolve FAILED for service: '" + serviceInfo.getServiceName() + "', Error code: " + errorCode);
                if (listener != null) listener.onNsdResolveFailed(serviceInfo, errorCode);
                finishResolvingAndProcessNext();
            }

            @Override
            public void onServiceResolved(NsdServiceInfo serviceInfo) {
                Log.i(TAG, "NSD Service RESOLVED: Name='" + serviceInfo.getServiceName() +
                        "', Host='" + (serviceInfo.getHost() != null ? serviceInfo.getHost().getHostAddress() : "N/A") +
                        "', Port='" + serviceInfo.getPort() + "'");
                if (listener != null) listener.onNsdServiceResolved(new DiscoveredService(serviceInfo));
                finishResolvingAndProcessNext();
            }
        });
    }

    private void finishResolvingAndProcessNext() {
        synchronized (this) {
            isCurrentlyResolving = false; // Allow next resolve to start
        }
        processNextInResolveQueue(); // Check if more items are in the queue
    }

    public void discoverServices(String targetServiceNameFilter, String serviceTypeToScan) {
        if (nsdManager == null) {
            Log.e(TAG, "NsdManager is not initialized. Cannot discover services.");
            if (listener != null) listener.onNsdDiscoveryFailed(serviceTypeToScan, -1); // Custom error
            return;
        }
        if (serviceTypeToScan == null || serviceTypeToScan.isEmpty()) {
            Log.e(TAG, "Service type to scan cannot be null or empty.");
            if (listener != null) listener.onNsdDiscoveryFailed("", NsdManager.FAILURE_BAD_PARAMETERS);
            return;
        }

        if (discoveryActive) {
            Log.d(TAG, "Discovery already active for '" + currentServiceTypeToDiscover + "'. Stopping first.");
            // Stop first, the listener callback onDiscoveryStopped will allow starting new one if needed
            // or UI can re-trigger. For now, let's assume stop is effective quickly.
            nsdManager.stopServiceDiscovery(discoveryListener); // Call directly, rely on callbacks
            // discoveryActive will be set to false in onDiscoveryStopped
        }

        this.serviceNameFilter = targetServiceNameFilter;
        // NsdManager.discoverServices expects the type to end with a dot for some protocols.
        this.currentServiceTypeToDiscover = serviceTypeToScan.endsWith(".") ? serviceTypeToScan : serviceTypeToScan + ".";

        Log.i(TAG, "Requesting NSD service discovery for type: '" + currentServiceTypeToDiscover +
                (serviceNameFilter != null && !serviceNameFilter.isEmpty() ? "' with name filter: '" + serviceNameFilter + "'" : "'"));
        try {
            // discoveryListener should have been initialized in constructor.
            nsdManager.discoverServices(currentServiceTypeToDiscover, NsdManager.PROTOCOL_DNS_SD, discoveryListener);
        } catch (Exception e) { // Catch any unexpected errors from discoverServices
            Log.e(TAG, "Exception during nsdManager.discoverServices call: " + e.getMessage(), e);
            discoveryActive = false; // Ensure state is correct
            if (listener != null) listener.onNsdDiscoveryFailed(currentServiceTypeToDiscover, NsdManager.FAILURE_INTERNAL_ERROR);
        }
    }

    public void stopDiscovery() {
        if (nsdManager == null) {
            Log.e(TAG, "NsdManager is not initialized. Cannot stop discovery.");
            return;
        }
        if (discoveryListener != null && discoveryActive) {
            try {
                Log.i(TAG, "Requesting to stop NSD service discovery for type: " + currentServiceTypeToDiscover);
                nsdManager.stopServiceDiscovery(discoveryListener);
                // discoveryActive will be set to false in the onDiscoveryStopped callback.
            } catch (IllegalArgumentException e) { // If listener not registered
                Log.w(TAG, "Error stopping discovery (IllegalArgumentException): " + e.getMessage() + ". Already stopped or listener invalid?");
                discoveryActive = false; // Force state update
                resolveQueue.clear();
                isCurrentlyResolving = false;
                if (listener != null && currentServiceTypeToDiscover != null) {
                    listener.onNsdDiscoveryLifecycleChange(false, currentServiceTypeToDiscover);
                }
            }
        } else {
            Log.d(TAG, "No active NSD discovery to stop, or listener is null.");
            if(discoveryActive) { // Correct the state if it was wrongly true
                discoveryActive = false;
                if (listener != null && currentServiceTypeToDiscover != null) {
                    listener.onNsdDiscoveryLifecycleChange(false, currentServiceTypeToDiscover);
                }
            }
        }
    }

    public void tearDown() {
        Log.d(TAG, "Tearing down NsdHelper.");
        if (nsdManager != null) {
            stopDiscovery(); // Ensure discovery is stopped.
        }
        this.listener = null; // Remove reference to listener
        // NsdManager is a system service, no explicit close method for manager itself.
        // discoveryListener will be garbage collected if no longer referenced.
        Log.d(TAG, "NsdHelper torn down.");
    }

    public boolean isDiscoveryActive() {
        return discoveryActive;
    }
}

#################### START OF FILE: app\src\main\java\com\example\mybasicapp\WebSocketService.java ####################

package com.example.mybasicapp;

import android.app.Notification;
import android.app.NotificationChannel;
import android.app.NotificationManager;
import android.app.PendingIntent;
import android.app.Service;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.content.pm.ServiceInfo;
import android.os.Build;
import android.os.Handler;
import android.os.IBinder;
import android.os.Looper;
import android.util.Log;

import androidx.annotation.Nullable;
import androidx.core.app.ActivityCompat;
import androidx.core.app.NotificationCompat;
import androidx.core.app.NotificationManagerCompat;
import androidx.localbroadcastmanager.content.LocalBroadcastManager;

import org.json.JSONException;
import org.json.JSONObject;

import java.util.Locale;
import java.util.concurrent.TimeUnit;

import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.Response;
import okhttp3.WebSocket;
import okhttp3.WebSocketListener;
import okio.ByteString;

public class WebSocketService extends Service {

    private static final String TAG = "WebSocketService";
    // Ensure action strings are unique if copied from elsewhere or define them in a central place
    public static final String ACTION_START_FOREGROUND_SERVICE = "com.example.mybasicapp.ACTION_START_FOREGROUND_SERVICE";
    public static final String ACTION_STOP_FOREGROUND_SERVICE = "com.example.mybasicapp.ACTION_STOP_FOREGROUND_SERVICE";
    public static final String ACTION_CONNECT = "com.example.mybasicapp.ACTION_CONNECT";
    public static final String ACTION_DISCONNECT = "com.example.mybasicapp.ACTION_DISCONNECT";
    public static final String EXTRA_IP_ADDRESS = "EXTRA_IP_ADDRESS"; // This is the full ws:// URL

    public static final String ACTION_STATUS_UPDATE = "com.example.mybasicapp.ACTION_STATUS_UPDATE";
    public static final String EXTRA_STATUS = "EXTRA_STATUS";
    public static final String ACTION_MESSAGE_RECEIVED = "com.example.mybasicapp.ACTION_MESSAGE_RECEIVED";
    public static final String EXTRA_MESSAGE_TITLE = "EXTRA_MESSAGE_TITLE";
    public static final String EXTRA_MESSAGE_BODY = "EXTRA_MESSAGE_BODY";

    private static final String NOTIFICATION_CHANNEL_ID_SERVICE = "web_socket_service_status_channel";
    private static final String NOTIFICATION_CHANNEL_ID_MESSAGES = "esp32_message_notifications";
    private static final int SERVICE_NOTIFICATION_ID = 1; // Must be > 0
    private static final int MESSAGE_NOTIFICATION_ID = 101;

    private OkHttpClient httpClient;
    private WebSocket webSocketClient;
    private String currentWebSocketUrl; // Stores the URL we are currently connected to or trying to connect to
    private Handler retryHandler = new Handler(Looper.getMainLooper());
    private boolean isServiceRunningAsForeground = false;
    private int connectionRetryCount = 0;
    private static final int MAX_CONNECTION_RETRIES = 5; // Max attempts before giving up (for a single connect sequence)
    private static final long INITIAL_RETRY_DELAY_MS = 3000; // 3 seconds
    private static final long MAX_RETRY_DELAY_MS = 30000; // 30 seconds max between retries

    @Override
    public void onCreate() {
        super.onCreate();
        Log.i(TAG, "Service onCreate");
        httpClient = new OkHttpClient.Builder()
                .pingInterval(20, TimeUnit.SECONDS)
                .connectTimeout(10, TimeUnit.SECONDS)
                .readTimeout(30, TimeUnit.SECONDS)
                .writeTimeout(10, TimeUnit.SECONDS)
                .retryOnConnectionFailure(false) // We handle retries manually
                .build();
        createNotificationChannel(NOTIFICATION_CHANNEL_ID_SERVICE, "ESP32 Sync Service", NotificationManager.IMPORTANCE_LOW);
        createNotificationChannel(NOTIFICATION_CHANNEL_ID_MESSAGES, getString(R.string.channel_name), NotificationManager.IMPORTANCE_HIGH);
    }

    @Override
    public int onStartCommand(Intent intent, int flags, int startId) {
        if (intent == null || intent.getAction() == null) {
            Log.w(TAG, "onStartCommand: Null intent or action. Service might be restarting.");
            if (!isServiceRunningAsForeground) {
                 startForegroundServiceWithNotification("Service Initializing..."); // Ensure foreground state on restart
            }
            return START_STICKY; // Try to restart if killed
        }

        String action = intent.getAction();
        Log.i(TAG, "onStartCommand received Action: " + action);

        switch (action) {
            case ACTION_START_FOREGROUND_SERVICE:
                if (!isServiceRunningAsForeground) {
                    startForegroundServiceWithNotification("Service Active. Waiting for connection command.");
                }
                break;
            case ACTION_STOP_FOREGROUND_SERVICE:
                stopServiceAndForeground();
                return START_NOT_STICKY; // Do not restart if explicitly stopped
            case ACTION_CONNECT:
                if (!isServiceRunningAsForeground) {
                    startForegroundServiceWithNotification("Preparing to connect...");
                }
                String wsUrlFromIntent = intent.getStringExtra(EXTRA_IP_ADDRESS);
                if (wsUrlFromIntent != null && !wsUrlFromIntent.isEmpty()) {
                    // If already connected to a different URL, disconnect first
                    if (webSocketClient != null && currentWebSocketUrl != null && !currentWebSocketUrl.equals(wsUrlFromIntent)) {
                        Log.d(TAG, "Connecting to new URL. Closing existing connection to " + currentWebSocketUrl);
                        disconnectWebSocket("Connecting to new target: " + wsUrlFromIntent);
                    }
                    currentWebSocketUrl = wsUrlFromIntent;
                    connectionRetryCount = 0; // Reset retries for a new explicit connect command
                    cancelPendingRetries();
                    connectWebSocket(currentWebSocketUrl);
                } else {
                    Log.e(TAG, "ACTION_CONNECT: WebSocket URL is null or empty.");
                    sendBroadcastStatus("Error: WebSocket URL missing for connect command");
                    updateServiceNotification("Error: URL Missing");
                }
                break;
            case ACTION_DISCONNECT:
                disconnectWebSocket("User requested disconnect");
                updateServiceNotification("Disconnected by user."); // Update notification after explicit disconnect
                break;
            default:
                Log.w(TAG, "onStartCommand: Unhandled action: " + action);
                break;
        }
        return START_STICKY;
    }

    private void startForegroundServiceWithNotification(String statusText) {
        Intent notificationIntent = new Intent(this, MainActivity.class);
        PendingIntent pendingIntent = PendingIntent.getActivity(this, 0,
                notificationIntent, PendingIntent.FLAG_IMMUTABLE | PendingIntent.FLAG_UPDATE_CURRENT);

        Notification notification = new NotificationCompat.Builder(this, NOTIFICATION_CHANNEL_ID_SERVICE)
                .setContentTitle(getString(R.string.app_name) + " Sync")
                .setContentText(statusText)
                .setSmallIcon(R.drawable.ic_stat_service)
                .setContentIntent(pendingIntent)
                .setOngoing(true)
                .setPriority(NotificationCompat.PRIORITY_LOW)
                .setCategory(NotificationCompat.CATEGORY_SERVICE)
                .build();
        try {
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
                startForeground(SERVICE_NOTIFICATION_ID, notification, ServiceInfo.FOREGROUND_SERVICE_TYPE_DATA_SYNC);
            } else {
                startForeground(SERVICE_NOTIFICATION_ID, notification);
            }
            isServiceRunningAsForeground = true;
            Log.i(TAG, "Service started in foreground. Status: " + statusText);
        } catch (Exception e) { // Catch SecurityException, IllegalStateException, etc.
            Log.e(TAG, "Error starting foreground service: " + e.getClass().getSimpleName() + " - " + e.getMessage(), e);
            isServiceRunningAsForeground = false;
            // Consider calling stopSelf() if foregrounding is mandatory and fails.
        }
    }

    private void updateServiceNotification(String text) {
        if (!isServiceRunningAsForeground) {
            Log.d(TAG, "Service not in foreground, persistent notification not updated. Current text would be: " + text);
            return;
        }
        NotificationManager manager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);
        if (manager == null) {
            Log.e(TAG, "NotificationManager is null, cannot update notification.");
            return;
        }

        Intent notificationIntent = new Intent(this, MainActivity.class);
        PendingIntent pendingIntent = PendingIntent.getActivity(this, 0,
                notificationIntent, PendingIntent.FLAG_IMMUTABLE | PendingIntent.FLAG_UPDATE_CURRENT);

        Notification notification = new NotificationCompat.Builder(this, NOTIFICATION_CHANNEL_ID_SERVICE)
                .setContentTitle(getString(R.string.app_name) + " Sync")
                .setContentText(text)
                .setSmallIcon(R.drawable.ic_stat_service)
                .setContentIntent(pendingIntent)
                .setOngoing(true)
                .setPriority(NotificationCompat.PRIORITY_LOW)
                .setCategory(NotificationCompat.CATEGORY_SERVICE)
                .build();
        try {
            manager.notify(SERVICE_NOTIFICATION_ID, notification);
        } catch (Exception e) {
            Log.e(TAG, "Error updating service notification: " + e.getMessage(), e);
        }
    }

    private void connectWebSocket(final String wsUrlToConnect) {
        if (wsUrlToConnect == null || wsUrlToConnect.isEmpty()) {
            Log.e(TAG, "connectWebSocket: Aborted, URL is null or empty.");
            sendBroadcastStatus("Error: Invalid ESP32 URL for connection");
            updateServiceNotification("Error: Invalid URL");
            return;
        }

        if (webSocketClient != null) { // Should have been handled by disconnectWebSocket if URL changed
            Log.d(TAG, "connectWebSocket: Closing pre-existing client before connecting to " + wsUrlToConnect);
            webSocketClient.close(1001, "Client re-initiating connection");
            webSocketClient = null;
        }

        Request request = new Request.Builder().url(wsUrlToConnect).build();
        final String displayUrl = wsUrlToConnect.replaceFirst("ws://", "").replaceFirst("/ws", ""); // For display only
        String connectingMsg = "Connecting to: " + displayUrl +
                (connectionRetryCount > 0 ? " (Retrying " + connectionRetryCount + "/" + MAX_CONNECTION_RETRIES + ")" : "");
        Log.i(TAG, "Attempting WebSocket connection to: " + wsUrlToConnect + (connectionRetryCount > 0 ? " (Retry " + connectionRetryCount + ")" : ""));
        sendBroadcastStatus(connectingMsg);
        updateServiceNotification(connectingMsg);

        // Create a new WebSocket client for this attempt
        webSocketClient = httpClient.newWebSocket(request, new WebSocketListener() {
            @Override
            public void onOpen(WebSocket ws, Response response) {
                super.onOpen(ws, response);
                 // Check if this callback is for the current connection attempt
                if (!wsUrlToConnect.equals(currentWebSocketUrl)) {
                    Log.w(TAG, "onOpen received for a stale URL: " + wsUrlToConnect + ". Current target: " + currentWebSocketUrl + ". Closing this connection.");
                    ws.close(1000, "Stale connection attempt.");
                    return;
                }
                Log.i(TAG, "WebSocket Opened with " + displayUrl);
                sendBroadcastStatus("Connected to: " + displayUrl);
                updateServiceNotification("Connected to: " + displayUrl);
                connectionRetryCount = 0; // Reset on successful connection
                cancelPendingRetries();
                // WebSocketService.this.webSocketClient = ws; // Already set before calling newWebSocket
            }

            @Override
            public void onMessage(WebSocket ws, String text) {
                super.onMessage(ws, text);
                if (!wsUrlToConnect.equals(currentWebSocketUrl) || WebSocketService.this.webSocketClient != ws) {
                     Log.w(TAG, "onMessage from a stale/unexpected WebSocket instance. Ignoring."); return;
                }
                Log.i(TAG, "WS Message from " + displayUrl + ": " + text);
                try {
                    JSONObject json = new JSONObject(text);
                    String event = json.optString("event", "unknown_event");

                    if ("motion_detected".equals(event)) {
                        double distanceCm = json.optDouble("distance_cm", -1.0);
                        String title = "Motion Alert!";
                        String messageBody = String.format(Locale.getDefault(), "Motion at %.1f cm detected.", distanceCm);
                        sendBroadcastMessage(title, messageBody);
                        showDataNotification(title, messageBody);
                    } else {
                        String title = json.optString("title", "ESP32 Info");
                        String messageBody = json.optString("message", text);
                        sendBroadcastMessage(title, messageBody);
                        Log.d(TAG, "Received event '" + event + "' or generic message: " + text);
                    }
                } catch (JSONException e) {
                    Log.e(TAG, "Error parsing JSON from WebSocket: " + e.getMessage() + ". Raw: " + text);
                    sendBroadcastMessage("ESP32 Raw Message", text);
                }
            }

            @Override
            public void onMessage(WebSocket ws, ByteString bytes) {
                super.onMessage(ws, bytes);
                 if (!wsUrlToConnect.equals(currentWebSocketUrl) || WebSocketService.this.webSocketClient != ws) {
                     Log.w(TAG, "onMessage (bytes) from a stale/unexpected WebSocket instance. Ignoring."); return;
                }
                Log.i(TAG, "WS Receiving bytes from " + displayUrl + ": " + bytes.hex() + " (not processed)");
            }

            @Override
            public void onClosing(WebSocket ws, int code, String reason) {
                super.onClosing(ws, code, reason);
                Log.i(TAG, "WebSocket Closing: " + code + " / " + reason + " for URL: " + wsUrlToConnect);
            }

            @Override
            public void onClosed(WebSocket ws, int code, String reason) {
                super.onClosed(ws, code, reason);
                Log.i(TAG, "WebSocket Closed: " + code + " / " + reason + " for URL: " + wsUrlToConnect);
                // Check if this closed event is for the WebSocket client we care about
                if (WebSocketService.this.webSocketClient == ws) {
                    WebSocketService.this.webSocketClient = null; // Clear the active client
                    String finalStatusMsg = "Disconnected from: " + displayUrl + " (Reason: " + reason + ", Code: " + code + ")";
                    sendBroadcastStatus(finalStatusMsg);
                    updateServiceNotification("Disconnected from ESP32");

                    // Retry logic: only if not a clean/intentional close and service is still running for this URL
                    boolean intentionalClose = (code == 1000 || code == 1001); // 1000=Normal, 1001=Going Away
                    if (!intentionalClose && currentWebSocketUrl != null && currentWebSocketUrl.equals(wsUrlToConnect) && isServiceRunningAsForeground) {
                        Log.d(TAG, "Connection to " + wsUrlToConnect + " closed unexpectedly (code " + code + "). Will attempt retry.");
                        handleConnectionFailure(wsUrlToConnect, "Connection closed (code " + code + ")");
                    } else if (currentWebSocketUrl == null) {
                        Log.d(TAG, "WebSocket closed but currentWebSocketUrl is null, likely explicit disconnect. No retry.");
                    } else if (!currentWebSocketUrl.equals(wsUrlToConnect)) {
                        Log.d(TAG, "WebSocket for " + wsUrlToConnect + " closed, but current target is " + currentWebSocketUrl + ". No retry for old URL.");
                    } else {
                        Log.d(TAG, "WebSocket closed cleanly or retry not appropriate. Reason: " + reason + " Code: " + code);
                    }
                } else {
                     Log.w(TAG, "onClosed event for an old/unknown WebSocket instance (URL: " + wsUrlToConnect + "). Ignoring for retry logic.");
                }
            }

            @Override
            public void onFailure(WebSocket ws, Throwable t, Response response) {
                super.onFailure(ws, t, response);
                String errorMsg = (t != null && t.getMessage() != null) ? t.getMessage() : "Unknown connection error";
                Log.e(TAG, "WebSocket Failure for " + wsUrlToConnect + ": " + errorMsg, t);
                // Check if this failure is for the WebSocket client we care about
                if (WebSocketService.this.webSocketClient == ws) {
                    WebSocketService.this.webSocketClient = null; // Clear the active client
                    handleConnectionFailure(wsUrlToConnect, errorMsg);
                } else {
                    Log.w(TAG, "onFailure event for an old/unknown WebSocket instance (URL: " + wsUrlToConnect + "). Ignoring for retry logic.");
                }
            }
        });
    }

    private void handleConnectionFailure(String failedWsUrl, String errorMessage) {
        // Ensure we only retry if the service is still meant to be connected to THIS URL
        if (!isServiceRunningAsForeground || currentWebSocketUrl == null || !currentWebSocketUrl.equals(failedWsUrl)) {
            Log.w(TAG, "handleConnectionFailure: Conditions not met for retry on " + failedWsUrl +
                    " (service stopped, URL changed to " + currentWebSocketUrl + ", or explicit disconnect). Error: " + errorMessage);
            if (currentWebSocketUrl != null && currentWebSocketUrl.equals(failedWsUrl)) { // If it was the current URL that failed but conditions changed
                 sendBroadcastStatus("Connection Failed: " + errorMessage + " to " + failedWsUrl.replaceFirst("ws://", "").replaceFirst("/ws",""));
                 updateServiceNotification("Connection Failed");
            }
            return;
        }

        if (connectionRetryCount < MAX_CONNECTION_RETRIES) {
            long delay = (long) (INITIAL_RETRY_DELAY_MS * Math.pow(1.8, connectionRetryCount)); // Slightly less aggressive backoff
            delay = Math.min(delay, MAX_RETRY_DELAY_MS);

            final int nextRetryAttempt = connectionRetryCount + 1;
            Log.d(TAG, "Retrying connection to: " + currentWebSocketUrl + " (Attempt " + nextRetryAttempt +
                    " of " + MAX_CONNECTION_RETRIES + ") in " + (delay / 1000.0) + "s. Last Error: " + errorMessage);
            String retryStatus = String.format(Locale.US,"Connection Failed to %s. Retrying (%d/%d)...",
                    currentWebSocketUrl.replaceFirst("ws://", "").replaceFirst("/ws",""),
                    nextRetryAttempt, MAX_CONNECTION_RETRIES);

            sendBroadcastStatus(retryStatus);
            updateServiceNotification("Connection Failed. Retrying...");

            retryHandler.postDelayed(() -> {
                if (isServiceRunningAsForeground && currentWebSocketUrl != null && currentWebSocketUrl.equals(failedWsUrl)) {
                     // connectionRetryCount is incremented just before the connectWebSocket call in this block if it proceeds
                    connectWebSocket(currentWebSocketUrl); // This will use the current connectionRetryCount
                } else {
                     Log.w(TAG, "Retry for " + failedWsUrl + " was scheduled but is now cancelled due to state change (URL/service state).");
                }
            }, delay);
            connectionRetryCount++; // Increment for the next potential failure of this attempt
        } else {
            Log.e(TAG, "Max retry attempts ("+ MAX_CONNECTION_RETRIES +") reached for " + currentWebSocketUrl + ". Giving up. Last error: " + errorMessage);
            sendBroadcastStatus("Connection Failed: Max retries for " + currentWebSocketUrl.replaceFirst("ws://", "").replaceFirst("/ws",""));
            updateServiceNotification("Connection Failed. Max retries.");
            // currentWebSocketUrl = null; // Optional: Force user to explicitly reconnect.
        }
    }

    private void disconnectWebSocket(String reason) {
        Log.i(TAG, "disconnectWebSocket called. Reason: " + reason);
        cancelPendingRetries(); // Stop any retry attempts
        if (webSocketClient != null) {
            Log.d(TAG, "Closing active WebSocket client for URL: " + currentWebSocketUrl);
            webSocketClient.close(1000, reason); // 1000 Normal closure
            webSocketClient = null;
        }
        // Important: Clear currentWebSocketUrl to signify no active connection target
        // This prevents onClosed/onFailure from incorrect retry attempts after explicit disconnect.
        currentWebSocketUrl = null;
        connectionRetryCount = 0; // Reset retries
        sendBroadcastStatus("Disconnected: " + reason);
        // Foreground notification will be updated by onClosed or if explicitly stopped
    }

    private void cancelPendingRetries() {
        retryHandler.removeCallbacksAndMessages(null);
        Log.d(TAG, "Cancelled any pending connection retries.");
    }

    private void sendBroadcastStatus(String status) {
        Intent intent = new Intent(ACTION_STATUS_UPDATE);
        intent.putExtra(EXTRA_STATUS, status);
        LocalBroadcastManager.getInstance(this).sendBroadcast(intent);
        Log.v(TAG, "Broadcast Sent - Status: " + status);
    }

    private void sendBroadcastMessage(String title, String body) {
        Intent intent = new Intent(ACTION_MESSAGE_RECEIVED);
        intent.putExtra(EXTRA_MESSAGE_TITLE, title);
        intent.putExtra(EXTRA_MESSAGE_BODY, body);
        LocalBroadcastManager.getInstance(this).sendBroadcast(intent);
    }

    private void createNotificationChannel(String channelId, String channelName, int importance) {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            NotificationChannel channel = new NotificationChannel(channelId, channelName, importance);
            if (NOTIFICATION_CHANNEL_ID_MESSAGES.equals(channelId)) {
                channel.setDescription(getString(R.string.channel_description));
            } else {
                 channel.setDescription("Channel for ESP32 Sync Service status updates.");
            }
            NotificationManager notificationManager = getSystemService(NotificationManager.class);
            if (notificationManager != null) {
                notificationManager.createNotificationChannel(channel);
                Log.d(TAG, "Notification channel created/updated: " + channelId);
            } else {
                Log.e(TAG, "NotificationManager is null, cannot create channel " + channelId);
            }
        }
    }

    private void showDataNotification(String title, String message) {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
            if (ActivityCompat.checkSelfPermission(this, android.Manifest.permission.POST_NOTIFICATIONS) != PackageManager.PERMISSION_GRANTED) {
                Log.w(TAG, "POST_NOTIFICATIONS permission not granted. Cannot show data notification.");
                return;
            }
        }

        Intent intent = new Intent(this, MainActivity.class);
        intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP | Intent.FLAG_ACTIVITY_SINGLE_TOP);
        PendingIntent pendingIntent = PendingIntent.getActivity(this,
                (int) System.currentTimeMillis(), // Unique request code for pending intent
                intent,
                PendingIntent.FLAG_UPDATE_CURRENT | PendingIntent.FLAG_IMMUTABLE);

        NotificationCompat.Builder builder = new NotificationCompat.Builder(this, NOTIFICATION_CHANNEL_ID_MESSAGES)
                .setSmallIcon(R.drawable.ic_stat_message)
                .setContentTitle(title)
                .setContentText(message)
                .setPriority(NotificationCompat.PRIORITY_HIGH)
                .setAutoCancel(true)
                .setContentIntent(pendingIntent)
                .setDefaults(Notification.DEFAULT_ALL); // Uses default sound, vibrate, light

        NotificationManagerCompat notificationManager = NotificationManagerCompat.from(this);
        try {
            notificationManager.notify(MESSAGE_NOTIFICATION_ID, builder.build());
        } catch (SecurityException e) { // Should be rare with TIRAMISU check
            Log.e(TAG, "SecurityException while trying to post data notification: " + e.getMessage());
        }
    }

    private void stopServiceAndForeground() {
        Log.i(TAG, "stopServiceAndForeground called.");
        disconnectWebSocket("Service is stopping"); // Ensure WS is closed
        cancelPendingRetries();
        if (isServiceRunningAsForeground) {
            Log.d(TAG, "Stopping foreground state.");
            stopForeground(true); // True to remove the notification
            isServiceRunningAsForeground = false;
        }
        stopSelf(); // Stop the service instance
        Log.i(TAG, "WebSocketService fully stopped and resources should be released.");
        // Note: sendBroadcastStatus("Service Stopped") is often done by the component requesting the stop
        // or can be done here if a final status is needed.
    }

    @Nullable
    @Override
    public IBinder onBind(Intent intent) {
        return null; // This service is not designed for binding
    }

    @Override
    public void onDestroy() {
        Log.i(TAG, "Service onDestroy. Cleaning up...");
        disconnectWebSocket("Service being destroyed"); // Final attempt to close
        cancelPendingRetries();
        if (isServiceRunningAsForeground) { // Should already be false if stopServiceAndForeground was called
            stopForeground(true);
            isServiceRunningAsForeground = false;
        }
        if (httpClient != null) {
            // OkHttp recommends shutting down its dispatcher and connection pool for cleanup
            httpClient.dispatcher().executorService().shutdown();
            httpClient.connectionPool().evictAll();
            try {
                if (httpClient.cache() != null) {
                    httpClient.cache().close();
                }
            } catch (Exception e) {
                Log.e(TAG, "Error closing OkHttp cache during onDestroy", e);
            }
        }
        Log.i(TAG, "Service resources cleaned up in onDestroy.");
        super.onDestroy();
    }
}

#################### START OF FILE: app\src\main\res\drawable\ic_stat_message.xml ####################

<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24.0"
    android:viewportHeight="24.0"
    android:tint="?attr/colorControlNormal">
  <path
      android:fillColor="@android:color/white"
      android:pathData="M20,2L4,2c-1.1,0 -1.99,0.9 -1.99,2L2,22l4,-4h14c1.1,0 2,-0.9 2,-2L22,4c0,-1.1 -0.9,-2 -2,-2zM18,14L6,14v-2h12v2zM18,11L6,11L6,9h12v2zM18,8L6,8L6,6h12v2z"/>
</vector>

#################### START OF FILE: app\src\main\res\drawable\ic_stat_service.xml ####################

<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24.0"
    android:viewportHeight="24.0"
    android:tint="?attr/colorControlNormal"> <!-- Or a specific color -->
  <path
      android:fillColor="@android:color/white"
      android:pathData="M12,2C6.48,2 2,6.48 2,12s4.48,10 10,10 10,-4.48 10,-10S17.52,2 12,2zM12,20c-4.41,0 -8,-3.59 -8,-8s3.59,-8 8,-8 8,3.59 8,8 -3.59,8 -8,8zM13,7h-2v6h2V7zm0,8h-2v2h2v-2z"/>
</vector>

#################### START OF FILE: app\src\main\res\layout\activity_main.xml ####################

<?xml version="1.0" encoding="utf-8"?>
<androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:padding="16dp"
    tools:context=".MainActivity">

    <TextView
        android:id="@+id/textViewAppTitle"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="@string/app_name"
        android:textSize="22sp"
        android:textStyle="bold"
        app:layout_constraintTop_toTopOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent" />

    <com.google.android.material.textfield.TextInputLayout
        android:id="@+id/textInputLayoutEspAddress"
        style="@style/Widget.MaterialComponents.TextInputLayout.OutlinedBox"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:layout_marginTop="16dp"
        app:layout_constraintTop_toBottomOf="@id/textViewAppTitle"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        android:hint="ESP32 Address (IP or hostname.local)">

        <com.google.android.material.textfield.TextInputEditText
            android:id="@+id/editTextEspAddress"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:inputType="textUri|textNoSuggestions"
            android:textColor="?android:attr/textColorPrimary"
            android:singleLine="true"/>
    </com.google.android.material.textfield.TextInputLayout>

    <LinearLayout
        android:id="@+id/layoutConnectionButtons"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:orientation="horizontal"
        android:layout_marginTop="8dp"
        app:layout_constraintTop_toBottomOf="@id/textInputLayoutEspAddress"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent">

        <Button
            android:id="@+id/buttonConnectManual"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:text="Connect"
            android:layout_marginEnd="4dp"/>

        <Button
            android:id="@+id/buttonDisconnect"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:text="Disconnect"
            android:layout_marginStart="4dp"
            android:enabled="false"/>
    </LinearLayout>

    <Button
        android:id="@+id/buttonStartStopDiscovery"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:layout_marginTop="8dp"
        android:text="Scan Network for ESP32"
        app:layout_constraintTop_toBottomOf="@id/layoutConnectionButtons"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent"/>

    <TextView
        android:id="@+id/textViewDiscoveredServicesTitle"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Discovered (tap to use):"
        android:layout_marginTop="12dp"
        android:textSize="16sp"
        android:textStyle="italic"
        android:visibility="gone"
        app:layout_constraintTop_toBottomOf="@id/buttonStartStopDiscovery"
        app:layout_constraintStart_toStartOf="parent"/>

    <androidx.recyclerview.widget.RecyclerView
        android:id="@+id/recyclerViewDiscoveredServices"
        android:layout_width="0dp"
        android:layout_height="0dp"
        android:layout_marginTop="4dp"
        android:visibility="gone"
        app:layout_constraintTop_toBottomOf="@id/textViewDiscoveredServicesTitle"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintBottom_toTopOf="@+id/guidelineLogArea"
        app:layout_constraintHeight_max="200dp"
        app:layout_constraintVertical_bias="0.0"
        tools:listitem="@layout/list_item_discovered_service"
        tools:itemCount="2"/>

    <androidx.constraintlayout.widget.Guideline
        android:id="@+id/guidelineLogArea"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:orientation="horizontal"
        app:layout_constraintGuide_end="120dp"/>

    <TextView
        android:id="@+id/textViewStatus"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:text="Status: Idle"
        android:layout_marginBottom="4dp"
        android:textSize="14sp"
        app:layout_constraintBottom_toTopOf="@id/textViewLastMessage"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent" />

    <TextView
        android:id="@+id/textViewLastMessage"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:text="Last WS Msg: None"
        android:layout_marginBottom="8dp"
        android:textSize="12sp"
        app:layout_constraintBottom_toTopOf="@id/buttonSaveLog"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent"/>

    <Button
        android:id="@+id/buttonSaveLog"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:text="Save Activity Log"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent" />

</androidx.constraintlayout.widget.ConstraintLayout>

#################### START OF FILE: app\src\main\res\layout\list_item_discovered_service.xml ####################

<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:orientation="vertical"
    android:padding="12dp"
    android:background="?android:attr/selectableItemBackground">

    <TextView
        android:id="@+id/textViewServiceName"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:textSize="16sp"
        android:textStyle="bold"
        android:textColor="?android:attr/textColorPrimary" />

    <TextView
        android:id="@+id/textViewServiceAddress"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:textSize="14sp"
        android:textColor="?android:attr/textColorSecondary" />
</LinearLayout>

#################### START OF FILE: app\src\main\res\values\colors.xml ####################

<?xml version="1.0" encoding="utf-8"?>
<resources>
    <!-- Theme Colors for MyBasicApp -->
    <color name="my_app_primary">#1A535C</color> <!-- A dark teal/green, adjust to your liking -->
    <color name="my_app_primary_dark">#0E3F47</color> <!-- A darker shade for status bar -->
    <color name="my_app_accent">#F7B801</color> <!-- An accent color, e.g., a gold/yellow -->

    <!-- Standard Android/Material Colors (can be used as fallbacks or for other UI elements) -->
    <color name="purple_200">#FFBB86FC</color>
    <color name="purple_500">#FF6200EE</color>
    <color name="purple_700">#FF3700B3</color>
    <color name="teal_200">#FF03DAC5</color>
    <color name="teal_700">#FF018786</color>
    <color name="black">#FF000000</color>
    <color name="white">#FFFFFFFF</color>

    <!-- Text Colors -->
    <color name="text_on_primary">#FFFFFF</color>
    <color name="text_on_accent">#000000</color>
</resources>


#################### START OF FILE: app\src\main\res\values\strings.xml ####################

<resources>
    <string name="app_name">Mr Coopers ESP32</string>
    <!-- For Notification Channel for ESP32 messages -->
    <string name="channel_name">ESP32 Notifications</string>
    <string name="channel_description">Notifications received from the local ESP32 device.</string>
</resources>

#################### START OF FILE: app\src\main\res\values\themes.xml ####################

<?xml version="1.0" encoding="utf-8"?>
<resources xmlns:tools="http://schemas.android.com/tools">
    <!-- Base application theme. -->
    <style name="Theme.MyBasicApp" parent="Theme.MaterialComponents.DayNight.DarkActionBar">
        <!-- Primary brand color. -->
        <item name="colorPrimary">@color/my_app_primary</item>
        <item name="colorPrimaryVariant">@color/my_app_primary_dark</item> <!-- Used for status bar by default -->
        <item name="colorOnPrimary">@color/text_on_primary</item> <!-- Text/icon color on primary color -->

        <!-- Secondary brand color (accent color). -->
        <item name="colorSecondary">@color/my_app_accent</item>
        <item name="colorSecondaryVariant">@color/my_app_accent</item> <!-- Can be a darker/lighter shade of accent -->
        <item name="colorOnSecondary">@color/text_on_accent</item> <!-- Text/icon color on secondary color -->

        <!-- Status bar color. -->
        <!-- By default, uses colorPrimaryVariant. You can override it explicitly. -->
        <item name="android:statusBarColor" tools:targetApi="l">?attr/colorPrimaryVariant</item>

        <!-- Customize your theme here. -->
        <!-- For example, to remove the action bar if you're using a Toolbar in your layout: -->
        <!-- <item name="windowActionBar">false</item> -->
        <!-- <item name="windowNoTitle">true</item> -->

        <!-- You can also define other attributes like windowBackground, textColor, etc. -->
        <!-- <item name="android:windowBackground">@color/white</item> -->
    </style>

    <!-- Optional: A theme for a splash screen if you implement one -->
    <!--
    <style name="Theme.MyBasicApp.Splash" parent="Theme.SplashScreen">
        <item name="windowSplashScreenBackground">@color/my_app_primary</item>
        <item name="windowSplashScreenAnimatedIcon">@mipmap/ic_launcher_round</item> Comment out if no round launcher or use ic_launcher
        <item name="windowSplashScreenAnimationDuration">1000</item>
        <item name="postSplashScreenTheme">@style/Theme.MyBasicApp</item>
    </style>
    -->
</resources>

#################### START OF FILE: app\src\main\res\xml\backup_rules.xml ####################

<?xml version="1.0" encoding="utf-8"?>
<full-backup-content>
    <!-- TODO Remove the following backup rules src/main/AndroidManifext.xml#fullBackupContent-->
    <!-- <include domain="sharedpref" path="."/> -->
    <!-- <exclude domain="sharedpref" path="device.xml"/> -->
</full-backup-content>


#################### START OF FILE: app\src\main\res\xml\data_extraction_rules.xml ####################

<?xml version="1.0" encoding="utf-8"?>
<data-extraction-rules>
    <cloud-backup>
        <!-- TODO: Add cloud backup rules here. -->
        <!--
        <include domain="sharedpref" path="."/>
        <exclude domain="sharedpref" path="device.xml"/>
        -->
    </cloud-backup>
    <device-transfer>
        <!-- TODO: Add device transfer rules here. -->
        <!--
        <include domain="sharedpref" path="."/>
        <exclude domain="sharedpref" path="device.xml"/>
        -->
    </device-transfer>
</data-extraction-rules>


#################### START OF FILE: build.gradle ####################

// Top-level build file where you can add configuration options common to all sub-projects/modules.
plugins {
    // Define the Android Gradle Plugin version. 'apply false' means it's not applied to the root project,
    // but makes this version available to sub-projects like ':app'.
    // AGP 8.4.0 is a stable version compatible with Gradle 8.5.
    id("com.android.application") version "8.4.0" apply false

    // If you were using Kotlin (which this project is not, based on .java files and dependencies):
    // id("org.jetbrains.kotlin.android") version "1.9.23" apply false // Check for latest compatible Kotlin version
}

#################### START OF FILE: gradle\wrapper\gradle-wrapper.properties ####################

distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-8.6-bin.zip
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists

#################### START OF FILE: gradle.properties ####################

# Gradle JVM ARGS
# org.gradle.jvmargs=-Xmx2048m -Dfile.encoding=UTF-8 # Optional: Adjust memory if needed

# AndroidX Properties
android.useAndroidX=true
android.enableJetifier=true


#################### START OF FILE: settings.gradle ####################

pluginManagement {
    repositories {
        google()
        mavenCentral()
        gradlePluginPortal()
    }
}
dependencyResolutionManagement {
    repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)
    repositories {
        google()
        mavenCentral()
    }
}

rootProject.name = "MyBasicApp"
include ':app'
