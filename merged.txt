Total files found and listed: 33
List of all files found (paths relative to processing context):
- .github\workflows\android_ci.yml
- .gitignore
- app\build.gradle
- app\src\main\AndroidManifest.xml
- app\src\main\java\com\example\mybasicapp\AlertSoundService.java
- app\src\main\java\com\example\mybasicapp\DiscoveredService.java
- app\src\main\java\com\example\mybasicapp\DiscoveredServicesAdapter.java
- app\src\main\java\com\example\mybasicapp\HttpPollingService.java
- app\src\main\java\com\example\mybasicapp\MainActivity.java
- app\src\main\java\com\example\mybasicapp\NsdHelper.java
- app\src\main\res\drawable\ic_stat_message.xml
- app\src\main\res\drawable\ic_stat_service.xml
- app\src\main\res\layout\activity_main.xml
- app\src\main\res\layout\list_item_discovered_service.xml
- app\src\main\res\mipmap-hdpi\ic_launcher.png
- app\src\main\res\mipmap-hdpi\ic_launcher_round.png
- app\src\main\res\mipmap-mdpi\ic_launcher.png
- app\src\main\res\mipmap-mdpi\ic_launcher_round.png
- app\src\main\res\mipmap-xhdpi\ic_launcher.png
- app\src\main\res\mipmap-xhdpi\ic_launcher_round.png
- app\src\main\res\mipmap-xxhdpi\ic_launcher.png
- app\src\main\res\mipmap-xxhdpi\ic_launcher_round.png
- app\src\main\res\mipmap-xxxhdpi\ic_launcher.png
- app\src\main\res\mipmap-xxxhdpi\ic_launcher_round.png
- app\src\main\res\values\colors.xml
- app\src\main\res\values\strings.xml
- app\src\main\res\values\themes.xml
- app\src\main\res\xml\backup_rules.xml
- app\src\main\res\xml\data_extraction_rules.xml
- build.gradle
- gradle\wrapper\gradle-wrapper.properties
- gradle.properties
- settings.gradle

Content included for 22 file(s) with extensions: .java, .yml, .xml, .gradle, .properties

================================================================================


#################### START OF FILE: .github\workflows\android_ci.yml ####################

name: Android CI Build (Online Wrapper Init)

on:
  push:
    branches: [ "main", "master" ] # Or your default branch
  pull_request:
    branches: [ "main", "master" ]

jobs:
  build:
    env:
      # Define the Gradle version for the wrapper and build.
      # Choose a version compatible with your Android Gradle Plugin (AGP).
      # For AGP 8.4.0 (used in root build.gradle), Gradle 8.6 or higher is needed.
      # Check AGP release notes for compatibility.
      GRADLE_VERSION_TO_USE: '8.6' # Updated to Gradle 8.6

    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up JDK 17
      uses: actions/setup-java@v4
      with:
        java-version: '17' # Common for modern Android development
        distribution: 'temurin'

    # This step installs the specified version of Gradle and adds the 'gradle' command to the PATH.
    - name: Setup Gradle
      uses: gradle/actions/setup-gradle@v3 # Using setup-gradle v3
      with:
        gradle-version: ${{ env.GRADLE_VERSION_TO_USE }}
        # setup-gradle action has its own caching for Gradle User Home,
        # which can be beneficial. You can further configure it if needed.
        # See https://github.com/gradle/actions/blob/main/setup-gradle/README.md#caching

    # This step uses the 'gradle' command (from Setup Gradle step) to initialize
    # the Gradle wrapper files (gradlew, gradlew.bat, gradle-wrapper.jar, gradle-wrapper.properties)
    # in the runner's workspace. The generated gradle-wrapper.properties will point to GRADLE_VERSION_TO_USE.
    - name: Initialize Gradle Wrapper
      run: gradle wrapper --gradle-version ${{ env.GRADLE_VERSION_TO_USE }} --distribution-type bin
      # Adding --distribution-type bin to ensure it fetches the binary distribution

    - name: Grant execute permission for gradlew
      run: chmod +x ./gradlew

    # Recommended: Cache Gradle dependencies downloaded by the wrapper.
    # This cache uses the wrapper files generated in the previous step and other project build files.
    - name: Cache Gradle packages
      uses: actions/cache@v4
      with:
        path: |
          ~/.gradle/caches
          ~/.gradle/wrapper/dists
        # MODIFIED KEY: Added a version suffix '-v1' to help invalidate the cache if needed.
        # Increment this suffix (e.g., -v2, -v3) or use a dynamic value like ${{ github.run_id }}
        # if you suspect stale cache issues and need to force a fresh download.
        key: ${{ runner.os }}-gradle-${{ env.GRADLE_VERSION_TO_USE }}-${{ hashFiles('**/*.gradle*', '**/gradle-wrapper.properties', '**/libs.versions.toml') }}-v1
        restore-keys: |
          ${{ runner.os }}-gradle-${{ env.GRADLE_VERSION_TO_USE }}-

    - name: Build with Gradle Wrapper
      # Adding --stacktrace for more detailed error output if the build fails
      run: ./gradlew assembleDebug --stacktrace

    - name: Upload Debug APK
      uses: actions/upload-artifact@v4
      with:
        name: MrCoopersESP32 # Name of the artifact
        path: app/build/outputs/apk/debug/MrCoopersESP32.apk # Path to the APK
        if-no-files-found: error # Fail if APK not found

#################### START OF FILE: app\build.gradle ####################

plugins {
    id 'com.android.application'
    // id 'org.jetbrains.kotlin.android' // This project uses Java, so Kotlin plugin is not needed
}

android {
    namespace 'com.example.mybasicapp'
    compileSdk 34

    defaultConfig {
        applicationId "com.example.mybasicapp"
        minSdk 21
        targetSdk 34
        versionCode 1
        versionName "1.0"

        testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
    }

    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
        }
        debug {
            // APK naming is handled by the androidComponents block below
        }
    }

    compileOptions {
        // Align with the JDK version used in the CI workflow (JDK 17)
        sourceCompatibility JavaVersion.VERSION_17
        targetCompatibility JavaVersion.VERSION_17
    }
}

// This block customizes the output APK name for debug builds.
// It was previously (and incorrectly) in the root build.gradle.
androidComponents {
    onVariants(selector().withBuildType("debug")) { variant ->
        variant.outputs.forEach { output ->
            // Ensure we are modifying the main APK output
            // Correctly compare the outputType enum directly
            if (output.outputType == com.android.build.api.variant.VariantOutputConfiguration.OutputType.SINGLE) {
                output.outputFileName.set("MrCoopersESP32.apk")
            }
        }
    }
}

dependencies {
    // Use 'androidx.core:core' for Java projects. 'core-ktx' is for Kotlin.
    implementation 'androidx.core:core:1.12.0'
    implementation 'androidx.appcompat:appcompat:1.6.1'
    implementation 'com.google.android.material:material:1.11.0'
    implementation 'androidx.constraintlayout:constraintlayout:2.1.4'

    // Add OkHttp dependency, required for WebSocketService.java.
    // This was previously (and incorrectly) in the root build.gradle's dependencies.
    implementation("com.squareup.okhttp3:okhttp:4.12.0")

    testImplementation 'junit:junit:4.13.2'
    androidTestImplementation 'androidx.test.ext:junit:1.1.5'
    androidTestImplementation 'androidx.test.espresso:espresso-core:3.5.1'
}


#################### START OF FILE: app\src\main\AndroidManifest.xml ####################

<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools">

    <!-- Standard Network Permissions -->
    <uses-permission android:name="android.permission.INTERNET" />
    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />

    <!-- Permissions for mDNS (Network Service Discovery) -->
    <uses-permission android:name="android.permission.ACCESS_WIFI_STATE" />
    <uses-permission android:name="android.permission.CHANGE_WIFI_MULTICAST_STATE" />

    <!-- Permission for Notifications (Required for Android 13+) -->
    <uses-permission android:name="android.permission.POST_NOTIFICATIONS"/>

    <!-- Permissions for Foreground Service -->
    <uses-permission android:name="android.permission.FOREGROUND_SERVICE" />
    <!-- Allow specific types, HttpPollingService already uses dataSync -->
    <uses-permission android:name="android.permission.FOREGROUND_SERVICE_DATA_SYNC" />
    <!-- Add mediaPlayback for AlertSoundService -->
    <uses-permission android:name="android.permission.FOREGROUND_SERVICE_MEDIA_PLAYBACK" />


    <!-- Permissions for custom sound -->
    <uses-permission android:name="android.permission.WAKE_LOCK" />
    <!-- For Android 12 (API 32) and below to read audio files -->
    <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" android:maxSdkVersion="32" />
    <!-- For Android 13 (API 33) and above, for specific media types -->
    <uses-permission android:name="android.permission.READ_MEDIA_AUDIO" />


    <application
        android:allowBackup="true"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/Theme.MyBasicApp"
        tools:targetApi="34"
        android:usesCleartextTraffic="true">
        <!-- usesCleartextTraffic="true" is important for local http:// and ws:// connections -->

        <activity
            android:name=".MainActivity"
            android:exported="true"
            android:launchMode="singleTop"> <!-- singleTop is good if opening from notification -->
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>

        <service
            android:name=".HttpPollingService"
            android:enabled="true"
            android:exported="false"
            android:foregroundServiceType="dataSync" />
            <!-- foregroundServiceType is required for services targeting Android Q (API 29) and above -->

        <service
            android:name=".AlertSoundService"
            android:enabled="true"
            android:exported="false"
            android:foregroundServiceType="mediaPlayback" />

    </application>

</manifest>

#################### START OF FILE: app\src\main\java\com\example\mybasicapp\AlertSoundService.java ####################

package com.example.mybasicapp;

import android.app.Notification;
import android.app.NotificationChannel;
import android.app.NotificationManager;
import android.app.PendingIntent;
import android.app.Service;
import android.content.Context;
import android.content.Intent;
import android.content.pm.ServiceInfo;
import android.media.AudioAttributes;
import android.media.MediaPlayer;
import android.net.Uri;
import android.os.Build;
import android.os.IBinder;
import android.os.PowerManager;
import android.util.Log;

import androidx.annotation.Nullable;
import androidx.core.app.NotificationCompat;

import java.io.IOException;

public class AlertSoundService extends Service {

    private static final String TAG = "AlertSoundService_DBG";
    public static final String CUSTOM_ALERT_SOUND_CHANNEL_ID = "custom_alert_sound_service_channel";
    private static final int CUSTOM_ALERT_NOTIFICATION_ID = 3; // Unique ID

    public static final String ACTION_PLAY_CUSTOM_SOUND = "com.example.mybasicapp.ACTION_PLAY_CUSTOM_SOUND";
    public static final String EXTRA_SOUND_URI = "EXTRA_SOUND_URI";

    private MediaPlayer mediaPlayer;
    private PowerManager.WakeLock wakeLock;

    @Override
    public void onCreate() {
        super.onCreate();
        Log.d(TAG, "onCreate: AlertSoundService creating.");
        PowerManager powerManager = (PowerManager) getSystemService(Context.POWER_SERVICE);
        if (powerManager != null) {
            wakeLock = powerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "MrCoopersESP::AlertSoundWakeLock");
            wakeLock.setReferenceCounted(false);
        }
        createNotificationChannel(); // Create channel early
        Log.d(TAG, "onCreate: AlertSoundService created.");
    }

    @Override
    public int onStartCommand(Intent intent, int flags, int startId) {
        if (intent == null || intent.getAction() == null) {
            Log.w(TAG, "onStartCommand: Null intent or action. Stopping service.");
            stopSelf();
            return START_NOT_STICKY;
        }

        String action = intent.getAction();
        Log.i(TAG, "onStartCommand: Action='" + action + "'");

        if (ACTION_PLAY_CUSTOM_SOUND.equals(action)) {
            String soundUriString = intent.getStringExtra(EXTRA_SOUND_URI);
            if (soundUriString != null) {
                Uri soundUri = Uri.parse(soundUriString);
                startForegroundWithNotification();
                playSoundInBackground(soundUri);
            } else {
                Log.e(TAG, "ACTION_PLAY_CUSTOM_SOUND: Sound URI is missing! Stopping service.");
                stopSelf();
            }
        } else {
            Log.w(TAG, "onStartCommand: Unhandled action: " + action + ". Stopping service.");
            stopSelf();
        }
        return START_NOT_STICKY;
    }

    private void createNotificationChannel() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            NotificationChannel channel = new NotificationChannel(
                    CUSTOM_ALERT_SOUND_CHANNEL_ID,
                    getString(R.string.alert_sound_service_channel_name),
                    NotificationManager.IMPORTANCE_LOW // Low importance for background service notification
            );
            channel.setDescription(getString(R.string.alert_sound_service_channel_description));
            NotificationManager manager = getSystemService(NotificationManager.class);
            if (manager != null) {
                manager.createNotificationChannel(channel);
                Log.d(TAG, "Notification channel created: " + CUSTOM_ALERT_SOUND_CHANNEL_ID);
            }
        }
    }

    private void startForegroundWithNotification() {
        Log.d(TAG, "startForegroundWithNotification called");
        Intent notificationIntent = new Intent(this, MainActivity.class);
        PendingIntent pendingIntent = PendingIntent.getActivity(this, 0,
                notificationIntent, PendingIntent.FLAG_IMMUTABLE | PendingIntent.FLAG_UPDATE_CURRENT);

        Notification notification = new NotificationCompat.Builder(this, CUSTOM_ALERT_SOUND_CHANNEL_ID)
                .setContentTitle(getString(R.string.alert_sound_notification_title))
                .setContentText(getString(R.string.alert_sound_notification_text))
                .setSmallIcon(R.drawable.ic_stat_message) // Use an appropriate icon
                .setContentIntent(pendingIntent)
                .setOngoing(true)
                .setPriority(NotificationCompat.PRIORITY_LOW)
                .build();
        try {
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
                 startForeground(CUSTOM_ALERT_NOTIFICATION_ID, notification, ServiceInfo.FOREGROUND_SERVICE_TYPE_MEDIA_PLAYBACK);
            } else {
                startForeground(CUSTOM_ALERT_NOTIFICATION_ID, notification);
            }
            Log.i(TAG, "Service started in foreground for custom sound.");
        } catch (Exception e) {
            Log.e(TAG, "Error starting foreground service for custom sound: " + e.getMessage(), e);
        }
    }

    private void playSoundInBackground(Uri soundUri) {
        Log.d(TAG, "playSoundInBackground: URI=" + soundUri);
        if (mediaPlayer != null) {
            mediaPlayer.release();
        }
        mediaPlayer = new MediaPlayer();
        mediaPlayer.setAudioAttributes(
                new AudioAttributes.Builder()
                        .setContentType(AudioAttributes.CONTENT_TYPE_MUSIC)
                        .setUsage(AudioAttributes.USAGE_ALARM) // Important for alerts
                        .build());

        if (wakeLock != null && !wakeLock.isHeld()) {
            wakeLock.acquire(10 * 60 * 1000L /* 10 minutes timeout */);
            Log.d(TAG, "WakeLock acquired.");
        }

        try {
            // Grant temporary permission to the media player if needed, by setting the URI on the intent to the service.
            // MainActivity should have added Intent.FLAG_GRANT_READ_URI_PERMISSION
            // Or, the URI must be persistable and permission already taken by MainActivity.
            mediaPlayer.setDataSource(getApplicationContext(), soundUri);
            mediaPlayer.prepareAsync();
            mediaPlayer.setOnPreparedListener(mp -> {
                Log.i(TAG, "MediaPlayer prepared, starting custom sound playback.");
                mp.start();
            });
            mediaPlayer.setOnCompletionListener(mp -> {
                Log.i(TAG, "Custom sound playback completed.");
                cleanupAndStopService();
            });
            mediaPlayer.setOnErrorListener((mp, what, extra) -> {
                Log.e(TAG, "MediaPlayer error during custom sound: what=" + what + ", extra=" + extra);
                cleanupAndStopService();
                return true; // Error handled
            });
        } catch (IOException e) {
            Log.e(TAG, "IOException for custom sound: " + e.getMessage(), e);
            cleanupAndStopService();
        } catch (SecurityException se) {
            Log.e(TAG, "SecurityException for custom sound (URI permission issue?): " + se.getMessage(), se);
            cleanupAndStopService();
        }
    }

    private void cleanupAndStopService() {
        Log.d(TAG, "cleanupAndStopService called");
        if (mediaPlayer != null) {
            if (mediaPlayer.isPlaying()) {
                mediaPlayer.stop();
            }
            mediaPlayer.release();
            mediaPlayer = null;
            Log.d(TAG, "MediaPlayer released.");
        }
        if (wakeLock != null && wakeLock.isHeld()) {
            wakeLock.release();
            Log.d(TAG, "WakeLock released.");
        }
        stopForeground(true); // Remove notification
        stopSelf(); // Stop the service
        Log.i(TAG, "AlertSoundService stopped.");
    }

    @Nullable
    @Override
    public IBinder onBind(Intent intent) {
        return null; // Not a bound service
    }

    @Override
    public void onDestroy() {
        super.onDestroy();
        Log.d(TAG, "onDestroy: AlertSoundService destroyed.");
        cleanupAndStopService(); // Ensure all resources are released
    }
}

#################### START OF FILE: app\src\main\java\com\example\mybasicapp\DiscoveredService.java ####################

package com.example.mybasicapp;

import android.net.nsd.NsdServiceInfo;

public class DiscoveredService {
    private String serviceName;
    private String hostAddress;
    private int port;
    private String type; // e.g., _myespwebsocket._tcp

    public DiscoveredService(NsdServiceInfo nsdServiceInfo) {
        this.serviceName = nsdServiceInfo.getServiceName();
        this.hostAddress = nsdServiceInfo.getHost() != null ? nsdServiceInfo.getHost().getHostAddress() : null;
        this.port = nsdServiceInfo.getPort();
        this.type = nsdServiceInfo.getServiceType();
    }

    // Minimal constructor for manual entries or future use
    public DiscoveredService(String serviceName, String hostAddress, int port, String type) {
        this.serviceName = serviceName;
        this.hostAddress = hostAddress;
        this.port = port;
        this.type = type;
    }


    public String getServiceName() {
        return serviceName;
    }

    public String getHostAddress() {
        return hostAddress;
    }

    public int getPort() {
        return port;
    }

    public String getType() { return type; }

    public boolean isValid() {
        return hostAddress != null && !hostAddress.isEmpty() && port > 0;
    }

    @Override
    public String toString() {
        return serviceName + " (" + (hostAddress != null ? hostAddress : "Resolving...") + ":" + port + ")";
    }

    // Implement equals and hashCode to avoid duplicates in a list if necessary
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        DiscoveredService that = (DiscoveredService) o;
        return port == that.port &&
                java.util.Objects.equals(serviceName, that.serviceName) &&
                java.util.Objects.equals(hostAddress, that.hostAddress) &&
                java.util.Objects.equals(type, that.type);
    }

    @Override
    public int hashCode() {
        return java.util.Objects.hash(serviceName, hostAddress, port, type);
    }
}

#################### START OF FILE: app\src\main\java\com\example\mybasicapp\DiscoveredServicesAdapter.java ####################

package com.example.mybasicapp;

import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.TextView;
import androidx.annotation.NonNull;
import androidx.recyclerview.widget.RecyclerView;
import java.util.ArrayList;
import java.util.List;

public class DiscoveredServicesAdapter extends RecyclerView.Adapter<DiscoveredServicesAdapter.ViewHolder> {

    private List<DiscoveredService> discoveredServices = new ArrayList<>();
    private OnServiceClickListener listener;

    public interface OnServiceClickListener {
        void onServiceClick(DiscoveredService service);
    }

    public DiscoveredServicesAdapter(OnServiceClickListener listener) {
        this.listener = listener;
    }

    public void setServices(List<DiscoveredService> services) {
        this.discoveredServices.clear();
        if (services != null) {
            this.discoveredServices.addAll(services);
        }
        notifyDataSetChanged(); // Use DiffUtil for better performance in complex apps
    }

    public void addService(DiscoveredService service) {
        if (!discoveredServices.contains(service)) { // Avoid duplicates
            discoveredServices.add(service);
            notifyItemInserted(discoveredServices.size() - 1);
        } else { // If it exists, maybe update it (e.g. IP resolved)
           int index = discoveredServices.indexOf(service);
           if (index != -1) {
               discoveredServices.set(index, service);
               notifyItemChanged(index);
           }
        }
    }

    public void clearServices() {
        discoveredServices.clear();
        notifyDataSetChanged();
    }


    @NonNull
    @Override
    public ViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {
        View view = LayoutInflater.from(parent.getContext())
                .inflate(R.layout.list_item_discovered_service, parent, false);
        return new ViewHolder(view);
    }

    @Override
    public void onBindViewHolder(@NonNull ViewHolder holder, int position) {
        DiscoveredService service = discoveredServices.get(position);
        holder.bind(service, listener);
    }

    @Override
    public int getItemCount() {
        return discoveredServices.size();
    }

    static class ViewHolder extends RecyclerView.ViewHolder {
        TextView textViewServiceName;
        TextView textViewServiceAddress;

        ViewHolder(View itemView) {
            super(itemView);
            textViewServiceName = itemView.findViewById(R.id.textViewServiceName);
            textViewServiceAddress = itemView.findViewById(R.id.textViewServiceAddress);
        }

        void bind(final DiscoveredService service, final OnServiceClickListener listener) {
            textViewServiceName.setText(service.getServiceName());
            if (service.isValid()) {
                textViewServiceAddress.setText(service.getHostAddress() + ":" + service.getPort());
            } else {
                textViewServiceAddress.setText("Resolving or invalid...");
            }
            itemView.setOnClickListener(v -> listener.onServiceClick(service));
        }
    }
}

#################### START OF FILE: app\src\main\java\com\example\mybasicapp\HttpPollingService.java ####################

package com.example.mybasicapp;

import android.app.Notification;
import android.app.NotificationChannel;
import android.app.NotificationManager;
import android.app.PendingIntent;
import android.app.Service;
import android.content.Context;
import android.content.Intent;
import android.content.SharedPreferences;
import android.content.pm.PackageManager;
import android.content.pm.ServiceInfo;
import android.net.Uri; // Added
import android.os.Build;
import android.os.Handler;
import android.os.IBinder;
import android.os.Looper;
import android.provider.OpenableColumns; // Added
import android.util.Log;
import android.database.Cursor; // Added

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.core.app.ActivityCompat;
import androidx.core.app.NotificationCompat;
import androidx.core.content.ContextCompat; // Added
import androidx.localbroadcastmanager.content.LocalBroadcastManager;


import org.json.JSONException;
import org.json.JSONObject;

import java.io.File; // Added
import java.io.FileOutputStream; // Added
import java.io.IOException;
import java.io.OutputStreamWriter; // Added
import java.text.SimpleDateFormat; // Added
import java.util.Date; // Added
import java.util.Locale;
// import java.util.Objects; // Not strictly needed here anymore
import java.util.concurrent.TimeUnit;

import okhttp3.Call;
import okhttp3.Callback;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.Response;

public class HttpPollingService extends Service {

    private static final String TAG = "HttpPollingService_DBG";
    public static final String ACTION_START_FOREGROUND_SERVICE = "com.example.mybasicapp.ACTION_START_HTTP_FG_SERVICE";
    public static final String ACTION_STOP_FOREGROUND_SERVICE = "com.example.mybasicapp.ACTION_STOP_HTTP_FG_SERVICE";
    public static final String ACTION_START_POLLING = "com.example.mybasicapp.ACTION_START_POLLING";
    public static final String ACTION_STOP_POLLING = "com.example.mybasicapp.ACTION_STOP_POLLING";
    public static final String EXTRA_BASE_URL = "EXTRA_BASE_URL";

    public static final String ACTION_STATUS_UPDATE = "com.example.mybasicapp.ACTION_HTTP_STATUS_UPDATE";
    public static final String EXTRA_STATUS = "EXTRA_STATUS";
    public static final String ACTION_DATA_RECEIVED = "com.example.mybasicapp.ACTION_HTTP_DATA_RECEIVED";
    public static final String EXTRA_DATA_TYPE = "EXTRA_DATA_TYPE";
    public static final String EXTRA_DATA_JSON_STRING = "EXTRA_DATA_JSON_STRING";

    private static final String NOTIFICATION_CHANNEL_ID_SERVICE = "http_polling_service_status_channel";
    private static final String NOTIFICATION_CHANNEL_ID_MESSAGES = "esp32_http_notifications";
    private static final int SERVICE_NOTIFICATION_ID = 2;
    private static final int MESSAGE_NOTIFICATION_ID = 102; // Unique ID for distance alerts

    private OkHttpClient httpClient;
    private Handler pollingHandler = new Handler(Looper.getMainLooper());
    private boolean isServiceRunningAsForeground = false;
    private boolean isCurrentlyPolling = false;
    private String currentBaseUrl;

    private static final long POLLING_INTERVAL_MS = 3000;
    private static final String DISTANCE_ENDPOINT = "/get_distance";

    // SharedPreferences keys (must match MainActivity)
    private static final String PREFS_NAME = "MrCooperESP_Prefs";
    private static final String PREF_TRIGGER_DISTANCE = "trigger_distance_cm";
    private static final String PREF_NOTIFICATIONS_ENABLED = "notifications_enabled";
    // New keys for custom sound
    private static final String PREF_CUSTOM_ALERT_SOUND_URI = "custom_alert_sound_uri";
    private static final String PREF_CUSTOM_ALERT_SOUND_ENABLED = "custom_alert_sound_enabled";

    private static final int DEFAULT_TRIGGER_DISTANCE = 50; // cm
    private static final boolean DEFAULT_NOTIFICATIONS_ENABLED = false;
    private static final boolean DEFAULT_CUSTOM_SOUND_ENABLED = true; // Default to true if a sound is selected
    private SharedPreferences sharedPreferences;

    // For logging sensor triggers
    private static final String SENSOR_TRIGGER_LOG_FILE_NAME_KEY = "log_sensor_trigger_file_name";


    @Override
    public void onCreate() {
        super.onCreate();
        Log.i(TAG, "onCreate: Service Creating");
        httpClient = new OkHttpClient.Builder()
                .connectTimeout(10, TimeUnit.SECONDS)
                .readTimeout(15, TimeUnit.SECONDS)
                .writeTimeout(10, TimeUnit.SECONDS)
                .build();
        createNotificationChannel(NOTIFICATION_CHANNEL_ID_SERVICE, "ESP32 HTTP Polling Service", NotificationManager.IMPORTANCE_LOW);
        createNotificationChannel(NOTIFICATION_CHANNEL_ID_MESSAGES, getString(R.string.channel_name_http), NotificationManager.IMPORTANCE_HIGH);

        sharedPreferences = getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE);
        Log.d(TAG, "onCreate: Service Created");
    }

    @Override
    public int onStartCommand(Intent intent, int flags, int startId) {
        if (intent == null || intent.getAction() == null) {
            Log.w(TAG, "onStartCommand: Null intent or action. Flags=" + flags + ", StartId=" + startId);
            if (!isServiceRunningAsForeground) {
                startForegroundServiceWithNotification("Service Initializing (Restart)...");
            }
            return START_STICKY;
        }

        String action = intent.getAction();
        Log.i(TAG, "onStartCommand: Action='" + action + "', Flags=" + flags + ", StartId=" + startId);

        switch (action) {
            case ACTION_START_FOREGROUND_SERVICE:
                Log.d(TAG, "onStartCommand: Handling ACTION_START_FOREGROUND_SERVICE. isServiceRunningAsForeground=" + isServiceRunningAsForeground);
                currentBaseUrl = intent.getStringExtra(EXTRA_BASE_URL);
                if (currentBaseUrl == null || currentBaseUrl.isEmpty()){
                    Log.e(TAG, "ACTION_START_FOREGROUND_SERVICE: Base URL is missing!");
                    sendBroadcastStatus("Error: Base URL missing for service start");
                    stopSelf();
                    return START_NOT_STICKY;
                }
                if (!isServiceRunningAsForeground) {
                    startForegroundServiceWithNotification("Service Active. Polling ESP32 at " + getHostFromUrl(currentBaseUrl));
                }
                if (!isCurrentlyPolling) {
                     startPollingData();
                }
                break;
            case ACTION_STOP_FOREGROUND_SERVICE:
                Log.d(TAG, "onStartCommand: Handling ACTION_STOP_FOREGROUND_SERVICE.");
                stopPollingData();
                stopServiceAndForeground();
                return START_NOT_STICKY;
            case ACTION_START_POLLING:
                Log.d(TAG, "onStartCommand: Handling ACTION_START_POLLING.");
                currentBaseUrl = intent.getStringExtra(EXTRA_BASE_URL);
                if (currentBaseUrl == null || currentBaseUrl.isEmpty()){
                     Log.e(TAG, "ACTION_START_POLLING: Base URL is missing!");
                     sendBroadcastStatus("Error: Base URL missing for polling");
                     break;
                }
                if (!isServiceRunningAsForeground) {
                     startForegroundServiceWithNotification("Polling ESP32 at " + getHostFromUrl(currentBaseUrl));
                }
                startPollingData();
                break;
            case ACTION_STOP_POLLING:
                Log.d(TAG, "onStartCommand: Handling ACTION_STOP_POLLING.");
                stopPollingData();
                updateServiceNotification("Polling Paused. Service still active.");
                break;
            default:
                Log.w(TAG, "onStartCommand: Unhandled action: " + action);
                break;
        }
        return START_STICKY;
    }

    private String getHostFromUrl(String urlString) {
        if (urlString == null) return "Unknown Host";
        try {
            java.net.URL url = new java.net.URL(urlString);
            return url.getHost() + (url.getPort() != -1 && url.getPort() != 80 && url.getPort() != url.getDefaultPort() ? ":" + url.getPort() : "");
        } catch (java.net.MalformedURLException e) {
            return urlString;
        }
    }


    private void startPollingData() {
        if (currentBaseUrl == null || currentBaseUrl.isEmpty()) {
            Log.e(TAG, "startPollingData: Cannot start, base URL is not set.");
            sendBroadcastStatus("Error: Base URL not set for polling.");
            return;
        }
        if (!isCurrentlyPolling) {
            isCurrentlyPolling = true;
            pollingHandler.post(pollingRunnable);
            Log.i(TAG, "startPollingData: Polling started for " + currentBaseUrl);
            sendBroadcastStatus("Polling started for " + getHostFromUrl(currentBaseUrl));
            updateServiceNotification("Polling active: " + getHostFromUrl(currentBaseUrl));
        } else {
            Log.d(TAG, "startPollingData: Polling already active.");
        }
    }

    private void stopPollingData() {
        if (isCurrentlyPolling) {
            isCurrentlyPolling = false;
            pollingHandler.removeCallbacks(pollingRunnable);
            Log.i(TAG, "stopPollingData: Polling stopped.");
            sendBroadcastStatus("Polling stopped.");
        }
    }

    private final Runnable pollingRunnable = new Runnable() {
        @Override
        public void run() {
            if (isCurrentlyPolling && currentBaseUrl != null && !currentBaseUrl.isEmpty()) {
                fetchDataFromServer(DISTANCE_ENDPOINT, "distance");
                pollingHandler.postDelayed(this, POLLING_INTERVAL_MS);
            }
        }
    };

    private void fetchDataFromServer(String endpoint, final String dataType) {
        if (currentBaseUrl == null) {
            Log.e(TAG, "fetchDataFromServer: currentBaseUrl is null. Cannot fetch.");
            return;
        }
        String url = currentBaseUrl + endpoint;
        Log.d(TAG, "HTTP Polling: GET " + url);

        Request request = new Request.Builder().url(url).build();

        httpClient.newCall(request).enqueue(new Callback() {
            @Override
            public void onFailure(@NonNull Call call, @NonNull IOException e) {
                Log.e(TAG, "HTTP poll " + endpoint + " onFailure: " + e.getMessage());
                sendBroadcastStatus("Error polling " + dataType + ": " + e.getMessage());
            }

            @Override
            public void onResponse(@NonNull Call call, @NonNull Response response) throws IOException {
                final String responseBodyString = response.body() != null ? response.body().string() : null;
                final int responseCode = response.code();
                response.close();

                if (response.isSuccessful() && responseBodyString != null) {
                    Log.d(TAG, "HTTP poll " + endpoint + " onResponse (" + responseCode + "): " + responseBodyString.substring(0, Math.min(responseBodyString.length(), 100)));
                    sendBroadcastData(dataType, responseBodyString);

                    if ("distance".equals(dataType)) {
                        try {
                            JSONObject json = new JSONObject(responseBodyString);
                            double distanceValCm = json.optDouble("distance_cm", -3.0);

                            boolean notificationsEnabled = sharedPreferences.getBoolean(PREF_NOTIFICATIONS_ENABLED, DEFAULT_NOTIFICATIONS_ENABLED);
                            int triggerDistanceCm = sharedPreferences.getInt(PREF_TRIGGER_DISTANCE, DEFAULT_TRIGGER_DISTANCE);
                            boolean customSoundEnabled = sharedPreferences.getBoolean(PREF_CUSTOM_ALERT_SOUND_ENABLED, DEFAULT_CUSTOM_SOUND_ENABLED);
                            String customSoundUriString = sharedPreferences.getString(PREF_CUSTOM_ALERT_SOUND_URI, null);

                            Log.d(TAG, "Notification check: NotificationsEnabled=" + notificationsEnabled +
                                       ", TriggerDist=" + triggerDistanceCm + "cm" +
                                       ", CurrentDist=" + distanceValCm + "cm" +
                                       ", CustomSoundEnabled=" + customSoundEnabled +
                                       ", CustomSoundURI=" + (customSoundUriString != null));

                            if (notificationsEnabled && distanceValCm >= 0 && distanceValCm <= triggerDistanceCm) {
                                String notificationMsg = String.format(Locale.getDefault(),
                                        "Object detected at %.1f cm (Trigger: <= %d cm)",
                                        distanceValCm, triggerDistanceCm);
                                showDataNotification("Motion Alert", notificationMsg); // Visual notification

                                String customSoundFileName = "None";
                                if (customSoundUriString != null) {
                                    customSoundFileName = getFileNameFromContentUri(Uri.parse(customSoundUriString));
                                }

                                // Log the sensor trigger event
                                logSensorTriggerToFile(String.format(Locale.getDefault(),
                                        "Sensor triggered. Distance: %.1f cm (Threshold: <= %d cm). Visual notification shown. Custom sound: %s (Enabled: %b, URI Set: %b)",
                                        distanceValCm, triggerDistanceCm, customSoundFileName, customSoundEnabled, (customSoundUriString != null)));

                                // Play custom sound if enabled and URI is set
                                if (customSoundEnabled && customSoundUriString != null) {
                                    Uri soundUri = Uri.parse(customSoundUriString);
                                    Intent alertSoundIntent = new Intent(HttpPollingService.this, AlertSoundService.class);
                                    alertSoundIntent.setAction(AlertSoundService.ACTION_PLAY_CUSTOM_SOUND);
                                    alertSoundIntent.putExtra(AlertSoundService.EXTRA_SOUND_URI, soundUri.toString());
                                    // Grant read permission to the AlertSoundService for this URI
                                    alertSoundIntent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);
                                    ContextCompat.startForegroundService(HttpPollingService.this, alertSoundIntent);
                                    Log.i(TAG, "Custom alert sound service started for: " + customSoundFileName);
                                }
                            }

                        } catch (JSONException e_json) {
                             Log.e(TAG, "Error parsing " + dataType + " JSON for notification: " + e_json.getMessage());
                        }
                    }

                } else {
                    Log.e(TAG, "HTTP poll " + endpoint + " onResponse Error: " + responseCode + " - " + response.message());
                    sendBroadcastStatus("Error polling " + dataType + ": " + responseCode);
                }
            }
        });
    }

    private String getFileNameFromContentUri(Uri uri) {
        String result = null;
        if (uri == null) return "Unknown URI";
        if ("content".equals(uri.getScheme())) {
            try (Cursor cursor = getContentResolver().query(uri, null, null, null, null)) {
                if (cursor != null && cursor.moveToFirst()) {
                    int displayNameIndex = cursor.getColumnIndex(OpenableColumns.DISPLAY_NAME);
                    if (displayNameIndex != -1) {
                        result = cursor.getString(displayNameIndex);
                    }
                }
            } catch (Exception e) {
                Log.e(TAG, "Error getting file name from content URI: " + uri, e);
            }
        }
        if (result == null) {
            result = uri.getPath();
            if (result != null) {
                int cut = result.lastIndexOf('/');
                if (cut != -1) {
                    result = result.substring(cut + 1);
                }
            } else {
                result = uri.toString();
            }
        }
        return result;
    }

    private void logSensorTriggerToFile(String message) {
        File logFile = new File(getFilesDir(), getString(R.string.log_sensor_trigger_file_name));
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.SSS", Locale.getDefault());
        String timestamp = sdf.format(new Date());
        String logEntry = "[" + timestamp + "] " + message + "\n";

        FileOutputStream fos = null;
        OutputStreamWriter osw = null;
        try {
            fos = new FileOutputStream(logFile, true); // true for append mode
            osw = new OutputStreamWriter(fos);
            osw.write(logEntry);
            Log.i(TAG, "Logged to sensor trigger file: " + message);
        } catch (IOException e) {
            Log.e(TAG, "Error writing to sensor trigger log file: " + logFile.getAbsolutePath(), e);
        } finally {
            try {
                if (osw != null) osw.close();
                else if (fos != null) fos.close();
            } catch (IOException e) {
                Log.e(TAG, "Error closing sensor trigger log file streams", e);
            }
        }
    }


    private void startForegroundServiceWithNotification(String statusText) {
        Log.d(TAG, "startForegroundServiceWithNotification: statusText='" + statusText + "'");
        Intent notificationIntent = new Intent(this, MainActivity.class);
        PendingIntent pendingIntent = PendingIntent.getActivity(this, 0,
                notificationIntent, PendingIntent.FLAG_IMMUTABLE | PendingIntent.FLAG_UPDATE_CURRENT);

        Notification notification = new NotificationCompat.Builder(this, NOTIFICATION_CHANNEL_ID_SERVICE)
                .setContentTitle(getString(R.string.app_name) + " HTTP Sync")
                .setContentText(statusText)
                .setSmallIcon(R.drawable.ic_stat_service)
                .setContentIntent(pendingIntent)
                .setOngoing(true)
                .setPriority(NotificationCompat.PRIORITY_LOW)
                .setCategory(NotificationCompat.CATEGORY_SERVICE)
                .build();
        try {
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
                startForeground(SERVICE_NOTIFICATION_ID, notification, ServiceInfo.FOREGROUND_SERVICE_TYPE_DATA_SYNC);
            } else {
                startForeground(SERVICE_NOTIFICATION_ID, notification);
            }
            isServiceRunningAsForeground = true;
            Log.i(TAG, "startForegroundServiceWithNotification: Service started in foreground. Notification: '" + statusText + "'");
        } catch (Exception e) {
            Log.e(TAG, "startForegroundServiceWithNotification: Error: " + e.getClass().getSimpleName() + " - " + e.getMessage(), e);
            isServiceRunningAsForeground = false;
        }
    }

    private void updateServiceNotification(String text) {
        Log.d(TAG, "updateServiceNotification: text='" + text + "'. isServiceRunningAsForeground=" + isServiceRunningAsForeground);
        if (!isServiceRunningAsForeground) {
            return;
        }
        NotificationManager manager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);
        if (manager == null) {
             Log.e(TAG, "updateServiceNotification: NotificationManager is null.");
            return;
        }
        Intent notificationIntent = new Intent(this, MainActivity.class);
        PendingIntent pendingIntent = PendingIntent.getActivity(this, 0,
                notificationIntent, PendingIntent.FLAG_IMMUTABLE | PendingIntent.FLAG_UPDATE_CURRENT);
        Notification notification = new NotificationCompat.Builder(this, NOTIFICATION_CHANNEL_ID_SERVICE)
                .setContentTitle(getString(R.string.app_name) + " HTTP Sync")
                .setContentText(text)
                .setSmallIcon(R.drawable.ic_stat_service)
                .setContentIntent(pendingIntent)
                .setOngoing(true)
                .setPriority(NotificationCompat.PRIORITY_LOW)
                .setCategory(NotificationCompat.CATEGORY_SERVICE)
                .build();
        try {
            manager.notify(SERVICE_NOTIFICATION_ID, notification);
        } catch (Exception e) {
            Log.e(TAG, "updateServiceNotification: Error: " + e.getMessage(), e);
        }
    }

    private void stopServiceAndForeground() {
        Log.i(TAG, "stopServiceAndForeground: Initiated.");
        stopPollingData();
        if (isServiceRunningAsForeground) {
            Log.d(TAG, "stopServiceAndForeground: Stopping foreground state now.");
            stopForeground(true);
            isServiceRunningAsForeground = false;
        }
        stopSelf();
        Log.i(TAG, "stopServiceAndForeground: Service instance stopped.");
    }

    private void sendBroadcastStatus(String status) {
        Intent intent = new Intent(ACTION_STATUS_UPDATE);
        intent.putExtra(EXTRA_STATUS, status);
        LocalBroadcastManager.getInstance(this).sendBroadcast(intent);
        Log.v(TAG, "sendBroadcastStatus >> UI: " + status);
    }

    private void sendBroadcastData(String dataType, String jsonString) {
        Intent intent = new Intent(ACTION_DATA_RECEIVED);
        intent.putExtra(EXTRA_DATA_TYPE, dataType);
        intent.putExtra(EXTRA_DATA_JSON_STRING, jsonString);
        LocalBroadcastManager.getInstance(this).sendBroadcast(intent);
        Log.v(TAG, "sendBroadcastData (" + dataType + ") >> UI: " + jsonString.substring(0, Math.min(jsonString.length(),100)));
    }

    private void createNotificationChannel(String channelId, String channelName, int importance) {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            NotificationChannel channel = new NotificationChannel(channelId, channelName, importance);
            if (NOTIFICATION_CHANNEL_ID_MESSAGES.equals(channelId)) {
                channel.setDescription(getString(R.string.channel_description_http));
                channel.enableLights(true);
                channel.enableVibration(true);
            } else if (NOTIFICATION_CHANNEL_ID_SERVICE.equals(channelId)) {
                 channel.setDescription("Channel for ESP32 HTTP Polling Service status.");
            }
            // AlertSoundService creates its own channel
            NotificationManager notificationManager = getSystemService(NotificationManager.class);
            if (notificationManager != null) {
                notificationManager.createNotificationChannel(channel);
                Log.d(TAG, "createNotificationChannel: Channel '" + channelId + "' created/updated.");
            } else {
                Log.e(TAG, "createNotificationChannel: NotificationManager is null for channel '" + channelId + "'");
            }
        }
    }

    private void showDataNotification(String title, String message) {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
            if (ActivityCompat.checkSelfPermission(this, android.Manifest.permission.POST_NOTIFICATIONS) != PackageManager.PERMISSION_GRANTED) {
                Log.w(TAG, "showDataNotification: POST_NOTIFICATIONS permission NOT granted. Cannot show.");
                return;
            }
        }
        Intent intent = new Intent(this, MainActivity.class);
        intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP | Intent.FLAG_ACTIVITY_SINGLE_TOP);
        PendingIntent pendingIntent = PendingIntent.getActivity(this, MESSAGE_NOTIFICATION_ID, intent, PendingIntent.FLAG_UPDATE_CURRENT | PendingIntent.FLAG_IMMUTABLE);

        NotificationCompat.Builder builder = new NotificationCompat.Builder(this, NOTIFICATION_CHANNEL_ID_MESSAGES)
            .setSmallIcon(R.drawable.ic_stat_message)
            .setContentTitle(title).setContentText(message)
            .setPriority(NotificationCompat.PRIORITY_HIGH).setAutoCancel(true)
            .setContentIntent(pendingIntent)
            .setDefaults(Notification.DEFAULT_ALL); 
        
        NotificationManagerCompat.from(this).notify(MESSAGE_NOTIFICATION_ID, builder.build());
        Log.d(TAG, "showDataNotification: Sent. Title='" + title + "'");
    }

    @Nullable
    @Override
    public IBinder onBind(Intent intent) {
        Log.d(TAG, "onBind: Called, returning null.");
        return null;
    }

    @Override
    public void onDestroy() {
        Log.i(TAG, "onDestroy: Service Destroying.");
        stopPollingData();
        if (isServiceRunningAsForeground) {
            stopForeground(true);
            isServiceRunningAsForeground = false;
        }
        if (httpClient != null) {
            Log.d(TAG, "onDestroy: Shutting down OkHttpClient dispatcher and connection pool.");
            httpClient.dispatcher().executorService().shutdown();
            httpClient.connectionPool().evictAll();
            try {
                if (httpClient.cache() != null) {
                    httpClient.cache().close();
                }
            } catch (IOException e) {
                Log.e(TAG, "Error closing OkHttp cache", e);
            }
        }
        Log.i(TAG, "onDestroy: Service fully destroyed.");
        super.onDestroy();
    }
}

#################### START OF FILE: app\src\main\java\com\example\mybasicapp\MainActivity.java ####################

package com.example.mybasicapp;

import androidx.activity.result.ActivityResultLauncher;
import androidx.activity.result.contract.ActivityResultContracts;
import androidx.appcompat.app.AppCompatActivity;
import androidx.core.content.ContextCompat;
import androidx.localbroadcastmanager.content.LocalBroadcastManager;
import androidx.recyclerview.widget.LinearLayoutManager;
import androidx.recyclerview.widget.RecyclerView;

import android.Manifest;
import android.app.Activity; // Added
import android.app.NotificationChannel; // Added
import android.app.NotificationManager; // Added
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.SharedPreferences;
import android.content.pm.PackageManager;
import android.database.Cursor; // Added
import android.media.AudioAttributes; // Added
import android.media.MediaPlayer; // Added
import android.net.Uri;
import android.net.nsd.NsdServiceInfo;
import android.os.Build;
import android.os.Bundle;
import android.os.Handler;
import android.os.Looper;
import android.provider.OpenableColumns; // Added
import android.text.Editable;
import android.text.TextUtils;
import android.text.TextWatcher;
import android.util.Log;
import android.view.View;
import android.widget.Button;
import android.widget.CompoundButton;
import android.widget.SeekBar;
import android.widget.TextView;
import android.widget.Toast;

import com.google.android.material.switchmaterial.SwitchMaterial;
import com.google.android.material.textfield.TextInputEditText;
import com.google.android.material.textfield.TextInputLayout;

import org.json.JSONException;
import org.json.JSONObject;

import java.io.File; // Already here for saveLog
import java.io.IOException;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.Locale;
import java.util.Objects;

public class MainActivity extends AppCompatActivity implements NsdHelper.NsdHelperListener, DiscoveredServicesAdapter.OnServiceClickListener {

    private static final String TAG = "MainActivity_DEBUG";
    private static final String ESP_HTTP_SERVICE_TYPE = "_http._tcp";
    private static final String ESP_SERVICE_NAME_FILTER = "mrcoopersesp";
    // private static final int ESP_DEFAULT_HTTP_PORT = 80; // Not directly used here
    private static final long NSD_DISCOVERY_TIMEOUT_MS = 15000;

    // SharedPreferences keys
    private static final String PREFS_NAME = "MrCooperESP_Prefs";
    private static final String PREF_TRIGGER_DISTANCE = "trigger_distance_cm";
    private static final String PREF_NOTIFICATIONS_ENABLED = "notifications_enabled";
    // New SharedPreferences keys for custom sound
    private static final String PREF_CUSTOM_ALERT_SOUND_URI = "custom_alert_sound_uri";
    private static final String PREF_CUSTOM_ALERT_SOUND_ENABLED = "custom_alert_sound_enabled";

    private static final int DEFAULT_TRIGGER_DISTANCE = 50; // cm
    private static final boolean DEFAULT_NOTIFICATIONS_ENABLED = false;
    private static final boolean DEFAULT_CUSTOM_SOUND_ENABLED = true;


    private TextInputLayout textInputLayoutEspAddress;
    private TextInputEditText editTextEspAddress;
    private Button buttonStartStopPolling, buttonStopService, buttonStartStopDiscovery, buttonSaveLog;
    private TextView textViewStatus, textViewLastMessage, textViewDiscoveredServicesTitle;
    private RecyclerView recyclerViewDiscoveredServices;
    private DiscoveredServicesAdapter discoveredServicesAdapter;
    // private List<DiscoveredService> discoveredServiceList = new ArrayList<>(); // Not used directly

    private NsdHelper nsdHelper;
    private StringBuilder statusLog = new StringBuilder();
    private StringBuilder messageLog = new StringBuilder();
    private ActivityResultLauncher<String> createFileLauncher;
    private ActivityResultLauncher<Intent> selectCustomSoundLauncher; // New
    private ActivityResultLauncher<String> requestStoragePermissionLauncher; // New

    private boolean isServiceReceiverRegistered = false;
    private Handler discoveryTimeoutHandler = new Handler(Looper.getMainLooper());

    private boolean isHttpServicePolling = false;

    // UI Elements for original features
    private SeekBar seekBarTriggerDistance;
    private TextView textViewTriggerDistanceValue;
    private SwitchMaterial switchEnableNotifications;

    // New UI Elements for Custom Sound Alert
    private Button buttonSelectCustomSound;
    private TextView textViewSelectedCustomSound;
    private Button buttonTestCustomSound;
    private SwitchMaterial switchEnableCustomSound;
    private Uri currentCustomSoundUri = null;
    private MediaPlayer localTestMediaPlayer;


    private SharedPreferences sharedPreferences;


    private final ActivityResultLauncher<String> requestPostNotificationPermissionLauncher =
            registerForActivityResult(new ActivityResultContracts.RequestPermission(), isGranted -> {
                Log.d(TAG, "POST_NOTIFICATIONS permission granted: " + isGranted);
                if (isGranted) {
                    Toast.makeText(this, "Notifications permission granted.", Toast.LENGTH_SHORT).show();
                } else {
                    Toast.makeText(this, "Notifications permission denied. App may not show alerts.", Toast.LENGTH_LONG).show();
                }
            });

    private final BroadcastReceiver serviceUpdateReceiver = new BroadcastReceiver() {
        @Override
        public void onReceive(Context context, Intent intent) {
            String action = intent.getAction();
            String timestamp = getCurrentTimestamp();
            Log.d(TAG, "serviceUpdateReceiver: Received action: " + action);

            if (HttpPollingService.ACTION_STATUS_UPDATE.equals(action)) {
                String statusMessage = intent.getStringExtra(HttpPollingService.EXTRA_STATUS);
                if (statusMessage == null) statusMessage = "Unknown status from service";
                String logEntry = timestamp + " HTTP_Service_Status_RCV: " + statusMessage + "\n";
                statusLog.append(logEntry);
                Log.i(TAG, "serviceUpdateReceiver << HTTP_Status: " + statusMessage);

                if (statusMessage.toLowerCase().contains("polling started")) {
                    isHttpServicePolling = true;
                } else if (statusMessage.toLowerCase().contains("polling stopped") ||
                           statusMessage.toLowerCase().contains("service stopped")) {
                    isHttpServicePolling = false;
                }
                updateUIForHttpPollingState(isHttpServicePolling, statusMessage);


            } else if (HttpPollingService.ACTION_DATA_RECEIVED.equals(action)) {
                String dataType = intent.getStringExtra(HttpPollingService.EXTRA_DATA_TYPE);
                String jsonData = intent.getStringExtra(HttpPollingService.EXTRA_DATA_JSON_STRING);
                String logEntry = timestamp + " HTTP_Data_RCV ("+dataType+"): " +
                                  (jsonData != null ? jsonData.substring(0, Math.min(jsonData.length(), 100)) + "..." : "null") + "\n";
                messageLog.append(logEntry);
                statusLog.append(logEntry); // Also add to general status log

                Log.i(TAG, "serviceUpdateReceiver << HTTP_Data (" + dataType + "): " + jsonData);

                if ("distance".equals(dataType) && jsonData != null) {
                    try {
                        JSONObject json = new JSONObject(jsonData);
                        double distanceVal = json.optDouble("distance_cm", -3.0);
                        String distDisplay;
                        if (distanceVal == -1.0) distDisplay = "Error Reading";
                        else if (distanceVal == -2.0) distDisplay = "Sensor Disabled (ESP)";
                        else if (distanceVal == -3.0) distDisplay = "Invalid JSON from ESP";
                        else distDisplay = String.format(Locale.getDefault(), "%.2f cm", distanceVal);
                        textViewLastMessage.setText("Last Dist: " + distDisplay);

                    } catch (JSONException e) {
                        Log.e(TAG, "Error parsing distance JSON in MainActivity: " + e.getMessage());
                        textViewLastMessage.setText("Last Dist: JSON Parse Err");
                    }
                }
            }
        }
    };


    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        Log.d(TAG, "onCreate: Activity Creating");
        setContentView(R.layout.activity_main);

        sharedPreferences = getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE);

        // Existing UI elements
        textInputLayoutEspAddress = findViewById(R.id.textInputLayoutEspAddress);
        editTextEspAddress = findViewById(R.id.editTextEspAddress);
        buttonStartStopPolling = findViewById(R.id.buttonConnectManual);
        buttonStopService = findViewById(R.id.buttonDisconnect);
        buttonStartStopDiscovery = findViewById(R.id.buttonStartStopDiscovery);
        buttonSaveLog = findViewById(R.id.buttonSaveLog);
        textViewStatus = findViewById(R.id.textViewStatus);
        textViewLastMessage = findViewById(R.id.textViewLastMessage);
        textViewDiscoveredServicesTitle = findViewById(R.id.textViewDiscoveredServicesTitle);
        recyclerViewDiscoveredServices = findViewById(R.id.recyclerViewDiscoveredServices);
        seekBarTriggerDistance = findViewById(R.id.seekBarTriggerDistance);
        textViewTriggerDistanceValue = findViewById(R.id.textViewTriggerDistanceValue);
        switchEnableNotifications = findViewById(R.id.switchEnableNotifications);

        // New UI Elements for Custom Sound Alert
        buttonSelectCustomSound = findViewById(R.id.buttonSelectCustomSound);
        textViewSelectedCustomSound = findViewById(R.id.textViewSelectedCustomSound);
        buttonTestCustomSound = findViewById(R.id.buttonTestCustomSound);
        switchEnableCustomSound = findViewById(R.id.switchEnableCustomSound);

        editTextEspAddress.setText("mrcoopersesp.local");

        setupRecyclerView();
        askNotificationPermission(); // For existing notifications + new foreground service
        createCustomAlertSoundNotificationChannel(); // For AlertSoundService

        loadSettings(); // Load saved settings for slider and switches
        setupOriginalUIListeners();
        setupCustomSoundUIListeners(); // Setup listeners for new custom sound UI

        Log.d(TAG, "onCreate: Initializing NsdHelper");
        nsdHelper = new NsdHelper(this, this);

        // Launcher for saving log file
        createFileLauncher = registerForActivityResult(new ActivityResultContracts.CreateDocument("text/plain"), uri -> {
            if (uri != null) {
                Log.d(TAG, "createFileLauncher: URI received for saving log: " + uri.getPath());
                saveLogToFile(uri);
            } else {
                Log.d(TAG, "createFileLauncher: Log saving cancelled by user.");
                Toast.makeText(MainActivity.this, "Log saving cancelled.", Toast.LENGTH_SHORT).show();
            }
        });

        // Launcher for selecting custom sound file
        selectCustomSoundLauncher = registerForActivityResult(
            new ActivityResultContracts.StartActivityForResult(),
            result -> {
                if (result.getResultCode() == Activity.RESULT_OK && result.getData() != null) {
                    Uri uri = result.getData().getData();
                    if (uri != null) {
                        // Persist read permission for the URI
                        try {
                            final int takeFlags = result.getData().getFlags() & Intent.FLAG_GRANT_READ_URI_PERMISSION;
                            getContentResolver().takePersistableUriPermission(uri, takeFlags);
                            currentCustomSoundUri = uri;
                            saveCustomSoundUri(currentCustomSoundUri);
                            updateCustomSoundUI();
                            Toast.makeText(this, getString(R.string.custom_sound_selected_toast, getFileNameFromUri(currentCustomSoundUri)), Toast.LENGTH_SHORT).show();
                        } catch (SecurityException e) {
                            Log.e(TAG, "Failed to take persistable URI permission for custom sound", e);
                            Toast.makeText(this, "Failed to get permanent access to sound file.", Toast.LENGTH_LONG).show();
                            currentCustomSoundUri = null;
                            saveCustomSoundUri(null); // Clear if permission failed
                            updateCustomSoundUI();
                        }
                    }
                }
            });

        // Launcher for requesting storage permission
        requestStoragePermissionLauncher = registerForActivityResult(
            new ActivityResultContracts.RequestPermission(),
            isGranted -> {
                if (isGranted) {
                    Log.d(TAG, "Storage permission granted for custom sound selection.");
                    openCustomSoundPicker();
                } else {
                    Toast.makeText(this, R.string.storage_permission_required_toast, Toast.LENGTH_LONG).show();
                }
            });


        editTextEspAddress.addTextChangedListener(new TextWatcher() {
            @Override public void beforeTextChanged(CharSequence s, int start, int count, int after) {}
            @Override public void onTextChanged(CharSequence s, int start, int before, int count) {}
            @Override public void afterTextChanged(Editable s) {
                boolean inputPresent = !TextUtils.isEmpty(s.toString().trim());
                buttonStartStopPolling.setEnabled(inputPresent);
            }
        });

        // Listeners for original buttons
        buttonStartStopPolling.setOnClickListener(v -> {
            Log.d(TAG, "buttonStartStopPolling (Service): Clicked");
            String address = Objects.requireNonNull(editTextEspAddress.getText()).toString().trim();
            if (TextUtils.isEmpty(address)) {
                Toast.makeText(this, "Please enter ESP32 address.", Toast.LENGTH_SHORT).show();
                return;
            }
            String baseUrl = address; // Assume it includes http:// or can be parsed
            if (!baseUrl.matches("^[a-zA-Z]+://.*")) { // Simple check if schema is missing
                baseUrl = "http://" + baseUrl;
            }
            try {
                new java.net.URL(baseUrl); // Validate URL format
            } catch (java.net.MalformedURLException e) {
                 Toast.makeText(this, "Invalid address format: " + e.getMessage(), Toast.LENGTH_LONG).show();
                 return;
            }

            if (!isHttpServicePolling) {
                Intent startServiceIntent = new Intent(this, HttpPollingService.class);
                startServiceIntent.setAction(HttpPollingService.ACTION_START_FOREGROUND_SERVICE);
                startServiceIntent.putExtra(HttpPollingService.EXTRA_BASE_URL, baseUrl);
                ContextCompat.startForegroundService(this, startServiceIntent);
            } else {
                Intent stopPollingIntent = new Intent(this, HttpPollingService.class);
                stopPollingIntent.setAction(HttpPollingService.ACTION_STOP_POLLING);
                startService(stopPollingIntent); // No need for foreground context here
            }
        });

        buttonStopService.setOnClickListener(v -> {
            Log.d(TAG, "buttonStopService Clicked");
            Intent stopServiceIntent = new Intent(this, HttpPollingService.class);
            stopServiceIntent.setAction(HttpPollingService.ACTION_STOP_FOREGROUND_SERVICE);
            startService(stopServiceIntent);
        });

        buttonStartStopDiscovery.setOnClickListener(v -> {
            Log.d(TAG, "buttonStartStopDiscovery: Clicked. nsdHelper.isDiscoveryActive()=" + nsdHelper.isDiscoveryActive());
            toggleDiscovery();
        });
        buttonSaveLog.setOnClickListener(v -> {
            Log.d(TAG, "buttonSaveLog: Clicked");
            saveLog();
        });

        updateUIForInitialState();
        registerServiceReceiver();
        Log.d(TAG, "onCreate: Activity Created");
    }

    private void loadSettings() {
        // Original settings
        int triggerDistance = sharedPreferences.getInt(PREF_TRIGGER_DISTANCE, DEFAULT_TRIGGER_DISTANCE);
        boolean notificationsEnabled = sharedPreferences.getBoolean(PREF_NOTIFICATIONS_ENABLED, DEFAULT_NOTIFICATIONS_ENABLED);
        seekBarTriggerDistance.setProgress(triggerDistance);
        textViewTriggerDistanceValue.setText(String.format(Locale.getDefault(), "%d cm", triggerDistance));
        switchEnableNotifications.setChecked(notificationsEnabled);
        Log.d(TAG, "loadSettings: TriggerDist=" + triggerDistance + "cm, NotificationsEnabled=" + notificationsEnabled);

        // Custom sound settings
        String soundUriString = sharedPreferences.getString(PREF_CUSTOM_ALERT_SOUND_URI, null);
        if (soundUriString != null) {
            currentCustomSoundUri = Uri.parse(soundUriString);
            // Verify access to persistable URI
            try {
                getContentResolver().takePersistableUriPermission(currentCustomSoundUri, Intent.FLAG_GRANT_READ_URI_PERMISSION);
                // Or check by trying to open an input stream briefly if not using takePersistable again
                // getContentResolver().openInputStream(currentCustomSoundUri).close();
            } catch (SecurityException e) {
                Log.w(TAG, "loadSettings: Lost permission for custom sound URI: " + currentCustomSoundUri, e);
                Toast.makeText(this, R.string.custom_sound_no_longer_accessible_toast, Toast.LENGTH_LONG).show();
                currentCustomSoundUri = null;
                saveCustomSoundUri(null); // Clear from prefs if no longer accessible
            }
        } else {
            currentCustomSoundUri = null;
        }
        boolean customSoundIsEnabled = sharedPreferences.getBoolean(PREF_CUSTOM_ALERT_SOUND_ENABLED, currentCustomSoundUri != null); // Default to true if URI is set
        switchEnableCustomSound.setChecked(customSoundIsEnabled);
        updateCustomSoundUI();
        Log.d(TAG, "loadSettings: CustomSoundURI=" + (currentCustomSoundUri != null) + ", CustomSoundEnabled=" + customSoundIsEnabled);
    }

    private void saveTriggerDistance(int distance) {
        sharedPreferences.edit().putInt(PREF_TRIGGER_DISTANCE, distance).apply();
        Log.d(TAG, "saveTriggerDistance: Saved " + distance + "cm");
    }

    private void saveNotificationsEnabled(boolean enabled) {
        sharedPreferences.edit().putBoolean(PREF_NOTIFICATIONS_ENABLED, enabled).apply();
        Log.d(TAG, "saveNotificationsEnabled: Saved " + enabled);
    }

    private void saveCustomSoundUri(Uri uri) {
        SharedPreferences.Editor editor = sharedPreferences.edit();
        if (uri != null) {
            editor.putString(PREF_CUSTOM_ALERT_SOUND_URI, uri.toString());
        } else {
            editor.remove(PREF_CUSTOM_ALERT_SOUND_URI);
        }
        editor.apply();
        Log.d(TAG, "saveCustomSoundUri: Saved " + (uri != null ? uri.toString() : "null"));
    }

    private void saveCustomSoundEnabled(boolean enabled) {
        sharedPreferences.edit().putBoolean(PREF_CUSTOM_ALERT_SOUND_ENABLED, enabled).apply();
        Log.d(TAG, "saveCustomSoundEnabled: Saved " + enabled);
    }

    private void setupOriginalUIListeners() {
        seekBarTriggerDistance.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener() {
            @Override
            public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) {
                textViewTriggerDistanceValue.setText(String.format(Locale.getDefault(), "%d cm", progress));
                 if (fromUser) {
                    saveTriggerDistance(progress);
                }
            }
            @Override public void onStartTrackingTouch(SeekBar seekBar) {}
            @Override public void onStopTrackingTouch(SeekBar seekBar) {
                 saveTriggerDistance(seekBar.getProgress());
            }
        });

        switchEnableNotifications.setOnCheckedChangeListener((buttonView, isChecked) -> {
            saveNotificationsEnabled(isChecked);
        });
    }

    private void setupCustomSoundUIListeners() {
        buttonSelectCustomSound.setOnClickListener(v -> checkStoragePermissionAndOpenPicker());
        buttonTestCustomSound.setOnClickListener(v -> {
            if (currentCustomSoundUri != null) {
                playLocalTestSound(currentCustomSoundUri);
            } else {
                Toast.makeText(this, R.string.no_custom_sound_selected, Toast.LENGTH_SHORT).show();
            }
        });
        switchEnableCustomSound.setOnCheckedChangeListener((buttonView, isChecked) -> {
            saveCustomSoundEnabled(isChecked);
        });
    }

    private void checkStoragePermissionAndOpenPicker() {
        String permission;
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
            permission = Manifest.permission.READ_MEDIA_AUDIO;
        } else {
            permission = Manifest.permission.READ_EXTERNAL_STORAGE;
        }

        if (ContextCompat.checkSelfPermission(this, permission) == PackageManager.PERMISSION_GRANTED) {
            openCustomSoundPicker();
        } else {
            requestStoragePermissionLauncher.launch(permission);
        }
    }

    private void openCustomSoundPicker() {
        Intent intent = new Intent(Intent.ACTION_OPEN_DOCUMENT);
        intent.addCategory(Intent.CATEGORY_OPENABLE);
        intent.setType("audio/*");
        intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_PERSISTABLE_URI_PERMISSION);
        selectCustomSoundLauncher.launch(intent);
    }

    private void updateCustomSoundUI() {
        if (currentCustomSoundUri != null) {
            textViewSelectedCustomSound.setText(getString(R.string.custom_sound_selected_label, getFileNameFromUri(currentCustomSoundUri)));
            buttonTestCustomSound.setEnabled(true);
            switchEnableCustomSound.setEnabled(true);
        } else {
            textViewSelectedCustomSound.setText(R.string.no_custom_sound_selected);
            buttonTestCustomSound.setEnabled(false);
            switchEnableCustomSound.setEnabled(false);
            switchEnableCustomSound.setChecked(false); // If no sound, disable the switch itself
            saveCustomSoundEnabled(false); // And save this state
        }
    }

    private String getFileNameFromUri(Uri uri) {
        if (uri == null) return "None";
        String result = null;
        if ("content".equals(uri.getScheme())) {
            try (Cursor cursor = getContentResolver().query(uri, null, null, null, null)) {
                if (cursor != null && cursor.moveToFirst()) {
                    int displayNameIndex = cursor.getColumnIndex(OpenableColumns.DISPLAY_NAME);
                    if (displayNameIndex != -1) {
                        result = cursor.getString(displayNameIndex);
                    }
                }
            } catch (Exception e) {
                Log.e(TAG, "Error getting file name from content URI", e);
            }
        }
        if (result == null) {
            result = uri.getPath();
            if (result != null) {
                int cut = result.lastIndexOf('/');
                if (cut != -1) {
                    result = result.substring(cut + 1);
                }
            } else {
                result = uri.toString(); // Fallback
            }
        }
        return result;
    }

    private void playLocalTestSound(Uri soundUri) {
        if (localTestMediaPlayer != null) {
            localTestMediaPlayer.release();
        }
        localTestMediaPlayer = new MediaPlayer();
        localTestMediaPlayer.setAudioAttributes(
                new AudioAttributes.Builder()
                        .setContentType(AudioAttributes.CONTENT_TYPE_MUSIC)
                        .setUsage(AudioAttributes.USAGE_MEDIA) // For local test, MEDIA is fine
                        .build());
        try {
            localTestMediaPlayer.setDataSource(this, soundUri);
            localTestMediaPlayer.prepareAsync();
            localTestMediaPlayer.setOnPreparedListener(mp -> {
                mp.start();
                Toast.makeText(this, R.string.custom_sound_playing_test, Toast.LENGTH_SHORT).show();
            });
            localTestMediaPlayer.setOnCompletionListener(mp -> {
                Toast.makeText(this, R.string.custom_sound_test_finished, Toast.LENGTH_SHORT).show();
                mp.release();
                localTestMediaPlayer = null;
            });
            localTestMediaPlayer.setOnErrorListener((mp, what, extra) -> {
                Log.e(TAG, "Local MediaPlayer error: " + what + ", " + extra);
                Toast.makeText(this, R.string.custom_sound_error_playing, Toast.LENGTH_SHORT).show();
                mp.release();
                localTestMediaPlayer = null;
                return true;
            });
        } catch (IOException e) {
            Log.e(TAG, "Error setting data source for local MediaPlayer", e);
            Toast.makeText(this, R.string.custom_sound_error_preparing, Toast.LENGTH_SHORT).show();
             if (localTestMediaPlayer != null) {
                localTestMediaPlayer.release();
                localTestMediaPlayer = null;
            }
        }
    }

    private void createCustomAlertSoundNotificationChannel() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            NotificationChannel channel = new NotificationChannel(
                    AlertSoundService.CUSTOM_ALERT_SOUND_CHANNEL_ID,
                    getString(R.string.alert_sound_service_channel_name),
                    NotificationManager.IMPORTANCE_LOW
            );
            channel.setDescription(getString(R.string.alert_sound_service_channel_description));
            NotificationManager manager = getSystemService(NotificationManager.class);
            if (manager != null) {
                manager.createNotificationChannel(channel);
                Log.d(TAG, "Custom Alert Sound Notification Channel created.");
            }
        }
    }


    private void setupRecyclerView() {
        Log.d(TAG, "setupRecyclerView()");
        discoveredServicesAdapter = new DiscoveredServicesAdapter(this);
        recyclerViewDiscoveredServices.setLayoutManager(new LinearLayoutManager(this));
        recyclerViewDiscoveredServices.setAdapter(discoveredServicesAdapter);
        textViewDiscoveredServicesTitle.setVisibility(View.GONE);
        recyclerViewDiscoveredServices.setVisibility(View.GONE);
    }

    private Runnable discoveryTimeoutRunnable = () -> {
        Log.w(TAG, "mDNS Discovery timed out (" + NSD_DISCOVERY_TIMEOUT_MS + "ms)");
        if (nsdHelper.isDiscoveryActive()) {
            Log.d(TAG, "Discovery timeout: Stopping active discovery.");
            nsdHelper.stopDiscovery();
            Toast.makeText(this, "Network scan timed out.", Toast.LENGTH_SHORT).show();
        }
    };

    private void toggleDiscovery() {
        Log.d(TAG, "toggleDiscovery: Current discoveryActive=" + nsdHelper.isDiscoveryActive());
        if (nsdHelper.isDiscoveryActive()) {
            discoveryTimeoutHandler.removeCallbacks(discoveryTimeoutRunnable);
            nsdHelper.stopDiscovery();
        } else {
            discoveredServicesAdapter.clearServices();
            textViewDiscoveredServicesTitle.setVisibility(View.GONE);
            recyclerViewDiscoveredServices.setVisibility(View.GONE);
            Log.i(TAG, "toggleDiscovery: Starting discovery for Type='" + ESP_HTTP_SERVICE_TYPE + "', NameFilter='" + ESP_SERVICE_NAME_FILTER + "'");
            nsdHelper.discoverServices(ESP_SERVICE_NAME_FILTER, ESP_HTTP_SERVICE_TYPE);
            discoveryTimeoutHandler.postDelayed(discoveryTimeoutRunnable, NSD_DISCOVERY_TIMEOUT_MS);
        }
    }

    private void saveLog() {
        String fileName = "MrCoopersESP32_Log_" + new SimpleDateFormat("yyyyMMdd_HHmmss", Locale.getDefault()).format(new Date()) + ".txt";
        Log.d(TAG, "saveLog: Requesting to save log as " + fileName);
        createFileLauncher.launch(fileName);
        statusLog.append(getCurrentTimestamp()).append(" CMD_OUT: Log Save Requested to ").append(fileName).append("\n");
    }

    private void updateUIForInitialState() {
        Log.d(TAG, "updateUIForInitialState");
        textViewStatus.setText("Status: Idle. Enter address or scan.");
        textViewLastMessage.setText("Last Dist: None");
        String currentAddress = editTextEspAddress.getText() != null ? editTextEspAddress.getText().toString().trim() : "";
        buttonStartStopPolling.setEnabled(!TextUtils.isEmpty(currentAddress));
        buttonStartStopPolling.setText("Start Polling (Service)");
        buttonStopService.setText("Stop Service");
        buttonStopService.setEnabled(false);
        textInputLayoutEspAddress.setEnabled(true);
        editTextEspAddress.setEnabled(true);
        buttonStartStopDiscovery.setText("Scan Network for ESP32");
        buttonStartStopDiscovery.setEnabled(true);

        updateCustomSoundUI(); // Ensure custom sound UI is also in initial state
    }

    private void updateUIForHttpPollingState(boolean isPolling, String statusTextFromService) {
        Log.d(TAG, "updateUIForHttpPollingState: isPolling=" + isPolling + ", statusText=" + statusTextFromService);
        textViewStatus.setText(statusTextFromService); // Use actual status from service
        String currentAddress = editTextEspAddress.getText() != null ? editTextEspAddress.getText().toString().trim() : "";
        boolean inputPresent = !TextUtils.isEmpty(currentAddress);

        buttonStartStopPolling.setEnabled(inputPresent);
        if (isPolling) {
            buttonStartStopPolling.setText("Stop Polling (Service)"); // Or "Pause Polling"
            buttonStopService.setEnabled(true);
        } else {
            // Logic for when service is stopped vs polling paused
            if(statusTextFromService != null && statusTextFromService.toLowerCase().contains("service stopped")){
                buttonStartStopPolling.setText("Start Polling (Service)");
                buttonStopService.setEnabled(false); // Service fully stopped
            } else { // Polling paused or service still running but not polling
                buttonStartStopPolling.setText("Start Polling (Service)");
                buttonStopService.setEnabled(true); // Can still fully stop the service
            }
        }
        textInputLayoutEspAddress.setEnabled(!isPolling);
        editTextEspAddress.setEnabled(!isPolling);

        if (isPolling && nsdHelper.isDiscoveryActive()) {
            Log.d(TAG,"updateUIForHttpPollingState: HTTP polling started, stopping NSD discovery.");
            discoveryTimeoutHandler.removeCallbacks(discoveryTimeoutRunnable);
            nsdHelper.stopDiscovery();
        }
    }

    private void updateUIDiscoveryState(boolean isDiscovering, String serviceType) {
        Log.d(TAG, "updateUIDiscoveryState: isDiscovering=" + isDiscovering + ", serviceType=" + serviceType);
        if (isDiscovering) {
            textViewStatus.setText("Status: Scanning for " + ESP_SERVICE_NAME_FILTER + " (" + serviceType.replaceFirst("\\.$", "") + ")...");
            buttonStartStopDiscovery.setText("Stop Scan");
        } else {
            String currentStatusLower = textViewStatus.getText().toString().toLowerCase();
            if (!isHttpServicePolling && !currentStatusLower.contains("polling")) { // Only update if not actively polling
                 textViewStatus.setText("Status: Scan stopped. " + (discoveredServicesAdapter.getItemCount() == 0 ? "No matching services found." : "Select from list or enter address."));
            }
            buttonStartStopDiscovery.setText("Scan Network for ESP32");
        }
        buttonStartStopDiscovery.setEnabled(true); // Always re-enable after state change
    }

    @Override
    public void onNsdServiceCandidateFound(NsdServiceInfo serviceInfo) {
        runOnUiThread(() -> {
            Log.i(TAG, "onNsdServiceCandidateFound: Name='" + serviceInfo.getServiceName() + "', Type='" + serviceInfo.getServiceType() + "'");
            statusLog.append(getCurrentTimestamp()).append(" NSD_Candidate: '").append(serviceInfo.getServiceName()).append("' Type: '").append(serviceInfo.getServiceType()).append("'\n");
        });
    }

    @Override
    public void onNsdServiceResolved(DiscoveredService service) {
        runOnUiThread(() -> {
            Log.i(TAG, "onNsdServiceResolved: Name='" + service.getServiceName() + "', Host='" + service.getHostAddress() + ":" + service.getPort() + "', Type='" + service.getType() + "'");
            statusLog.append(getCurrentTimestamp()).append(" NSD_Resolved: '").append(service.getServiceName()).append("' at ").append(service.getHostAddress()).append(":").append(service.getPort()).append(" Type: '").append(service.getType()).append("'\n");

            // Ensure we are adding the correct service type (_http._tcp)
            if (service.getType() != null && ESP_HTTP_SERVICE_TYPE.startsWith(service.getType().replaceFirst("\\.$", ""))) {
                Log.d(TAG, "onNsdServiceResolved: Adding HTTP service to adapter: " + service.getServiceName());
                discoveredServicesAdapter.addService(service);
                if (recyclerViewDiscoveredServices.getVisibility() == View.GONE && discoveredServicesAdapter.getItemCount() > 0) {
                    textViewDiscoveredServicesTitle.setVisibility(View.VISIBLE);
                    recyclerViewDiscoveredServices.setVisibility(View.VISIBLE);
                }
            } else {
                 Log.d(TAG, "onNsdServiceResolved: Resolved service '" + service.getServiceName() + "' is not the expected HTTP type ('" + service.getType() + "'). Not adding.");
            }
        });
    }

    @Override
    public void onNsdServiceLost(DiscoveredService service) {
        runOnUiThread(() -> {
            Log.w(TAG, "onNsdServiceLost: Name='" + service.getServiceName() + "', Type='" + service.getType() + "'");
            statusLog.append(getCurrentTimestamp()).append(" NSD_Lost: '").append(service.getServiceName()).append("' Type: '").append(service.getType()).append("'\n");
            // discoveredServicesAdapter.removeService(service); // Implement if needed
             Toast.makeText(this, "Lost service: " + service.getServiceName(), Toast.LENGTH_SHORT).show();
             if (discoveredServicesAdapter.getItemCount() == 0) {
                textViewDiscoveredServicesTitle.setVisibility(View.GONE);
                recyclerViewDiscoveredServices.setVisibility(View.GONE);
            }
        });
    }

    @Override
    public void onNsdDiscoveryFailed(String serviceType, int errorCode) {
        runOnUiThread(() -> {
            Log.e(TAG, "onNsdDiscoveryFailed: type=" + serviceType + ", errorCode=" + errorCode);
            statusLog.append(getCurrentTimestamp()).append(" NSD_Discovery_Failed: type='").append(serviceType).append("', ErrorCode=").append(errorCode).append("\n");
            Toast.makeText(this, "Network Discovery Failed (Code: " + errorCode + "). Check Wi-Fi.", Toast.LENGTH_LONG).show();
            discoveryTimeoutHandler.removeCallbacks(discoveryTimeoutRunnable);
            updateUIDiscoveryState(false, serviceType);
        });
    }

    @Override
    public void onNsdResolveFailed(NsdServiceInfo serviceInfo, int errorCode) {
        runOnUiThread(() -> {
            Log.e(TAG, "onNsdResolveFailed: Service='" + serviceInfo.getServiceName() + "', errorCode=" + errorCode);
            statusLog.append(getCurrentTimestamp()).append(" NSD_Resolve_Failed: '").append(serviceInfo.getServiceName()).append("', ErrorCode=").append(errorCode).append("\n");
        });
    }

    @Override
    public void onNsdDiscoveryLifecycleChange(boolean active, String serviceType) {
        runOnUiThread(() -> {
            Log.i(TAG, "onNsdDiscoveryLifecycleChange: Active=" + active + ", serviceType=" + serviceType);
            statusLog.append(getCurrentTimestamp()).append(" NSD_Lifecycle: Discovery ").append(active ? "STARTED" : "STOPPED").append(" for '").append(serviceType).append("'\n");
            if (!active) {
                discoveryTimeoutHandler.removeCallbacks(discoveryTimeoutRunnable);
            }
            updateUIDiscoveryState(active, serviceType);
        });
    }

    @Override
    public void onServiceClick(DiscoveredService service) {
        Log.i(TAG, "onServiceClick: Service='" + service.getServiceName() + "', Host='" + service.getHostAddress() + "', Port=" + service.getPort());
        if (service.isValid()) {
            String addressToUse = service.getHostAddress();
            // If port is not 80 and valid, append it. Otherwise, HttpPollingService assumes port 80 for http://
            // if (service.getPort() > 0 && service.getPort() != 80) {
            //    addressToUse += ":" + service.getPort();
            // }
            editTextEspAddress.setText(addressToUse);
            Toast.makeText(this, "'" +service.getServiceName() + "' (" + service.getHostAddress() + ") selected. Tap 'Connect'.", Toast.LENGTH_SHORT).show();
            statusLog.append(getCurrentTimestamp()).append(" UI_Action: Clicked discovered service '").append(service.getServiceName()).append("'\n");
            if (nsdHelper.isDiscoveryActive()) {
                Log.d(TAG, "onServiceClick: Stopping discovery after service selection.");
                discoveryTimeoutHandler.removeCallbacks(discoveryTimeoutRunnable);
                nsdHelper.stopDiscovery();
            }
        } else {
            Log.w(TAG, "onServiceClick: Clicked service '" + service.getServiceName() + "' is not fully resolved.");
            Toast.makeText(this, service.getServiceName() + " is not fully resolved. Please wait or scan again.", Toast.LENGTH_SHORT).show();
        }
    }

    private String getCurrentTimestamp() {
        return new SimpleDateFormat("HH:mm:ss.SSS", Locale.getDefault()).format(new Date());
    }

    private void saveLogToFile(Uri uri) {
        Log.d(TAG, "saveLogToFile: Attempting to write log to URI: " + uri);
        try (OutputStream outputStream = getContentResolver().openOutputStream(uri);
             OutputStreamWriter writer = new OutputStreamWriter(Objects.requireNonNull(outputStream))) {
            writer.write("--- MrCooperESP32 App Log (HTTP Mode) ---\n");
            writer.write("Timestamp Format: HH:mm:ss.SSS\n");
            writer.write("Log Start: " + new SimpleDateFormat("yyyy-MM-dd HH:mm:ss", Locale.getDefault()).format(new Date()) + "\n\n");
            writer.write("--- Activity, Status & NSD Log ---\n");
            writer.write(statusLog.toString());
            writer.write("\n--- HTTP Data Log ---\n");
            writer.write(messageLog.toString());
            writer.flush();
            Toast.makeText(this, "Log saved successfully!", Toast.LENGTH_LONG).show();
            Log.i(TAG, "saveLogToFile: Log saved successfully.");
        } catch (IOException | NullPointerException e) {
            Log.e(TAG, "saveLogToFile: Error: " + e.getMessage(), e);
            Toast.makeText(this, "Error saving log: " + e.getMessage(), Toast.LENGTH_LONG).show();
        }
    }

    private void askNotificationPermission() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
            if (ContextCompat.checkSelfPermission(this, Manifest.permission.POST_NOTIFICATIONS) !=
                    PackageManager.PERMISSION_GRANTED) {
                Log.i(TAG, "askNotificationPermission: Requesting POST_NOTIFICATIONS permission.");
                requestPostNotificationPermissionLauncher.launch(Manifest.permission.POST_NOTIFICATIONS);
            } else {
                Log.d(TAG, "askNotificationPermission: POST_NOTIFICATIONS permission already granted.");
            }
        }
    }

    private void registerServiceReceiver() {
        if (!isServiceReceiverRegistered) {
            IntentFilter filter = new IntentFilter();
            filter.addAction(HttpPollingService.ACTION_STATUS_UPDATE);
            filter.addAction(HttpPollingService.ACTION_DATA_RECEIVED);
            LocalBroadcastManager.getInstance(this).registerReceiver(serviceUpdateReceiver, filter);
            isServiceReceiverRegistered = true;
            Log.d(TAG, "registerServiceReceiver: ServiceUpdateReceiver registered for HttpPollingService.");
        } else {
             Log.d(TAG, "registerServiceReceiver: ServiceUpdateReceiver already registered.");
        }
    }

    private void unregisterServiceReceiver() {
        if (isServiceReceiverRegistered) {
            LocalBroadcastManager.getInstance(this).unregisterReceiver(serviceUpdateReceiver);
            isServiceReceiverRegistered = false;
            Log.d(TAG, "unregisterServiceReceiver: ServiceUpdateReceiver unregistered.");
        }
    }

    @Override
    protected void onResume() {
        super.onResume();
        Log.d(TAG, "onResume: Activity Resumed. isHttpServicePolling=" + isHttpServicePolling);
        registerServiceReceiver();
        loadSettings(); // Ensure UI reflects current settings on resume
        // textViewStatus can be stale if service stopped while activity was paused.
        // Consider querying service state or rely on service sending an update if it's running.
        // For now, updateUIForHttpPollingState will use the current textViewStatus text if no fresh update received.
        updateUIForHttpPollingState(isHttpServicePolling, textViewStatus.getText().toString());
    }

    @Override
    protected void onPause() {
        super.onPause();
        Log.d(TAG, "onPause: Activity Paused.");
        // Do NOT unregister receiver here if we want updates while paused (e.g. for logging)
        // But if activity is not visible, some UI updates might not be relevant.
        // For simplicity, keeping it registered.
    }

    @Override
    protected void onStop() {
        super.onStop();
        Log.d(TAG, "onStop: Activity Stopped.");
        discoveryTimeoutHandler.removeCallbacks(discoveryTimeoutRunnable);
        if (nsdHelper.isDiscoveryActive()) {
             Log.i(TAG, "onStop: Stopping NSD discovery as activity is no longer visible.");
             nsdHelper.stopDiscovery();
        }
        if (localTestMediaPlayer != null) {
            localTestMediaPlayer.release();
            localTestMediaPlayer = null;
        }
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
        Log.d(TAG, "onDestroy: Activity Destroyed.");
        unregisterServiceReceiver();
        if (nsdHelper != null) {
            nsdHelper.tearDown();
        }
        discoveryTimeoutHandler.removeCallbacksAndMessages(null);
         if (localTestMediaPlayer != null) {
            localTestMediaPlayer.release();
            localTestMediaPlayer = null;
        }
    }
}

#################### START OF FILE: app\src\main\java\com\example\mybasicapp\NsdHelper.java ####################

package com.example.mybasicapp;

import android.content.Context;
import android.net.nsd.NsdManager;
import android.net.nsd.NsdServiceInfo;
import android.util.Log;

import java.util.concurrent.ConcurrentLinkedQueue;

public class NsdHelper {

    private static final String TAG = "NsdHelper_DEBUG"; // Enhanced Tag

    private NsdManager nsdManager;
    private NsdManager.DiscoveryListener discoveryListener;

    private boolean discoveryActive = false;
    private String serviceNameFilter;
    private String currentServiceTypeToDiscover;

    public interface NsdHelperListener {
        void onNsdServiceCandidateFound(NsdServiceInfo serviceInfo);
        void onNsdServiceResolved(DiscoveredService discoveredService);
        void onNsdServiceLost(DiscoveredService discoveredService);
        void onNsdDiscoveryFailed(String serviceType, int errorCode);
        void onNsdResolveFailed(NsdServiceInfo serviceInfo, int errorCode);
        void onNsdDiscoveryLifecycleChange(boolean active, String serviceType);
    }

    private NsdHelperListener listener;
    private ConcurrentLinkedQueue<NsdServiceInfo> resolveQueue = new ConcurrentLinkedQueue<>();
    private boolean isCurrentlyResolving = false;

    public NsdHelper(Context context, NsdHelperListener listener) {
        Log.d(TAG, "NsdHelper Constructor called");
        this.nsdManager = (NsdManager) context.getSystemService(Context.NSD_SERVICE);
        this.listener = listener;
        initializeDiscoveryListener();
    }

    private void initializeDiscoveryListener() {
        Log.d(TAG, "initializeDiscoveryListener()");
        discoveryListener = new NsdManager.DiscoveryListener() {
            @Override
            public void onDiscoveryStarted(String regType) {
                Log.i(TAG, "onDiscoveryStarted: type=" + regType);
                discoveryActive = true;
                if (listener != null) listener.onNsdDiscoveryLifecycleChange(true, regType);
            }

            @Override
            public void onServiceFound(NsdServiceInfo service) {
                Log.i(TAG, "onServiceFound: RAW - Name='" + service.getServiceName() + "', Type='" + service.getServiceType() + "', Port='" + service.getPort() + "'");
                Log.d(TAG, "onServiceFound: Current Filter - expectedType='" + currentServiceTypeToDiscover + "', expectedName='" + serviceNameFilter + "'");

                if (currentServiceTypeToDiscover == null || currentServiceTypeToDiscover.isEmpty()) {
                    Log.e(TAG, "onServiceFound: currentServiceTypeToDiscover is null/empty. Cannot filter.");
                    return;
                }
                String foundServiceTypeNormalized = service.getServiceType().replaceFirst("\\.$", "");
                String expectedServiceTypeNormalized = currentServiceTypeToDiscover.replaceFirst("\\.$", "");
                Log.d(TAG, "onServiceFound: Normalized types - Found='" + foundServiceTypeNormalized + "', Expected='" + expectedServiceTypeNormalized + "'");

                if (foundServiceTypeNormalized.equalsIgnoreCase(expectedServiceTypeNormalized)) {
                    Log.d(TAG, "onServiceFound: Type MATCHED: " + foundServiceTypeNormalized);
                    if (serviceNameFilter != null && !serviceNameFilter.isEmpty() &&
                            !service.getServiceName().equalsIgnoreCase(serviceNameFilter)) {
                        Log.d(TAG, "onServiceFound: Type matched, but Name MISMATCH. FoundName='" + service.getServiceName() + "', ExpectedName='" + serviceNameFilter + "'. Ignoring for resolve queue.");
                        return;
                    }
                    Log.i(TAG, "onServiceFound: MATCH! Name='" + service.getServiceName() + "'. Adding to resolve queue.");
                    if (listener != null) listener.onNsdServiceCandidateFound(service);
                    addToResolveQueue(service);
                } else {
                    Log.d(TAG, "onServiceFound: Type MISMATCH. FoundType='" + foundServiceTypeNormalized + "', ExpectedType='" + expectedServiceTypeNormalized + "'.");
                }
            }

            @Override
            public void onServiceLost(NsdServiceInfo service) {
                Log.w(TAG, "onServiceLost: Name='" + service.getServiceName() + "', Type='" + service.getServiceType() + "'");
                if (listener != null) listener.onNsdServiceLost(new DiscoveredService(service));
                resolveQueue.remove(service);
            }

            @Override
            public void onDiscoveryStopped(String serviceType) {
                Log.i(TAG, "onDiscoveryStopped: type=" + serviceType);
                discoveryActive = false;
                resolveQueue.clear();
                isCurrentlyResolving = false;
                if (listener != null) listener.onNsdDiscoveryLifecycleChange(false, serviceType);
            }

            @Override
            public void onStartDiscoveryFailed(String serviceType, int errorCode) {
                Log.e(TAG, "onStartDiscoveryFailed: type=" + serviceType + ", errorCode=" + errorCode);
                discoveryActive = false;
                if (listener != null) listener.onNsdDiscoveryFailed(serviceType, errorCode);
            }

            @Override
            public void onStopDiscoveryFailed(String serviceType, int errorCode) {
                Log.e(TAG, "onStopDiscoveryFailed: type=" + serviceType + ", errorCode=" + errorCode);
                discoveryActive = false;
                resolveQueue.clear();
                isCurrentlyResolving = false;
                if (listener != null) listener.onNsdDiscoveryLifecycleChange(false, serviceType);
            }
        };
    }

    private void addToResolveQueue(NsdServiceInfo serviceInfo) {
        Log.d(TAG, "addToResolveQueue: Attempting to add '" + serviceInfo.getServiceName() + "'");
        if (!resolveQueue.contains(serviceInfo)) { // Simple contains check, NsdServiceInfo might need proper equals
            resolveQueue.offer(serviceInfo);
            Log.d(TAG, "addToResolveQueue: Added '" + serviceInfo.getServiceName() + "'. Queue size: " + resolveQueue.size());
            processNextInResolveQueue();
        } else {
            Log.d(TAG, "addToResolveQueue: Service '" + serviceInfo.getServiceName() + "' already in queue.");
        }
    }

    private void processNextInResolveQueue() {
        synchronized (this) {
            if (isCurrentlyResolving) {
                Log.d(TAG, "processNextInResolveQueue: Already resolving. Queue size: " + resolveQueue.size());
                return;
            }
            if (resolveQueue.isEmpty()) {
                Log.d(TAG, "processNextInResolveQueue: Queue is empty.");
                return;
            }
            isCurrentlyResolving = true;
        }

        NsdServiceInfo serviceToResolve = resolveQueue.poll();
        if (serviceToResolve == null) {
            Log.w(TAG, "processNextInResolveQueue: Polled null from non-empty queue (race condition?)");
            synchronized (this) { isCurrentlyResolving = false; }
            return;
        }

        Log.i(TAG, "processNextInResolveQueue: Attempting to resolve '" + serviceToResolve.getServiceName() + "'. Remaining in queue: " + resolveQueue.size());
        if (nsdManager == null) {
            Log.e(TAG, "processNextInResolveQueue: NsdManager is null! Cannot resolve.");
            finishResolvingAndProcessNext();
            return;
        }
        nsdManager.resolveService(serviceToResolve, new NsdManager.ResolveListener() {
            @Override
            public void onResolveFailed(NsdServiceInfo serviceInfo, int errorCode) {
                Log.e(TAG, "onResolveFailed: Service='" + serviceInfo.getServiceName() + "', ErrorCode=" + errorCode);
                if (listener != null) listener.onNsdResolveFailed(serviceInfo, errorCode);
                finishResolvingAndProcessNext();
            }

            @Override
            public void onServiceResolved(NsdServiceInfo serviceInfo) {
                String hostAddress = (serviceInfo.getHost() != null) ? serviceInfo.getHost().getHostAddress() : "N/A";
                Log.i(TAG, "onServiceResolved: Name='" + serviceInfo.getServiceName() + "', Host='" + hostAddress + "', Port='" + serviceInfo.getPort() + "'");
                if (listener != null) listener.onNsdServiceResolved(new DiscoveredService(serviceInfo));
                finishResolvingAndProcessNext();
            }
        });
    }

    private void finishResolvingAndProcessNext() {
        Log.d(TAG, "finishResolvingAndProcessNext()");
        synchronized (this) {
            isCurrentlyResolving = false;
        }
        processNextInResolveQueue();
    }

    public void discoverServices(String targetServiceNameFilter, String serviceTypeToScan) {
        Log.i(TAG, "discoverServices: Requested. FilterName='" + targetServiceNameFilter + "', Type='" + serviceTypeToScan + "'");
        if (nsdManager == null) {
            Log.e(TAG, "discoverServices: NsdManager is null!");
            if (listener != null) listener.onNsdDiscoveryFailed(serviceTypeToScan, -100); // Custom error
            return;
        }
        if (serviceTypeToScan == null || serviceTypeToScan.isEmpty()) {
            Log.e(TAG, "discoverServices: Service type to scan cannot be null or empty.");
            if (listener != null) listener.onNsdDiscoveryFailed("", NsdManager.FAILURE_BAD_PARAMETERS);
            return;
        }

        if (discoveryActive) {
            Log.d(TAG, "discoverServices: Discovery already active for '" + currentServiceTypeToDiscover + "'. Stopping it first.");
            // This stop is asynchronous. The new discovery will be attempted immediately after.
            // This might lead to onDiscoveryStopped being called after the new one has started if not careful.
            // However, NsdManager should handle multiple calls.
            nsdManager.stopServiceDiscovery(discoveryListener);
            // discoveryActive will be set false in its callback
        }

        this.serviceNameFilter = targetServiceNameFilter;
        this.currentServiceTypeToDiscover = serviceTypeToScan.endsWith(".") ? serviceTypeToScan : serviceTypeToScan + ".";
        Log.d(TAG, "discoverServices: Setting scan parameters - Type='" + currentServiceTypeToDiscover + "', NameFilter='" + this.serviceNameFilter + "'");

        try {
            Log.d(TAG, "discoverServices: Calling nsdManager.discoverServices()...");
            nsdManager.discoverServices(currentServiceTypeToDiscover, NsdManager.PROTOCOL_DNS_SD, discoveryListener);
        } catch (Exception e) {
            Log.e(TAG, "discoverServices: Exception during nsdManager.discoverServices call: " + e.getMessage(), e);
            discoveryActive = false;
            if (listener != null) listener.onNsdDiscoveryFailed(currentServiceTypeToDiscover, NsdManager.FAILURE_INTERNAL_ERROR);
        }
    }

    public void stopDiscovery() {
        Log.i(TAG, "stopDiscovery: Requested.");
        if (nsdManager == null) {
            Log.e(TAG, "stopDiscovery: NsdManager is null!");
            return;
        }
        if (discoveryListener != null && discoveryActive) {
            try {
                Log.d(TAG, "stopDiscovery: Calling nsdManager.stopServiceDiscovery() for type: " + currentServiceTypeToDiscover);
                nsdManager.stopServiceDiscovery(discoveryListener);
            } catch (IllegalArgumentException e) {
                Log.w(TAG, "stopDiscovery: IllegalArgumentException: " + e.getMessage() + ". Already stopped or listener invalid?");
                discoveryActive = false; // Force state update
                resolveQueue.clear();
                isCurrentlyResolving = false;
                if (listener != null && currentServiceTypeToDiscover != null) {
                    listener.onNsdDiscoveryLifecycleChange(false, currentServiceTypeToDiscover);
                }
            }
        } else {
            Log.d(TAG, "stopDiscovery: No active discovery to stop, or listener is null, or discoveryActive is false. Current discoveryActive=" + discoveryActive);
            if(discoveryActive) { // If flag was somehow stuck true
                discoveryActive = false;
                if (listener != null && currentServiceTypeToDiscover != null) {
                    listener.onNsdDiscoveryLifecycleChange(false, currentServiceTypeToDiscover);
                }
            }
        }
    }

    public void tearDown() {
        Log.i(TAG, "tearDown: Called.");
        if (nsdManager != null) {
            stopDiscovery();
        }
        this.listener = null;
        // this.nsdManager = null; // Let it be GC'd if context is gone. System service.
        Log.d(TAG, "NsdHelper torn down.");
    }

    public boolean isDiscoveryActive() {
        return discoveryActive;
    }
}

#################### START OF FILE: app\src\main\res\drawable\ic_stat_message.xml ####################

<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24.0"
    android:viewportHeight="24.0"
    android:tint="?attr/colorControlNormal">
  <path
      android:fillColor="@android:color/white"
      android:pathData="M20,2L4,2c-1.1,0 -1.99,0.9 -1.99,2L2,22l4,-4h14c1.1,0 2,-0.9 2,-2L22,4c0,-1.1 -0.9,-2 -2,-2zM18,14L6,14v-2h12v2zM18,11L6,11L6,9h12v2zM18,8L6,8L6,6h12v2z"/>
</vector>

#################### START OF FILE: app\src\main\res\drawable\ic_stat_service.xml ####################

<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24.0"
    android:viewportHeight="24.0"
    android:tint="?attr/colorControlNormal"> <!-- Or a specific color -->
  <path
      android:fillColor="@android:color/white"
      android:pathData="M12,2C6.48,2 2,6.48 2,12s4.48,10 10,10 10,-4.48 10,-10S17.52,2 12,2zM12,20c-4.41,0 -8,-3.59 -8,-8s3.59,-8 8,-8 8,3.59 8,8 -3.59,8 -8,8zM13,7h-2v6h2V7zm0,8h-2v2h2v-2z"/>
</vector>

#################### START OF FILE: app\src\main\res\layout\activity_main.xml ####################

<?xml version="1.0" encoding="utf-8"?>
<androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:padding="16dp"
    tools:context=".MainActivity">

    <TextView
        android:id="@+id/textViewAppTitle"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="@string/app_name"
        android:textSize="22sp"
        android:textStyle="bold"
        app:layout_constraintTop_toTopOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent" />

    <com.google.android.material.textfield.TextInputLayout
        android:id="@+id/textInputLayoutEspAddress"
        style="@style/Widget.MaterialComponents.TextInputLayout.OutlinedBox"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:layout_marginTop="8dp"
        app:layout_constraintTop_toBottomOf="@id/textViewAppTitle"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        android:hint="ESP32 Address (IP or hostname.local)">

        <com.google.android.material.textfield.TextInputEditText
            android:id="@+id/editTextEspAddress"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:inputType="textUri|textNoSuggestions"
            android:textColor="?android:attr/textColorPrimary"
            android:singleLine="true"/>
    </com.google.android.material.textfield.TextInputLayout>

    <LinearLayout
        android:id="@+id/layoutConnectionButtons"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:orientation="horizontal"
        android:layout_marginTop="8dp"
        app:layout_constraintTop_toBottomOf="@id/textInputLayoutEspAddress"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent">

        <Button
            android:id="@+id/buttonConnectManual"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:text="Connect"
            android:layout_marginEnd="4dp"/>

        <Button
            android:id="@+id/buttonDisconnect"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:text="Disconnect"
            android:layout_marginStart="4dp"
            android:enabled="false"/>
    </LinearLayout>

    <Button
        android:id="@+id/buttonStartStopDiscovery"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:layout_marginTop="8dp"
        android:text="Scan Network for ESP32"
        app:layout_constraintTop_toBottomOf="@id/layoutConnectionButtons"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent"/>

    <TextView
        android:id="@+id/textViewTriggerDistanceLabel"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Trigger Distance (cm):"
        android:layout_marginTop="12dp"
        app:layout_constraintTop_toBottomOf="@id/buttonStartStopDiscovery"
        app:layout_constraintStart_toStartOf="parent"/>

    <TextView
        android:id="@+id/textViewTriggerDistanceValue"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="50 cm"
        android:layout_marginStart="8dp"
        app:layout_constraintStart_toEndOf="@id/textViewTriggerDistanceLabel"
        app:layout_constraintTop_toTopOf="@id/textViewTriggerDistanceLabel"
        app:layout_constraintBottom_toBottomOf="@id/textViewTriggerDistanceLabel"/>

    <SeekBar
        android:id="@+id/seekBarTriggerDistance"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:max="200"
        android:progress="50"
        android:layout_marginTop="4dp"
        app:layout_constraintTop_toBottomOf="@id/textViewTriggerDistanceLabel"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent"/>

    <com.google.android.material.switchmaterial.SwitchMaterial
        android:id="@+id/switchEnableNotifications"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:text="Enable Background Notifications"
        android:layout_marginTop="8dp"
        app:layout_constraintTop_toBottomOf="@id/seekBarTriggerDistance"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent"/>

    <!-- Custom Sound Alert UI Elements -->
    <Button
        android:id="@+id/buttonSelectCustomSound"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:text="@string/select_custom_alert_sound"
        android:layout_marginTop="12dp"
        app:layout_constraintTop_toBottomOf="@id/switchEnableNotifications"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent" />

    <TextView
        android:id="@+id/textViewSelectedCustomSound"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:text="@string/no_custom_sound_selected"
        android:gravity="center_horizontal"
        android:layout_marginTop="4dp"
        app:layout_constraintTop_toBottomOf="@id/buttonSelectCustomSound"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent" />

    <Button
        android:id="@+id/buttonTestCustomSound"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:text="@string/test_custom_alert_sound"
        android:enabled="false"
        android:layout_marginTop="4dp"
        app:layout_constraintTop_toBottomOf="@id/textViewSelectedCustomSound"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent" />

    <com.google.android.material.switchmaterial.SwitchMaterial
        android:id="@+id/switchEnableCustomSound"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:text="@string/enable_custom_alert_sound_switch"
        android:enabled="false"
        android:layout_marginTop="8dp"
        app:layout_constraintTop_toBottomOf="@id/buttonTestCustomSound"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent" />
    <!-- End Custom Sound Alert UI Elements -->


    <TextView
        android:id="@+id/textViewDiscoveredServicesTitle"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Discovered (tap to use):"
        android:layout_marginTop="12dp"
        android:textSize="16sp"
        android:textStyle="italic"
        android:visibility="gone"
        app:layout_constraintTop_toBottomOf="@id/switchEnableCustomSound"
        app:layout_constraintStart_toStartOf="parent"/>

    <androidx.recyclerview.widget.RecyclerView
        android:id="@+id/recyclerViewDiscoveredServices"
        android:layout_width="0dp"
        android:layout_height="0dp"
        android:layout_marginTop="4dp"
        android:visibility="gone"
        app:layout_constraintTop_toBottomOf="@id/textViewDiscoveredServicesTitle"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintBottom_toTopOf="@+id/guidelineLogArea"
        app:layout_constraintHeight_max="120dp"
        app:layout_constraintHeight_default="wrap"
        app:layout_constraintVertical_bias="0.0"
        tools:listitem="@layout/list_item_discovered_service"
        tools:itemCount="2"/>

    <androidx.constraintlayout.widget.Guideline
        android:id="@+id/guidelineLogArea"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:orientation="horizontal"
        app:layout_constraintGuide_end="120dp"/> <!-- Adjusted Guideline -->

    <TextView
        android:id="@+id/textViewStatus"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:text="Status: Idle"
        android:layout_marginBottom="4dp"
        android:textSize="14sp"
        app:layout_constraintBottom_toTopOf="@id/textViewLastMessage"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent" />

    <TextView
        android:id="@+id/textViewLastMessage"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:text="Last WS Msg: None"
        android:layout_marginBottom="8dp"
        android:textSize="12sp"
        app:layout_constraintBottom_toTopOf="@id/buttonSaveLog"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent"/>

    <Button
        android:id="@+id/buttonSaveLog"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:text="Save Activity Log"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent" />

</androidx.constraintlayout.widget.ConstraintLayout>

#################### START OF FILE: app\src\main\res\layout\list_item_discovered_service.xml ####################

<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:orientation="vertical"
    android:padding="12dp"
    android:background="?android:attr/selectableItemBackground">

    <TextView
        android:id="@+id/textViewServiceName"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:textSize="16sp"
        android:textStyle="bold"
        android:textColor="?android:attr/textColorPrimary" />

    <TextView
        android:id="@+id/textViewServiceAddress"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:textSize="14sp"
        android:textColor="?android:attr/textColorSecondary" />
</LinearLayout>

#################### START OF FILE: app\src\main\res\values\colors.xml ####################

<?xml version="1.0" encoding="utf-8"?>
<resources>
    <!-- Theme Colors for MyBasicApp -->
    <color name="my_app_primary">#1A535C</color> <!-- A dark teal/green, adjust to your liking -->
    <color name="my_app_primary_dark">#0E3F47</color> <!-- A darker shade for status bar -->
    <color name="my_app_accent">#F7B801</color> <!-- An accent color, e.g., a gold/yellow -->

    <!-- Standard Android/Material Colors (can be used as fallbacks or for other UI elements) -->
    <color name="purple_200">#FFBB86FC</color>
    <color name="purple_500">#FF6200EE</color>
    <color name="purple_700">#FF3700B3</color>
    <color name="teal_200">#FF03DAC5</color>
    <color name="teal_700">#FF018786</color>
    <color name="black">#FF000000</color>
    <color name="white">#FFFFFFFF</color>

    <!-- Text Colors -->
    <color name="text_on_primary">#FFFFFF</color>
    <color name="text_on_accent">#000000</color>
</resources>


#################### START OF FILE: app\src\main\res\values\strings.xml ####################

<resources>
    <string name="app_name">Mr Coopers ESP32</string>

    <!-- For Original Notification Channel (can be repurposed or kept if distinct features) -->
    <string name="channel_name">ESP32 Notifications</string>
    <string name="channel_description">Notifications received from the local ESP32 device.</string>

    <!-- For New HTTP Notification Channel -->
    <string name="channel_name_http">ESP32 HTTP Data</string>
    <string name="channel_description_http">Notifications for data polled from ESP32 via HTTP.</string>

    <!-- For Custom Alert Sound Feature -->
    <string name="select_custom_alert_sound">Select Custom Alert Sound</string>
    <string name="test_custom_alert_sound">Test Custom Alert</string>
    <string name="enable_custom_alert_sound_switch">Enable Custom Alert Sound</string>
    <string name="no_custom_sound_selected">No custom alert sound selected.</string>
    <string name="custom_sound_selected_label">Custom Alert: %s</string>
    <string name="custom_sound_playing_test">Playing custom alert test...</string>
    <string name="custom_sound_test_finished">Custom alert test finished.</string>
    <string name="custom_sound_error_playing">Error playing custom sound.</string>
    <string name="custom_sound_error_preparing">Error preparing custom sound.</string>
    <string name="custom_sound_selected_toast">Custom alert sound selected: %s</string>
    <string name="custom_sound_cleared_toast">Custom alert sound cleared.</string>
    <string name="custom_sound_no_longer_accessible_toast">Previously selected custom sound is no longer accessible. Please select again.</string>
    <string name="storage_permission_required_toast">Storage permission is required to select a sound file.</string>
    <string name="alert_sound_service_channel_name">Custom Alert Sound Service</string>
    <string name="alert_sound_service_channel_description">Plays custom alert sounds in the background.</string>
    <string name="alert_sound_notification_title">Playing Alert</string>
    <string name="alert_sound_notification_text">Custom alert sound is playing.</string>
    <string name="log_sensor_trigger_file_name">esp32_sensor_triggers.log</string>


</resources>

#################### START OF FILE: app\src\main\res\values\themes.xml ####################

<?xml version="1.0" encoding="utf-8"?>
<resources xmlns:tools="http://schemas.android.com/tools">
    <!-- Base application theme. -->
    <style name="Theme.MyBasicApp" parent="Theme.MaterialComponents.DayNight.DarkActionBar">
        <!-- Primary brand color. -->
        <item name="colorPrimary">@color/my_app_primary</item>
        <item name="colorPrimaryVariant">@color/my_app_primary_dark</item> <!-- Used for status bar by default -->
        <item name="colorOnPrimary">@color/text_on_primary</item> <!-- Text/icon color on primary color -->

        <!-- Secondary brand color (accent color). -->
        <item name="colorSecondary">@color/my_app_accent</item>
        <item name="colorSecondaryVariant">@color/my_app_accent</item> <!-- Can be a darker/lighter shade of accent -->
        <item name="colorOnSecondary">@color/text_on_accent</item> <!-- Text/icon color on secondary color -->

        <!-- Status bar color. -->
        <!-- By default, uses colorPrimaryVariant. You can override it explicitly. -->
        <item name="android:statusBarColor" tools:targetApi="l">?attr/colorPrimaryVariant</item>

        <!-- Customize your theme here. -->
        <!-- For example, to remove the action bar if you're using a Toolbar in your layout: -->
        <!-- <item name="windowActionBar">false</item> -->
        <!-- <item name="windowNoTitle">true</item> -->

        <!-- You can also define other attributes like windowBackground, textColor, etc. -->
        <!-- <item name="android:windowBackground">@color/white</item> -->
    </style>

    <!-- Optional: A theme for a splash screen if you implement one -->
    <!--
    <style name="Theme.MyBasicApp.Splash" parent="Theme.SplashScreen">
        <item name="windowSplashScreenBackground">@color/my_app_primary</item>
        <item name="windowSplashScreenAnimatedIcon">@mipmap/ic_launcher_round</item> Comment out if no round launcher or use ic_launcher
        <item name="windowSplashScreenAnimationDuration">1000</item>
        <item name="postSplashScreenTheme">@style/Theme.MyBasicApp</item>
    </style>
    -->
</resources>

#################### START OF FILE: app\src\main\res\xml\backup_rules.xml ####################

<?xml version="1.0" encoding="utf-8"?>
<full-backup-content>
    <!-- TODO Remove the following backup rules src/main/AndroidManifext.xml#fullBackupContent-->
    <!-- <include domain="sharedpref" path="."/> -->
    <!-- <exclude domain="sharedpref" path="device.xml"/> -->
</full-backup-content>


#################### START OF FILE: app\src\main\res\xml\data_extraction_rules.xml ####################

<?xml version="1.0" encoding="utf-8"?>
<data-extraction-rules>
    <cloud-backup>
        <!-- TODO: Add cloud backup rules here. -->
        <!--
        <include domain="sharedpref" path="."/>
        <exclude domain="sharedpref" path="device.xml"/>
        -->
    </cloud-backup>
    <device-transfer>
        <!-- TODO: Add device transfer rules here. -->
        <!--
        <include domain="sharedpref" path="."/>
        <exclude domain="sharedpref" path="device.xml"/>
        -->
    </device-transfer>
</data-extraction-rules>


#################### START OF FILE: build.gradle ####################

// Top-level build file where you can add configuration options common to all sub-projects/modules.
plugins {
    // Define the Android Gradle Plugin version. 'apply false' means it's not applied to the root project,
    // but makes this version available to sub-projects like ':app'.
    // AGP 8.4.0 is a stable version compatible with Gradle 8.5.
    id("com.android.application") version "8.4.0" apply false

    // If you were using Kotlin (which this project is not, based on .java files and dependencies):
    // id("org.jetbrains.kotlin.android") version "1.9.23" apply false // Check for latest compatible Kotlin version
}

#################### START OF FILE: gradle\wrapper\gradle-wrapper.properties ####################

distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-8.6-bin.zip
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists

#################### START OF FILE: gradle.properties ####################

# Gradle JVM ARGS
# org.gradle.jvmargs=-Xmx2048m -Dfile.encoding=UTF-8 # Optional: Adjust memory if needed

# AndroidX Properties
android.useAndroidX=true
android.enableJetifier=true


#################### START OF FILE: settings.gradle ####################

pluginManagement {
    repositories {
        google()
        mavenCentral()
        gradlePluginPortal()
    }
}
dependencyResolutionManagement {
    repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)
    repositories {
        google()
        mavenCentral()
    }
}

rootProject.name = "MyBasicApp"
include ':app'
