Total files found and listed: 32
List of all files found (paths relative to processing context):
- .github\workflows\android_ci.yml
- .gitignore
- app\build.gradle
- app\src\main\AndroidManifest.xml
- app\src\main\java\com\example\mybasicapp\DiscoveredService.java
- app\src\main\java\com\example\mybasicapp\DiscoveredServicesAdapter.java
- app\src\main\java\com\example\mybasicapp\HttpPollingService.java
- app\src\main\java\com\example\mybasicapp\MainActivity.java
- app\src\main\java\com\example\mybasicapp\NsdHelper.java
- app\src\main\res\drawable\ic_stat_message.xml
- app\src\main\res\drawable\ic_stat_service.xml
- app\src\main\res\layout\activity_main.xml
- app\src\main\res\layout\list_item_discovered_service.xml
- app\src\main\res\mipmap-hdpi\ic_launcher.png
- app\src\main\res\mipmap-hdpi\ic_launcher_round.png
- app\src\main\res\mipmap-mdpi\ic_launcher.png
- app\src\main\res\mipmap-mdpi\ic_launcher_round.png
- app\src\main\res\mipmap-xhdpi\ic_launcher.png
- app\src\main\res\mipmap-xhdpi\ic_launcher_round.png
- app\src\main\res\mipmap-xxhdpi\ic_launcher.png
- app\src\main\res\mipmap-xxhdpi\ic_launcher_round.png
- app\src\main\res\mipmap-xxxhdpi\ic_launcher.png
- app\src\main\res\mipmap-xxxhdpi\ic_launcher_round.png
- app\src\main\res\values\colors.xml
- app\src\main\res\values\strings.xml
- app\src\main\res\values\themes.xml
- app\src\main\res\xml\backup_rules.xml
- app\src\main\res\xml\data_extraction_rules.xml
- build.gradle
- gradle\wrapper\gradle-wrapper.properties
- gradle.properties
- settings.gradle

Content included for 21 file(s) with extensions: .java, .yml, .xml, .gradle, .properties

================================================================================


#################### START OF FILE: .github\workflows\android_ci.yml ####################

name: Android CI Build (Online Wrapper Init)

on:
  push:
    branches: [ "main", "master" ] # Or your default branch
  pull_request:
    branches: [ "main", "master" ]

jobs:
  build:
    env:
      # Define the Gradle version for the wrapper and build.
      # Choose a version compatible with your Android Gradle Plugin (AGP).
      # For AGP 8.4.0 (used in root build.gradle), Gradle 8.6 or higher is needed.
      # Check AGP release notes for compatibility.
      GRADLE_VERSION_TO_USE: '8.6' # Updated to Gradle 8.6

    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up JDK 17
      uses: actions/setup-java@v4
      with:
        java-version: '17' # Common for modern Android development
        distribution: 'temurin'

    # This step installs the specified version of Gradle and adds the 'gradle' command to the PATH.
    - name: Setup Gradle
      uses: gradle/actions/setup-gradle@v3 # Using setup-gradle v3
      with:
        gradle-version: ${{ env.GRADLE_VERSION_TO_USE }}
        # setup-gradle action has its own caching for Gradle User Home,
        # which can be beneficial. You can further configure it if needed.
        # See https://github.com/gradle/actions/blob/main/setup-gradle/README.md#caching

    # This step uses the 'gradle' command (from Setup Gradle step) to initialize
    # the Gradle wrapper files (gradlew, gradlew.bat, gradle-wrapper.jar, gradle-wrapper.properties)
    # in the runner's workspace. The generated gradle-wrapper.properties will point to GRADLE_VERSION_TO_USE.
    - name: Initialize Gradle Wrapper
      run: gradle wrapper --gradle-version ${{ env.GRADLE_VERSION_TO_USE }} --distribution-type bin
      # Adding --distribution-type bin to ensure it fetches the binary distribution

    - name: Grant execute permission for gradlew
      run: chmod +x ./gradlew

    # Recommended: Cache Gradle dependencies downloaded by the wrapper.
    # This cache uses the wrapper files generated in the previous step and other project build files.
    - name: Cache Gradle packages
      uses: actions/cache@v4
      with:
        path: |
          ~/.gradle/caches
          ~/.gradle/wrapper/dists
        # MODIFIED KEY: Added a version suffix '-v1' to help invalidate the cache if needed.
        # Increment this suffix (e.g., -v2, -v3) or use a dynamic value like ${{ github.run_id }}
        # if you suspect stale cache issues and need to force a fresh download.
        key: ${{ runner.os }}-gradle-${{ env.GRADLE_VERSION_TO_USE }}-${{ hashFiles('**/*.gradle*', '**/gradle-wrapper.properties', '**/libs.versions.toml') }}-v1
        restore-keys: |
          ${{ runner.os }}-gradle-${{ env.GRADLE_VERSION_TO_USE }}-

    - name: Build with Gradle Wrapper
      # Adding --stacktrace for more detailed error output if the build fails
      run: ./gradlew assembleDebug --stacktrace

    - name: Upload Debug APK
      uses: actions/upload-artifact@v4
      with:
        name: MrCoopersESP32 # Name of the artifact
        path: app/build/outputs/apk/debug/MrCoopersESP32.apk # Path to the APK
        if-no-files-found: error # Fail if APK not found

#################### START OF FILE: app\build.gradle ####################

plugins {
    id 'com.android.application'
    // id 'org.jetbrains.kotlin.android' // This project uses Java, so Kotlin plugin is not needed
}

android {
    namespace 'com.example.mybasicapp'
    compileSdk 34

    defaultConfig {
        applicationId "com.example.mybasicapp"
        minSdk 21
        targetSdk 34
        versionCode 1
        versionName "1.0"

        testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
    }

    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
        }
        debug {
            // APK naming is handled by the androidComponents block below
        }
    }

    compileOptions {
        // Align with the JDK version used in the CI workflow (JDK 17)
        sourceCompatibility JavaVersion.VERSION_17
        targetCompatibility JavaVersion.VERSION_17
    }
}

// This block customizes the output APK name for debug builds.
// It was previously (and incorrectly) in the root build.gradle.
androidComponents {
    onVariants(selector().withBuildType("debug")) { variant ->
        variant.outputs.forEach { output ->
            // Ensure we are modifying the main APK output
            // Correctly compare the outputType enum directly
            if (output.outputType == com.android.build.api.variant.VariantOutputConfiguration.OutputType.SINGLE) {
                output.outputFileName.set("MrCoopersESP32.apk")
            }
        }
    }
}

dependencies {
    // Use 'androidx.core:core' for Java projects. 'core-ktx' is for Kotlin.
    implementation 'androidx.core:core:1.12.0'
    implementation 'androidx.appcompat:appcompat:1.6.1'
    implementation 'com.google.android.material:material:1.11.0'
    implementation 'androidx.constraintlayout:constraintlayout:2.1.4'

    // Add OkHttp dependency, required for WebSocketService.java.
    // This was previously (and incorrectly) in the root build.gradle's dependencies.
    implementation("com.squareup.okhttp3:okhttp:4.12.0")

    testImplementation 'junit:junit:4.13.2'
    androidTestImplementation 'androidx.test.ext:junit:1.1.5'
    androidTestImplementation 'androidx.test.espresso:espresso-core:3.5.1'
}


#################### START OF FILE: app\src\main\AndroidManifest.xml ####################

<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools">

    <!-- Standard Network Permissions -->
    <uses-permission android:name="android.permission.INTERNET" />
    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />

    <!-- Permissions for mDNS (Network Service Discovery) -->
    <uses-permission android:name="android.permission.ACCESS_WIFI_STATE" />
    <uses-permission android:name="android.permission.CHANGE_WIFI_MULTICAST_STATE" />

    <!-- Permission for Notifications (Required for Android 13+) -->
    <uses-permission android:name="android.permission.POST_NOTIFICATIONS"/>

    <!-- Permissions for Foreground Service -->
    <uses-permission android:name="android.permission.FOREGROUND_SERVICE" />
    <uses-permission android:name="android.permission.FOREGROUND_SERVICE_DATA_SYNC" />
    <!-- If targeting Android 14 (API 34) or higher and your foreground service type is dataSync,
         you might need to explicitly declare the type again here if issues arise,
         though usually the manifest merge handles it.
    <uses-permission android:name="android.permission.FOREGROUND_SERVICE_TYPE_DATA_SYNC" />
    -->


    <application
        android:allowBackup="true"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/Theme.MyBasicApp"
        tools:targetApi="31"
        android:usesCleartextTraffic="true">
        <!-- usesCleartextTraffic="true" is important for local http:// and ws:// connections -->

        <activity
            android:name=".MainActivity"
            android:exported="true"
            android:launchMode="singleTop"> <!-- singleTop is good if opening from notification -->
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>

        <service
            android:name=".HttpPollingService" 
            android:enabled="true"
            android:exported="false"
            android:foregroundServiceType="dataSync" />
            <!-- foregroundServiceType is required for services targeting Android Q (API 29) and above -->

    </application>

</manifest>

#################### START OF FILE: app\src\main\java\com\example\mybasicapp\DiscoveredService.java ####################

package com.example.mybasicapp;

import android.net.nsd.NsdServiceInfo;

public class DiscoveredService {
    private String serviceName;
    private String hostAddress;
    private int port;
    private String type; // e.g., _myespwebsocket._tcp

    public DiscoveredService(NsdServiceInfo nsdServiceInfo) {
        this.serviceName = nsdServiceInfo.getServiceName();
        this.hostAddress = nsdServiceInfo.getHost() != null ? nsdServiceInfo.getHost().getHostAddress() : null;
        this.port = nsdServiceInfo.getPort();
        this.type = nsdServiceInfo.getServiceType();
    }

    // Minimal constructor for manual entries or future use
    public DiscoveredService(String serviceName, String hostAddress, int port, String type) {
        this.serviceName = serviceName;
        this.hostAddress = hostAddress;
        this.port = port;
        this.type = type;
    }


    public String getServiceName() {
        return serviceName;
    }

    public String getHostAddress() {
        return hostAddress;
    }

    public int getPort() {
        return port;
    }

    public String getType() { return type; }

    public boolean isValid() {
        return hostAddress != null && !hostAddress.isEmpty() && port > 0;
    }

    @Override
    public String toString() {
        return serviceName + " (" + (hostAddress != null ? hostAddress : "Resolving...") + ":" + port + ")";
    }

    // Implement equals and hashCode to avoid duplicates in a list if necessary
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        DiscoveredService that = (DiscoveredService) o;
        return port == that.port &&
                java.util.Objects.equals(serviceName, that.serviceName) &&
                java.util.Objects.equals(hostAddress, that.hostAddress) &&
                java.util.Objects.equals(type, that.type);
    }

    @Override
    public int hashCode() {
        return java.util.Objects.hash(serviceName, hostAddress, port, type);
    }
}

#################### START OF FILE: app\src\main\java\com\example\mybasicapp\DiscoveredServicesAdapter.java ####################

package com.example.mybasicapp;

import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.TextView;
import androidx.annotation.NonNull;
import androidx.recyclerview.widget.RecyclerView;
import java.util.ArrayList;
import java.util.List;

public class DiscoveredServicesAdapter extends RecyclerView.Adapter<DiscoveredServicesAdapter.ViewHolder> {

    private List<DiscoveredService> discoveredServices = new ArrayList<>();
    private OnServiceClickListener listener;

    public interface OnServiceClickListener {
        void onServiceClick(DiscoveredService service);
    }

    public DiscoveredServicesAdapter(OnServiceClickListener listener) {
        this.listener = listener;
    }

    public void setServices(List<DiscoveredService> services) {
        this.discoveredServices.clear();
        if (services != null) {
            this.discoveredServices.addAll(services);
        }
        notifyDataSetChanged(); // Use DiffUtil for better performance in complex apps
    }

    public void addService(DiscoveredService service) {
        if (!discoveredServices.contains(service)) { // Avoid duplicates
            discoveredServices.add(service);
            notifyItemInserted(discoveredServices.size() - 1);
        } else { // If it exists, maybe update it (e.g. IP resolved)
           int index = discoveredServices.indexOf(service);
           if (index != -1) {
               discoveredServices.set(index, service);
               notifyItemChanged(index);
           }
        }
    }

    public void clearServices() {
        discoveredServices.clear();
        notifyDataSetChanged();
    }


    @NonNull
    @Override
    public ViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {
        View view = LayoutInflater.from(parent.getContext())
                .inflate(R.layout.list_item_discovered_service, parent, false);
        return new ViewHolder(view);
    }

    @Override
    public void onBindViewHolder(@NonNull ViewHolder holder, int position) {
        DiscoveredService service = discoveredServices.get(position);
        holder.bind(service, listener);
    }

    @Override
    public int getItemCount() {
        return discoveredServices.size();
    }

    static class ViewHolder extends RecyclerView.ViewHolder {
        TextView textViewServiceName;
        TextView textViewServiceAddress;

        ViewHolder(View itemView) {
            super(itemView);
            textViewServiceName = itemView.findViewById(R.id.textViewServiceName);
            textViewServiceAddress = itemView.findViewById(R.id.textViewServiceAddress);
        }

        void bind(final DiscoveredService service, final OnServiceClickListener listener) {
            textViewServiceName.setText(service.getServiceName());
            if (service.isValid()) {
                textViewServiceAddress.setText(service.getHostAddress() + ":" + service.getPort());
            } else {
                textViewServiceAddress.setText("Resolving or invalid...");
            }
            itemView.setOnClickListener(v -> listener.onServiceClick(service));
        }
    }
}

#################### START OF FILE: app\src\main\java\com\example\mybasicapp\HttpPollingService.java ####################

package com.example.mybasicapp;

import android.app.Notification;
import android.app.NotificationChannel;
import android.app.NotificationManager;
import android.app.PendingIntent;
import android.app.Service;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.content.pm.ServiceInfo;
import android.os.Build;
import android.os.Handler;
import android.os.IBinder;
import android.os.Looper;
import android.util.Log;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.core.app.ActivityCompat;
import androidx.core.app.NotificationCompat;
import androidx.core.app.NotificationManagerCompat;
import androidx.localbroadcastmanager.content.LocalBroadcastManager;

import org.json.JSONException;
import org.json.JSONObject;

import java.io.IOException;
import java.util.Locale;
import java.util.Objects;
import java.util.concurrent.TimeUnit;

import okhttp3.Call;
import okhttp3.Callback;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.Response; // Ensure this is okhttp3.Response

public class HttpPollingService extends Service {

    private static final String TAG = "HttpPollingService_DBG"; // Enhanced Tag
    // Actions for starting/stopping service & controlling polling
    public static final String ACTION_START_FOREGROUND_SERVICE = "com.example.mybasicapp.ACTION_START_HTTP_FG_SERVICE";
    public static final String ACTION_STOP_FOREGROUND_SERVICE = "com.example.mybasicapp.ACTION_STOP_HTTP_FG_SERVICE";
    public static final String ACTION_START_POLLING = "com.example.mybasicapp.ACTION_START_POLLING";
    public static final String ACTION_STOP_POLLING = "com.example.mybasicapp.ACTION_STOP_POLLING";
    public static final String EXTRA_BASE_URL = "EXTRA_BASE_URL"; // e.g., "http://mrcooperesp.local:80"

    // Actions for broadcasting data/status
    public static final String ACTION_STATUS_UPDATE = "com.example.mybasicapp.ACTION_HTTP_STATUS_UPDATE";
    public static final String EXTRA_STATUS = "EXTRA_STATUS";
    public static final String ACTION_DATA_RECEIVED = "com.example.mybasicapp.ACTION_HTTP_DATA_RECEIVED";
    public static final String EXTRA_DATA_TYPE = "EXTRA_DATA_TYPE"; // e.g., "distance"
    public static final String EXTRA_DATA_JSON_STRING = "EXTRA_DATA_JSON_STRING"; // Send raw JSON string

    private static final String NOTIFICATION_CHANNEL_ID_SERVICE = "http_polling_service_status_channel";
    private static final String NOTIFICATION_CHANNEL_ID_MESSAGES = "esp32_http_notifications"; // Can reuse if appropriate
    private static final int SERVICE_NOTIFICATION_ID = 2; // Different ID from WebSocketService if coexisting
    private static final int MESSAGE_NOTIFICATION_ID = 102; // Different ID

    private OkHttpClient httpClient;
    private Handler pollingHandler = new Handler(Looper.getMainLooper());
    private boolean isServiceRunningAsForeground = false;
    private boolean isCurrentlyPolling = false;
    private String currentBaseUrl;

    private static final long POLLING_INTERVAL_MS = 3000; // Poll every 3 seconds
    private static final String DISTANCE_ENDPOINT = "/get_distance";

    @Override
    public void onCreate() {
        super.onCreate();
        Log.i(TAG, "onCreate: Service Creating");
        httpClient = new OkHttpClient.Builder()
                .connectTimeout(10, TimeUnit.SECONDS)
                .readTimeout(15, TimeUnit.SECONDS)
                .writeTimeout(10, TimeUnit.SECONDS)
                .build(); // Simpler client for HTTP polling
        createNotificationChannel(NOTIFICATION_CHANNEL_ID_SERVICE, "ESP32 HTTP Polling Service", NotificationManager.IMPORTANCE_LOW);
        // If you want separate notifications for data from HTTP:
        createNotificationChannel(NOTIFICATION_CHANNEL_ID_MESSAGES, getString(R.string.channel_name_http), NotificationManager.IMPORTANCE_HIGH);
        Log.d(TAG, "onCreate: Service Created");
    }

    @Override
    public int onStartCommand(Intent intent, int flags, int startId) {
        if (intent == null || intent.getAction() == null) {
            Log.w(TAG, "onStartCommand: Null intent or action. Flags=" + flags + ", StartId=" + startId);
            if (!isServiceRunningAsForeground) {
                startForegroundServiceWithNotification("Service Initializing (Restart)...");
            }
            return START_STICKY;
        }

        String action = intent.getAction();
        Log.i(TAG, "onStartCommand: Action='" + action + "', Flags=" + flags + ", StartId=" + startId);

        switch (action) {
            case ACTION_START_FOREGROUND_SERVICE:
                Log.d(TAG, "onStartCommand: Handling ACTION_START_FOREGROUND_SERVICE. isServiceRunningAsForeground=" + isServiceRunningAsForeground);
                currentBaseUrl = intent.getStringExtra(EXTRA_BASE_URL);
                if (currentBaseUrl == null || currentBaseUrl.isEmpty()){
                    Log.e(TAG, "ACTION_START_FOREGROUND_SERVICE: Base URL is missing!");
                    sendBroadcastStatus("Error: Base URL missing for service start");
                    stopSelf(); // Cannot operate without a base URL
                    return START_NOT_STICKY;
                }
                if (!isServiceRunningAsForeground) {
                    startForegroundServiceWithNotification("Service Active. Polling ESP32 at " + getHostFromUrl(currentBaseUrl));
                }
                // Optionally auto-start polling if base URL is provided
                if (!isCurrentlyPolling) {
                     startPollingData();
                }
                break;
            case ACTION_STOP_FOREGROUND_SERVICE:
                Log.d(TAG, "onStartCommand: Handling ACTION_STOP_FOREGROUND_SERVICE.");
                stopPollingData();
                stopServiceAndForeground();
                return START_NOT_STICKY;
            case ACTION_START_POLLING:
                Log.d(TAG, "onStartCommand: Handling ACTION_START_POLLING.");
                currentBaseUrl = intent.getStringExtra(EXTRA_BASE_URL); // Update base URL if provided
                if (currentBaseUrl == null || currentBaseUrl.isEmpty()){
                     Log.e(TAG, "ACTION_START_POLLING: Base URL is missing!");
                     sendBroadcastStatus("Error: Base URL missing for polling");
                     break;
                }
                if (!isServiceRunningAsForeground) { // Ensure foreground if not already
                     startForegroundServiceWithNotification("Polling ESP32 at " + getHostFromUrl(currentBaseUrl));
                }
                startPollingData();
                break;
            case ACTION_STOP_POLLING:
                Log.d(TAG, "onStartCommand: Handling ACTION_STOP_POLLING.");
                stopPollingData();
                updateServiceNotification("Polling Paused. Service still active.");
                break;
            default:
                Log.w(TAG, "onStartCommand: Unhandled action: " + action);
                break;
        }
        return START_STICKY;
    }

    private String getHostFromUrl(String urlString) {
        if (urlString == null) return "Unknown Host";
        try {
            java.net.URL url = new java.net.URL(urlString);
            return url.getHost() + (url.getPort() != -1 && url.getPort() != 80 ? ":" + url.getPort() : "");
        } catch (java.net.MalformedURLException e) {
            return urlString; // Fallback to original string if parsing fails
        }
    }


    private void startPollingData() {
        if (currentBaseUrl == null || currentBaseUrl.isEmpty()) {
            Log.e(TAG, "startPollingData: Cannot start, base URL is not set.");
            sendBroadcastStatus("Error: Base URL not set for polling.");
            return;
        }
        if (!isCurrentlyPolling) {
            isCurrentlyPolling = true;
            pollingHandler.post(pollingRunnable); // Start immediately
            Log.i(TAG, "startPollingData: Polling started for " + currentBaseUrl);
            sendBroadcastStatus("Polling started for " + getHostFromUrl(currentBaseUrl));
            updateServiceNotification("Polling active: " + getHostFromUrl(currentBaseUrl));
        } else {
            Log.d(TAG, "startPollingData: Polling already active.");
        }
    }

    private void stopPollingData() {
        if (isCurrentlyPolling) {
            isCurrentlyPolling = false;
            pollingHandler.removeCallbacks(pollingRunnable);
            Log.i(TAG, "stopPollingData: Polling stopped.");
            sendBroadcastStatus("Polling stopped.");
            // Don't change notification here if service is still foreground for other reasons
            // updateServiceNotification("Polling Paused.");
        }
    }

    private final Runnable pollingRunnable = new Runnable() {
        @Override
        public void run() {
            if (isCurrentlyPolling && currentBaseUrl != null && !currentBaseUrl.isEmpty()) {
                fetchDataFromServer(DISTANCE_ENDPOINT, "distance");
                // Add more fetchDataFromServer calls for other endpoints if needed
                pollingHandler.postDelayed(this, POLLING_INTERVAL_MS);
            }
        }
    };

    private void fetchDataFromServer(String endpoint, final String dataType) {
        if (currentBaseUrl == null) {
            Log.e(TAG, "fetchDataFromServer: currentBaseUrl is null. Cannot fetch.");
            return;
        }
        String url = currentBaseUrl + endpoint;
        Log.d(TAG, "HTTP Polling: GET " + url);

        Request request = new Request.Builder().url(url).build();

        httpClient.newCall(request).enqueue(new Callback() {
            @Override
            public void onFailure(@NonNull Call call, @NonNull IOException e) {
                Log.e(TAG, "HTTP poll " + endpoint + " onFailure: " + e.getMessage());
                sendBroadcastStatus("Error polling " + dataType + ": " + e.getMessage());
            }

            @Override
            public void onResponse(@NonNull Call call, @NonNull Response response) throws IOException {
                final String responseBodyString = response.body() != null ? response.body().string() : null;
                final int responseCode = response.code();
                response.close();

                if (response.isSuccessful() && responseBodyString != null) {
                    Log.d(TAG, "HTTP poll " + endpoint + " onResponse (" + responseCode + "): " + responseBodyString.substring(0, Math.min(responseBodyString.length(), 100)));
                    sendBroadcastData(dataType, responseBodyString);

                    // Example: If it's distance and a "motion_detected" style event happens based on it
                    if ("distance".equals(dataType)) {
                        try {
                            JSONObject json = new JSONObject(responseBodyString);
                            // Your ESP32's /get_distance returns {"distance_cm": ...}
                            // The ESP32 code also has a "motion_detected" event for WebSockets
                            // You'd need to replicate that logic here if you want notifications
                            // based on HTTP polled data.
                            // For simplicity, we're just broadcasting the raw data for now.
                            // MainActivity will handle parsing and potential notifications.

                        } catch (JSONException e_json) {
                             Log.e(TAG, "Error parsing " + dataType + " JSON: " + e_json.getMessage());
                        }
                    }

                } else {
                    Log.e(TAG, "HTTP poll " + endpoint + " onResponse Error: " + responseCode + " - " + response.message());
                    sendBroadcastStatus("Error polling " + dataType + ": " + responseCode);
                }
            }
        });
    }


    private void startForegroundServiceWithNotification(String statusText) {
        Log.d(TAG, "startForegroundServiceWithNotification: statusText='" + statusText + "'");
        Intent notificationIntent = new Intent(this, MainActivity.class);
        PendingIntent pendingIntent = PendingIntent.getActivity(this, 0,
                notificationIntent, PendingIntent.FLAG_IMMUTABLE | PendingIntent.FLAG_UPDATE_CURRENT);

        Notification notification = new NotificationCompat.Builder(this, NOTIFICATION_CHANNEL_ID_SERVICE)
                .setContentTitle(getString(R.string.app_name) + " HTTP Sync")
                .setContentText(statusText)
                .setSmallIcon(R.drawable.ic_stat_service) // Consider a different icon for HTTP
                .setContentIntent(pendingIntent)
                .setOngoing(true)
                .setPriority(NotificationCompat.PRIORITY_LOW)
                .setCategory(NotificationCompat.CATEGORY_SERVICE)
                .build();
        try {
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
                startForeground(SERVICE_NOTIFICATION_ID, notification, ServiceInfo.FOREGROUND_SERVICE_TYPE_DATA_SYNC);
            } else {
                startForeground(SERVICE_NOTIFICATION_ID, notification);
            }
            isServiceRunningAsForeground = true;
            Log.i(TAG, "startForegroundServiceWithNotification: Service started in foreground. Notification: '" + statusText + "'");
        } catch (Exception e) {
            Log.e(TAG, "startForegroundServiceWithNotification: Error: " + e.getClass().getSimpleName() + " - " + e.getMessage(), e);
            isServiceRunningAsForeground = false;
        }
    }

    private void updateServiceNotification(String text) {
        // ... (Same as your WebSocketService's updateServiceNotification, just ensure channel ID and title are correct)
        Log.d(TAG, "updateServiceNotification: text='" + text + "'. isServiceRunningAsForeground=" + isServiceRunningAsForeground);
        if (!isServiceRunningAsForeground) {
            return;
        }
        NotificationManager manager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);
        if (manager == null) {
             Log.e(TAG, "updateServiceNotification: NotificationManager is null.");
            return;
        }
        Intent notificationIntent = new Intent(this, MainActivity.class);
        PendingIntent pendingIntent = PendingIntent.getActivity(this, 0,
                notificationIntent, PendingIntent.FLAG_IMMUTABLE | PendingIntent.FLAG_UPDATE_CURRENT);
        Notification notification = new NotificationCompat.Builder(this, NOTIFICATION_CHANNEL_ID_SERVICE)
                .setContentTitle(getString(R.string.app_name) + " HTTP Sync")
                .setContentText(text)
                .setSmallIcon(R.drawable.ic_stat_service)
                .setContentIntent(pendingIntent)
                .setOngoing(true)
                .setPriority(NotificationCompat.PRIORITY_LOW)
                .setCategory(NotificationCompat.CATEGORY_SERVICE)
                .build();
        try {
            manager.notify(SERVICE_NOTIFICATION_ID, notification);
        } catch (Exception e) {
            Log.e(TAG, "updateServiceNotification: Error: " + e.getMessage(), e);
        }
    }

    private void stopServiceAndForeground() {
        Log.i(TAG, "stopServiceAndForeground: Initiated.");
        stopPollingData(); // Make sure polling stops
        if (isServiceRunningAsForeground) {
            Log.d(TAG, "stopServiceAndForeground: Stopping foreground state now.");
            stopForeground(true);
            isServiceRunningAsForeground = false;
        }
        stopSelf();
        Log.i(TAG, "stopServiceAndForeground: Service instance stopped.");
    }

    private void sendBroadcastStatus(String status) {
        Intent intent = new Intent(ACTION_STATUS_UPDATE);
        intent.putExtra(EXTRA_STATUS, status);
        LocalBroadcastManager.getInstance(this).sendBroadcast(intent);
        Log.v(TAG, "sendBroadcastStatus >> UI: " + status);
    }

    private void sendBroadcastData(String dataType, String jsonString) {
        Intent intent = new Intent(ACTION_DATA_RECEIVED);
        intent.putExtra(EXTRA_DATA_TYPE, dataType);
        intent.putExtra(EXTRA_DATA_JSON_STRING, jsonString);
        LocalBroadcastManager.getInstance(this).sendBroadcast(intent);
        Log.v(TAG, "sendBroadcastData (" + dataType + ") >> UI: " + jsonString.substring(0, Math.min(jsonString.length(),100)));
    }

    private void createNotificationChannel(String channelId, String channelName, int importance) {
        // ... (Same as your WebSocketService's createNotificationChannel)
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            NotificationChannel channel = new NotificationChannel(channelId, channelName, importance);
            if (NOTIFICATION_CHANNEL_ID_MESSAGES.equals(channelId)) {
                channel.setDescription(getString(R.string.channel_description_http)); // Potentially new string resource
            } else {
                 channel.setDescription("Channel for ESP32 HTTP Polling Service status.");
            }
            NotificationManager notificationManager = getSystemService(NotificationManager.class);
            if (notificationManager != null) {
                notificationManager.createNotificationChannel(channel);
                Log.d(TAG, "createNotificationChannel: Channel '" + channelId + "' created/updated.");
            } else {
                Log.e(TAG, "createNotificationChannel: NotificationManager is null for channel '" + channelId + "'");
            }
        }
    }

    // You might still want showDataNotification if specific data triggers a user-visible alert
    private void showDataNotification(String title, String message) {
        // ... (Same as your WebSocketService's showDataNotification, just ensure channel ID is correct)
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
            if (ActivityCompat.checkSelfPermission(this, android.Manifest.permission.POST_NOTIFICATIONS) != PackageManager.PERMISSION_GRANTED) {
                Log.w(TAG, "showDataNotification: POST_NOTIFICATIONS permission NOT granted. Cannot show.");
                return;
            }
        }
        Intent intent = new Intent(this, MainActivity.class);
        intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP | Intent.FLAG_ACTIVITY_SINGLE_TOP);
        PendingIntent pendingIntent = PendingIntent.getActivity(this, (int) System.currentTimeMillis(), intent, PendingIntent.FLAG_UPDATE_CURRENT | PendingIntent.FLAG_IMMUTABLE);
        NotificationCompat.Builder builder = new NotificationCompat.Builder(this, NOTIFICATION_CHANNEL_ID_MESSAGES)
            .setSmallIcon(R.drawable.ic_stat_message) // Or new icon
            .setContentTitle(title).setContentText(message)
            .setPriority(NotificationCompat.PRIORITY_HIGH).setAutoCancel(true)
            .setContentIntent(pendingIntent).setDefaults(Notification.DEFAULT_ALL);
        NotificationManagerCompat.from(this).notify(MESSAGE_NOTIFICATION_ID, builder.build());
        Log.d(TAG, "showDataNotification: Sent. Title='" + title + "'");
    }

    @Nullable
    @Override
    public IBinder onBind(Intent intent) {
        Log.d(TAG, "onBind: Called, returning null.");
        return null;
    }

    @Override
    public void onDestroy() {
        Log.i(TAG, "onDestroy: Service Destroying.");
        stopPollingData();
        if (isServiceRunningAsForeground) {
            stopForeground(true);
            isServiceRunningAsForeground = false;
        }
        if (httpClient != null) {
            Log.d(TAG, "onDestroy: Shutting down OkHttpClient dispatcher and connection pool.");
            httpClient.dispatcher().executorService().shutdown();
            httpClient.connectionPool().evictAll();
        }
        Log.i(TAG, "onDestroy: Service fully destroyed.");
        super.onDestroy();
    }
}

#################### START OF FILE: app\src\main\java\com\example\mybasicapp\MainActivity.java ####################

package com.example.mybasicapp;

import androidx.activity.result.ActivityResultLauncher;
import androidx.activity.result.contract.ActivityResultContracts;
import androidx.appcompat.app.AppCompatActivity;
import androidx.core.content.ContextCompat;
import androidx.localbroadcastmanager.content.LocalBroadcastManager;
import androidx.recyclerview.widget.LinearLayoutManager;
import androidx.recyclerview.widget.RecyclerView;

import android.Manifest;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.pm.PackageManager;
import android.net.Uri;
import android.net.nsd.NsdServiceInfo;
import android.os.Build;
import android.os.Bundle;
import android.os.Handler;
import android.os.Looper;
import android.text.Editable;
import android.text.TextUtils;
import android.text.TextWatcher;
import android.util.Log;
import android.view.View;
import android.widget.Button;
import android.widget.TextView;
import android.widget.Toast;

import com.google.android.material.textfield.TextInputEditText;
import com.google.android.material.textfield.TextInputLayout;

import org.json.JSONException;
import org.json.JSONObject;

import java.io.IOException;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap; // For app_config
import java.util.List;
import java.util.Locale;
import java.util.Map; // For app_config
import java.util.Objects;

public class MainActivity extends AppCompatActivity implements NsdHelper.NsdHelperListener, DiscoveredServicesAdapter.OnServiceClickListener {

    private static final String TAG = "MainActivity_DEBUG";
    private static final String ESP_HTTP_SERVICE_TYPE = "_http._tcp"; // For mDNS discovery of HTTP service
    private static final String ESP_SERVICE_NAME_FILTER = "mrcoopersesp"; // Your ESP's mDNS name
    private static final int ESP_DEFAULT_HTTP_PORT = 80;
    private static final long NSD_DISCOVERY_TIMEOUT_MS = 15000;

    private TextInputLayout textInputLayoutEspAddress;
    private TextInputEditText editTextEspAddress;
    private Button buttonStartStopPolling, buttonStopService, buttonStartStopDiscovery, buttonSaveLog;
    private TextView textViewStatus, textViewLastMessage, textViewDiscoveredServicesTitle;
    private RecyclerView recyclerViewDiscoveredServices;
    private DiscoveredServicesAdapter discoveredServicesAdapter;
    private List<DiscoveredService> discoveredServiceList = new ArrayList<>(); // Keep this for NSD

    private NsdHelper nsdHelper;
    private StringBuilder statusLog = new StringBuilder();
    private StringBuilder messageLog = new StringBuilder(); // Can be repurposed for HTTP data log
    private ActivityResultLauncher<String> createFileLauncher;

    private boolean isServiceReceiverRegistered = false;
    private Handler discoveryTimeoutHandler = new Handler(Looper.getMainLooper());

    // App config, potentially loaded or set via UI in a more complex app
    // For now, a simple map to hold a trigger distance for demonstration.
    // Your ESP32's `app_config` is on the device itself. This is an app-side equivalent if needed.
    private Map<String, Double> app_config = new HashMap<>();


    // Flag to track if HttpPollingService is actively polling
    private boolean isHttpServicePolling = false;


    private final ActivityResultLauncher<String> requestPermissionLauncher =
            registerForActivityResult(new ActivityResultContracts.RequestPermission(), isGranted -> {
                Log.d(TAG, "Notification permission granted: " + isGranted);
                if (isGranted) {
                    Toast.makeText(this, "Notifications permission granted.", Toast.LENGTH_SHORT).show();
                } else {
                    Toast.makeText(this, "Notifications permission denied. App may not show alerts.", Toast.LENGTH_LONG).show();
                }
            });

    private final BroadcastReceiver serviceUpdateReceiver = new BroadcastReceiver() {
        @Override
        public void onReceive(Context context, Intent intent) {
            String action = intent.getAction();
            String timestamp = getCurrentTimestamp();
            Log.d(TAG, "serviceUpdateReceiver: Received action: " + action);

            if (HttpPollingService.ACTION_STATUS_UPDATE.equals(action)) {
                String statusMessage = intent.getStringExtra(HttpPollingService.EXTRA_STATUS);
                if (statusMessage == null) statusMessage = "Unknown status from service";
                String logEntry = timestamp + " HTTP_Service_Status_RCV: " + statusMessage + "\n";
                statusLog.append(logEntry);
                Log.i(TAG, "serviceUpdateReceiver << HTTP_Status: " + statusMessage);

                // Update polling state based on messages from the service
                if (statusMessage.toLowerCase().contains("polling started")) {
                    isHttpServicePolling = true;
                } else if (statusMessage.toLowerCase().contains("polling stopped") ||
                           statusMessage.toLowerCase().contains("service stopped")) {
                    isHttpServicePolling = false;
                }
                updateUIForHttpPollingState(isHttpServicePolling, statusMessage);


            } else if (HttpPollingService.ACTION_DATA_RECEIVED.equals(action)) {
                String dataType = intent.getStringExtra(HttpPollingService.EXTRA_DATA_TYPE);
                String jsonData = intent.getStringExtra(HttpPollingService.EXTRA_DATA_JSON_STRING);
                String logEntry = timestamp + " HTTP_Data_RCV ("+dataType+"): " +
                                  (jsonData != null ? jsonData.substring(0, Math.min(jsonData.length(), 100)) + "..." : "null") + "\n";
                messageLog.append(logEntry);
                statusLog.append(logEntry);

                Log.i(TAG, "serviceUpdateReceiver << HTTP_Data (" + dataType + "): " + jsonData);

                if ("distance".equals(dataType) && jsonData != null) {
                    try {
                        JSONObject json = new JSONObject(jsonData);
                        double distanceVal = json.optDouble("distance_cm", -3.0); // Default if key missing
                        String distDisplay;
                        if (distanceVal == -1.0) distDisplay = "Error Reading";
                        else if (distanceVal == -2.0) distDisplay = "Sensor Disabled (ESP)";
                        else if (distanceVal == -3.0) distDisplay = "Invalid JSON from ESP";
                        else distDisplay = String.format(Locale.getDefault(), "%.2f cm", distanceVal);
                        textViewLastMessage.setText("Last Dist: " + distDisplay);

                        double triggerDistance = app_config.getOrDefault("trigger_distance_cm", 5.0);
                        if (distanceVal >= 0 && distanceVal < triggerDistance) {
                            Log.d(TAG, "Potential motion detected via HTTP poll: " + distDisplay);
                            // You could show a system notification here using HttpPollingService.showDataNotification
                            // but it's better if the service itself decides based on rules.
                            // For now, just log it.
                        }

                    } catch (JSONException e) {
                        Log.e(TAG, "Error parsing distance JSON in MainActivity: " + e.getMessage());
                        textViewLastMessage.setText("Last Dist: JSON Parse Err");
                    }
                }
            }
        }
    };


    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        Log.d(TAG, "onCreate: Activity Creating");
        setContentView(R.layout.activity_main);

        // Initialize app_config with a default (could be loaded from SharedPreferences)
        app_config.put("trigger_distance_cm", 5.0);

        textInputLayoutEspAddress = findViewById(R.id.textInputLayoutEspAddress);
        editTextEspAddress = findViewById(R.id.editTextEspAddress);
        buttonStartStopPolling = findViewById(R.id.buttonConnectManual); // Repurposed this button
        buttonStopService = findViewById(R.id.buttonDisconnect);    // Repurposed this button
        buttonStartStopDiscovery = findViewById(R.id.buttonStartStopDiscovery);
        buttonSaveLog = findViewById(R.id.buttonSaveLog);
        textViewStatus = findViewById(R.id.textViewStatus);
        textViewLastMessage = findViewById(R.id.textViewLastMessage);
        textViewDiscoveredServicesTitle = findViewById(R.id.textViewDiscoveredServicesTitle);
        recyclerViewDiscoveredServices = findViewById(R.id.recyclerViewDiscoveredServices);

        setupRecyclerView();
        askNotificationPermission();
        Log.d(TAG, "onCreate: Initializing NsdHelper");
        nsdHelper = new NsdHelper(this, this);

        createFileLauncher = registerForActivityResult(new ActivityResultContracts.CreateDocument("text/plain"), uri -> {
            if (uri != null) {
                Log.d(TAG, "createFileLauncher: URI received for saving log: " + uri.getPath());
                saveLogToFile(uri);
            } else {
                Log.d(TAG, "createFileLauncher: Log saving cancelled by user.");
                Toast.makeText(MainActivity.this, "Log saving cancelled.", Toast.LENGTH_SHORT).show();
            }
        });

        editTextEspAddress.addTextChangedListener(new TextWatcher() {
            @Override public void beforeTextChanged(CharSequence s, int start, int count, int after) {}
            @Override public void onTextChanged(CharSequence s, int start, int before, int count) {}
            @Override public void afterTextChanged(Editable s) {
                boolean inputPresent = !TextUtils.isEmpty(s.toString().trim());
                buttonStartStopPolling.setEnabled(inputPresent);
            }
        });

        buttonStartStopPolling.setOnClickListener(v -> {
            Log.d(TAG, "buttonStartStopPolling (Service): Clicked");
            String address = Objects.requireNonNull(editTextEspAddress.getText()).toString().trim();
            if (TextUtils.isEmpty(address)) {
                Toast.makeText(this, "Please enter ESP32 address.", Toast.LENGTH_SHORT).show();
                return;
            }

            String baseUrl = address;
            if (!baseUrl.matches("^[a-zA-Z]+://.*")) {
                baseUrl = "http://" + baseUrl;
            }
            try {
                java.net.URL tempUrl = new java.net.URL(baseUrl);
                if (tempUrl.getPort() == -1 && !tempUrl.getHost().endsWith(".local")) {
                     // If no port and not .local, assume default HTTP port 80 is intended
                    // The ESP code serves on 80. Let service handle this if necessary or assume 80.
                    // For clarity, we can append it if it's an IP or other hostname.
                    // If it's "mrcooperesp.local", http scheme already implies port 80.
                }
                 // If tempUrl.getHost().endsWith(".local") or port is specified, use as is.
                 // If it's an IP without port, HttpPollingService might need to assume 80 or we add it here.
                 // For now, let's assume user includes port if not 80, or it's a .local name.
                 // HttpPollingService's getHostFromUrl will strip path, so full "http://host:port" is fine.

            } catch (java.net.MalformedURLException e) {
                Toast.makeText(this, "Invalid address format: " + e.getMessage(), Toast.LENGTH_LONG).show();
                return;
            }

            if (!isHttpServicePolling) {
                Intent startServiceIntent = new Intent(this, HttpPollingService.class);
                startServiceIntent.setAction(HttpPollingService.ACTION_START_FOREGROUND_SERVICE);
                startServiceIntent.putExtra(HttpPollingService.EXTRA_BASE_URL, baseUrl);
                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                    startForegroundService(startServiceIntent);
                } else {
                    startService(startServiceIntent);
                }
            } else {
                Intent stopPollingIntent = new Intent(this, HttpPollingService.class);
                stopPollingIntent.setAction(HttpPollingService.ACTION_STOP_POLLING);
                startService(stopPollingIntent); // Service remains foreground, just stops polling
            }
        });

        buttonStopService.setOnClickListener(v -> {
            Log.d(TAG, "buttonStopService Clicked");
            Intent stopServiceIntent = new Intent(this, HttpPollingService.class);
            stopServiceIntent.setAction(HttpPollingService.ACTION_STOP_FOREGROUND_SERVICE);
            startService(stopServiceIntent);
            // isHttpServicePolling will be set to false via broadcast from service
        });

        buttonStartStopDiscovery.setOnClickListener(v -> {
            Log.d(TAG, "buttonStartStopDiscovery: Clicked. nsdHelper.isDiscoveryActive()=" + nsdHelper.isDiscoveryActive());
            toggleDiscovery();
        });
        buttonSaveLog.setOnClickListener(v -> {
            Log.d(TAG, "buttonSaveLog: Clicked");
            saveLog();
        });

        updateUIForInitialState();
        registerServiceReceiver();
        Log.d(TAG, "onCreate: Activity Created");
    }

    private void setupRecyclerView() {
        Log.d(TAG, "setupRecyclerView()");
        discoveredServicesAdapter = new DiscoveredServicesAdapter(this);
        recyclerViewDiscoveredServices.setLayoutManager(new LinearLayoutManager(this));
        recyclerViewDiscoveredServices.setAdapter(discoveredServicesAdapter);
        textViewDiscoveredServicesTitle.setVisibility(View.GONE);
        recyclerViewDiscoveredServices.setVisibility(View.GONE);
    }

    private Runnable discoveryTimeoutRunnable = () -> {
        Log.w(TAG, "mDNS Discovery timed out (" + NSD_DISCOVERY_TIMEOUT_MS + "ms)");
        if (nsdHelper.isDiscoveryActive()) {
            Log.d(TAG, "Discovery timeout: Stopping active discovery.");
            nsdHelper.stopDiscovery();
            Toast.makeText(this, "Network scan timed out.", Toast.LENGTH_SHORT).show();
        }
    };

    private void toggleDiscovery() {
        Log.d(TAG, "toggleDiscovery: Current discoveryActive=" + nsdHelper.isDiscoveryActive());
        if (nsdHelper.isDiscoveryActive()) {
            discoveryTimeoutHandler.removeCallbacks(discoveryTimeoutRunnable);
            nsdHelper.stopDiscovery();
        } else {
            // discoveredServiceList.clear(); // NsdHelper usually manages this internally, but explicit clear for UI is fine
            discoveredServicesAdapter.clearServices();
            textViewDiscoveredServicesTitle.setVisibility(View.GONE);
            recyclerViewDiscoveredServices.setVisibility(View.GONE);
            Log.i(TAG, "toggleDiscovery: Starting discovery for Type='" + ESP_HTTP_SERVICE_TYPE + "', NameFilter='" + ESP_SERVICE_NAME_FILTER + "'");
            // Discover HTTP service now
            nsdHelper.discoverServices(ESP_SERVICE_NAME_FILTER, ESP_HTTP_SERVICE_TYPE);
            discoveryTimeoutHandler.postDelayed(discoveryTimeoutRunnable, NSD_DISCOVERY_TIMEOUT_MS);
        }
    }

    private void saveLog() {
        String fileName = "MrCoopersESP32_Log_" + new SimpleDateFormat("yyyyMMdd_HHmmss", Locale.getDefault()).format(new Date()) + ".txt";
        Log.d(TAG, "saveLog: Requesting to save log as " + fileName);
        createFileLauncher.launch(fileName);
        statusLog.append(getCurrentTimestamp()).append(" CMD_OUT: Log Save Requested to ").append(fileName).append("\n");
    }

    // --- UI Update Methods ---
    private void updateUIForInitialState() {
        Log.d(TAG, "updateUIForInitialState");
        textViewStatus.setText("Status: Idle. Enter address or scan.");
        textViewLastMessage.setText("Last Dist: None");
        String currentAddress = editTextEspAddress.getText() != null ? editTextEspAddress.getText().toString().trim() : "";
        buttonStartStopPolling.setEnabled(!TextUtils.isEmpty(currentAddress));
        buttonStartStopPolling.setText("Start Polling (Service)");
        buttonStopService.setText("Stop Service");
        buttonStopService.setEnabled(false); // Enable when service is known to be running/polling
        textInputLayoutEspAddress.setEnabled(true);
        editTextEspAddress.setEnabled(true);
        buttonStartStopDiscovery.setText("Scan Network for ESP32");
        buttonStartStopDiscovery.setEnabled(true);
    }

    private void updateUIForHttpPollingState(boolean isPolling, String statusTextFromService) {
        Log.d(TAG, "updateUIForHttpPollingState: isPolling=" + isPolling + ", statusText=" + statusTextFromService);
        textViewStatus.setText(statusTextFromService); // Show the detailed status from service
        String currentAddress = editTextEspAddress.getText() != null ? editTextEspAddress.getText().toString().trim() : "";
        boolean inputPresent = !TextUtils.isEmpty(currentAddress);

        buttonStartStopPolling.setEnabled(inputPresent);
        if (isPolling) {
            buttonStartStopPolling.setText("Stop Polling (Service)");
            buttonStopService.setEnabled(true); // Can stop the service if it's polling
        } else {
            buttonStartStopPolling.setText("Start Polling (Service)");
            // Only enable stop service if we are sure service is running but just not polling
            // This logic might need refinement based on how "service stopped" event is handled
            // For now, if not polling, assume service might be idle or stopped, so disable stop button unless we know it's active.
             buttonStopService.setEnabled(isServiceReceiverRegistered && !statusTextFromService.toLowerCase().contains("service stopped"));
        }
        textInputLayoutEspAddress.setEnabled(!isPolling); // Disable address changes while polling
        editTextEspAddress.setEnabled(!isPolling);

        // If polling starts and discovery is active, stop discovery
        if (isPolling && nsdHelper.isDiscoveryActive()) {
            Log.d(TAG,"updateUIForHttpPollingState: HTTP polling started, stopping NSD discovery.");
            discoveryTimeoutHandler.removeCallbacks(discoveryTimeoutRunnable);
            nsdHelper.stopDiscovery();
        }
    }

    private void updateUIDiscoveryState(boolean isDiscovering, String serviceType) {
        Log.d(TAG, "updateUIDiscoveryState: isDiscovering=" + isDiscovering + ", serviceType=" + serviceType);
        if (isDiscovering) {
            textViewStatus.setText("Status: Scanning for " + ESP_SERVICE_NAME_FILTER + " (" + serviceType.replaceFirst("\\.$", "") + ")...");
            buttonStartStopDiscovery.setText("Stop Scan");
        } else {
            String currentStatusLower = textViewStatus.getText().toString().toLowerCase();
            if (!isHttpServicePolling && !currentStatusLower.contains("polling")) { // Avoid overwriting polling status
                 textViewStatus.setText("Status: Scan stopped. " + (discoveredServicesAdapter.getItemCount() == 0 ? "No matching services found." : "Select from list or enter address."));
            }
            buttonStartStopDiscovery.setText("Scan Network for ESP32");
        }
        buttonStartStopDiscovery.setEnabled(true);
    }

    // --- NsdHelper.NsdHelperListener Implementation ---
    @Override
    public void onNsdServiceCandidateFound(NsdServiceInfo serviceInfo) {
        runOnUiThread(() -> {
            Log.i(TAG, "onNsdServiceCandidateFound: Name='" + serviceInfo.getServiceName() + "', Type='" + serviceInfo.getServiceType() + "'");
            statusLog.append(getCurrentTimestamp()).append(" NSD_Candidate: '").append(serviceInfo.getServiceName()).append("' Type: '").append(serviceInfo.getServiceType()).append("'\n");
        });
    }

    @Override
    public void onNsdServiceResolved(DiscoveredService service) {
        runOnUiThread(() -> {
            Log.i(TAG, "onNsdServiceResolved: Name='" + service.getServiceName() + "', Host='" + service.getHostAddress() + ":" + service.getPort() + "', Type='" + service.getType() + "'");
            statusLog.append(getCurrentTimestamp()).append(" NSD_Resolved: '").append(service.getServiceName()).append("' at ").append(service.getHostAddress()).append(":").append(service.getPort()).append(" Type: '").append(service.getType()).append("'\n");

            // Filter for the HTTP service type
            if (ESP_HTTP_SERVICE_TYPE.startsWith(service.getType().replaceFirst("\\.$", ""))) {
                Log.d(TAG, "onNsdServiceResolved: Adding HTTP service to adapter: " + service.getServiceName());
                discoveredServicesAdapter.addService(service); // Using the adapter's addService
                if (recyclerViewDiscoveredServices.getVisibility() == View.GONE && discoveredServicesAdapter.getItemCount() > 0) {
                    textViewDiscoveredServicesTitle.setVisibility(View.VISIBLE);
                    recyclerViewDiscoveredServices.setVisibility(View.VISIBLE);
                }
            } else {
                 Log.d(TAG, "onNsdServiceResolved: Resolved service '" + service.getServiceName() + "' is not the expected HTTP type ('" + service.getType() + "'). Not adding.");
            }
        });
    }

    @Override
    public void onNsdServiceLost(DiscoveredService service) {
        runOnUiThread(() -> {
            Log.w(TAG, "onNsdServiceLost: Name='" + service.getServiceName() + "', Type='" + service.getType() + "'");
            statusLog.append(getCurrentTimestamp()).append(" NSD_Lost: '").append(service.getServiceName()).append("' Type: '").append(service.getType()).append("'\n");
            // Let DiscoveredServicesAdapter handle removal if it has such a method, or manage list here
            // For simplicity, we re-set the adapter's list. A more efficient way is to remove the specific item.
            List<DiscoveredService> currentServices = new ArrayList<>();
            for (int i = 0; i < discoveredServicesAdapter.getItemCount(); i++) {
                 // This needs a way to get item from adapter or manage a parallel list
                 // discoveredServicesAdapter.getServices().remove(service) if adapter has getServices()
            }
            // If using a local list:
            // discoveredServiceList.remove(service);
            // discoveredServicesAdapter.setServices(discoveredServiceList);
            // This part needs to be correctly implemented based on how you manage the adapter's data source
            // A simple clear and re-add or a dedicated remove method in adapter is better.
            // For now, let's assume the adapter can handle this or we clear and re-add if needed.
            // If the adapter's internal list is `discoveredServices`, then:
            // discoveredServicesAdapter.removeService(service); // IF YOU ADD SUCH A METHOD
            // If not, you might need to rebuild the list.
            // For this example, let's log and be aware this UI part of NSD lost might be incomplete.
            if (discoveredServicesAdapter.getItemCount() == 0) {
                textViewDiscoveredServicesTitle.setVisibility(View.GONE);
                recyclerViewDiscoveredServices.setVisibility(View.GONE);
            }
        });
    }

    @Override
    public void onNsdDiscoveryFailed(String serviceType, int errorCode) {
        runOnUiThread(() -> {
            Log.e(TAG, "onNsdDiscoveryFailed: type=" + serviceType + ", errorCode=" + errorCode);
            statusLog.append(getCurrentTimestamp()).append(" NSD_Discovery_Failed: type='").append(serviceType).append("', ErrorCode=").append(errorCode).append("\n");
            Toast.makeText(this, "Network Discovery Failed (Code: " + errorCode + "). Check Wi-Fi.", Toast.LENGTH_LONG).show();
            discoveryTimeoutHandler.removeCallbacks(discoveryTimeoutRunnable);
            updateUIDiscoveryState(false, serviceType);
        });
    }

    @Override
    public void onNsdResolveFailed(NsdServiceInfo serviceInfo, int errorCode) {
        runOnUiThread(() -> {
            Log.e(TAG, "onNsdResolveFailed: Service='" + serviceInfo.getServiceName() + "', errorCode=" + errorCode);
            statusLog.append(getCurrentTimestamp()).append(" NSD_Resolve_Failed: '").append(serviceInfo.getServiceName()).append("', ErrorCode=").append(errorCode).append("\n");
        });
    }

    @Override
    public void onNsdDiscoveryLifecycleChange(boolean active, String serviceType) {
        runOnUiThread(() -> {
            Log.i(TAG, "onNsdDiscoveryLifecycleChange: Active=" + active + ", serviceType=" + serviceType);
            statusLog.append(getCurrentTimestamp()).append(" NSD_Lifecycle: Discovery ").append(active ? "STARTED" : "STOPPED").append(" for '").append(serviceType).append("'\n");
            if (!active) {
                discoveryTimeoutHandler.removeCallbacks(discoveryTimeoutRunnable);
            }
            updateUIDiscoveryState(active, serviceType);
        });
    }

    @Override
    public void onServiceClick(DiscoveredService service) {
        Log.i(TAG, "onServiceClick: Service='" + service.getServiceName() + "', Host='" + service.getHostAddress() + "', Port=" + service.getPort());
        if (service.isValid()) {
            // For HTTP, we just need the host. Port 80 is usually implied by http:// or handled by service.
            // If NSD resolves a different port for _http, use it.
            String addressToUse = service.getHostAddress();
            if (service.getPort() != ESP_DEFAULT_HTTP_PORT && service.getPort() > 0) {
                // addressToUse += ":" + service.getPort(); // Let HttpPollingService handle base URL construction
            }
            editTextEspAddress.setText(addressToUse); // Set the IP/hostname
            Toast.makeText(this, "'" +service.getServiceName() + "' (" + service.getHostAddress() + ") selected. Tap 'Start Polling'.", Toast.LENGTH_SHORT).show();
            statusLog.append(getCurrentTimestamp()).append(" UI_Action: Clicked discovered service '").append(service.getServiceName()).append("'\n");
            if (nsdHelper.isDiscoveryActive()) {
                Log.d(TAG, "onServiceClick: Stopping discovery after service selection.");
                discoveryTimeoutHandler.removeCallbacks(discoveryTimeoutRunnable);
                nsdHelper.stopDiscovery();
            }
        } else {
            Log.w(TAG, "onServiceClick: Clicked service '" + service.getServiceName() + "' is not fully resolved.");
            Toast.makeText(this, service.getServiceName() + " is not fully resolved. Please wait or scan again.", Toast.LENGTH_SHORT).show();
        }
    }

    private String getCurrentTimestamp() {
        return new SimpleDateFormat("HH:mm:ss.SSS", Locale.getDefault()).format(new Date());
    }

    private void saveLogToFile(Uri uri) {
        Log.d(TAG, "saveLogToFile: Attempting to write log to URI: " + uri);
        try (OutputStream outputStream = getContentResolver().openOutputStream(uri);
             OutputStreamWriter writer = new OutputStreamWriter(Objects.requireNonNull(outputStream))) {
            writer.write("--- MrCooperESP32 App Log (HTTP Mode) ---\n");
            writer.write("Timestamp Format: HH:mm:ss.SSS\n");
            writer.write("Log Start: " + new SimpleDateFormat("yyyy-MM-dd HH:mm:ss", Locale.getDefault()).format(new Date()) + "\n\n");
            writer.write("--- Activity, Status & NSD Log ---\n");
            writer.write(statusLog.toString());
            writer.write("\n--- HTTP Data Log ---\n"); // Changed from WebSocket Message Log
            writer.write(messageLog.toString());
            writer.flush();
            Toast.makeText(this, "Log saved successfully!", Toast.LENGTH_LONG).show();
            Log.i(TAG, "saveLogToFile: Log saved successfully.");
        } catch (IOException | NullPointerException e) {
            Log.e(TAG, "saveLogToFile: Error: " + e.getMessage(), e);
            Toast.makeText(this, "Error saving log: " + e.getMessage(), Toast.LENGTH_LONG).show();
        }
    }

    private void askNotificationPermission() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
            if (ContextCompat.checkSelfPermission(this, Manifest.permission.POST_NOTIFICATIONS) !=
                    PackageManager.PERMISSION_GRANTED) {
                Log.i(TAG, "askNotificationPermission: Requesting POST_NOTIFICATIONS permission.");
                requestPermissionLauncher.launch(Manifest.permission.POST_NOTIFICATIONS);
            } else {
                Log.d(TAG, "askNotificationPermission: POST_NOTIFICATIONS permission already granted.");
            }
        }
    }

    private void registerServiceReceiver() {
        if (!isServiceReceiverRegistered) {
            IntentFilter filter = new IntentFilter();
            filter.addAction(HttpPollingService.ACTION_STATUS_UPDATE);
            filter.addAction(HttpPollingService.ACTION_DATA_RECEIVED);
            LocalBroadcastManager.getInstance(this).registerReceiver(serviceUpdateReceiver, filter);
            isServiceReceiverRegistered = true;
            Log.d(TAG, "registerServiceReceiver: ServiceUpdateReceiver registered for HttpPollingService.");
        } else {
             Log.d(TAG, "registerServiceReceiver: ServiceUpdateReceiver already registered.");
        }
    }

    private void unregisterServiceReceiver() {
        if (isServiceReceiverRegistered) {
            LocalBroadcastManager.getInstance(this).unregisterReceiver(serviceUpdateReceiver);
            isServiceReceiverRegistered = false;
            Log.d(TAG, "unregisterServiceReceiver: ServiceUpdateReceiver unregistered.");
        }
    }

    @Override
    protected void onResume() {
        super.onResume();
        Log.d(TAG, "onResume: Activity Resumed. isHttpServicePolling=" + isHttpServicePolling);
        registerServiceReceiver();
        // Update UI based on the current polling state
        // This might need a more robust way to check actual service state if activity was destroyed
        updateUIForHttpPollingState(isHttpServicePolling, textViewStatus.getText().toString());
    }

    @Override
    protected void onPause() {
        super.onPause();
        Log.d(TAG, "onPause: Activity Paused.");
        // Consider if you want to unregister receiver here. For background updates, keep it.
    }

    @Override
    protected void onStop() {
        super.onStop();
        Log.d(TAG, "onStop: Activity Stopped.");
        discoveryTimeoutHandler.removeCallbacks(discoveryTimeoutRunnable);
        if (nsdHelper.isDiscoveryActive()) {
             Log.i(TAG, "onStop: Stopping NSD discovery as activity is no longer visible.");
             nsdHelper.stopDiscovery();
        }
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
        Log.d(TAG, "onDestroy: Activity Destroyed.");
        unregisterServiceReceiver();
        if (nsdHelper != null) {
            nsdHelper.tearDown();
        }
        discoveryTimeoutHandler.removeCallbacksAndMessages(null);

        // Optional: Stop the service if the main activity is destroyed
        // Intent stopServiceIntent = new Intent(this, HttpPollingService.class);
        // stopServiceIntent.setAction(HttpPollingService.ACTION_STOP_FOREGROUND_SERVICE);
        // startService(stopServiceIntent);
        // Log.d(TAG, "onDestroy: Requested HttpPollingService stop.");
    }
}

#################### START OF FILE: app\src\main\java\com\example\mybasicapp\NsdHelper.java ####################

package com.example.mybasicapp;

import android.content.Context;
import android.net.nsd.NsdManager;
import android.net.nsd.NsdServiceInfo;
import android.util.Log;

import java.util.concurrent.ConcurrentLinkedQueue;

public class NsdHelper {

    private static final String TAG = "NsdHelper_DEBUG"; // Enhanced Tag

    private NsdManager nsdManager;
    private NsdManager.DiscoveryListener discoveryListener;

    private boolean discoveryActive = false;
    private String serviceNameFilter;
    private String currentServiceTypeToDiscover;

    public interface NsdHelperListener {
        void onNsdServiceCandidateFound(NsdServiceInfo serviceInfo);
        void onNsdServiceResolved(DiscoveredService discoveredService);
        void onNsdServiceLost(DiscoveredService discoveredService);
        void onNsdDiscoveryFailed(String serviceType, int errorCode);
        void onNsdResolveFailed(NsdServiceInfo serviceInfo, int errorCode);
        void onNsdDiscoveryLifecycleChange(boolean active, String serviceType);
    }

    private NsdHelperListener listener;
    private ConcurrentLinkedQueue<NsdServiceInfo> resolveQueue = new ConcurrentLinkedQueue<>();
    private boolean isCurrentlyResolving = false;

    public NsdHelper(Context context, NsdHelperListener listener) {
        Log.d(TAG, "NsdHelper Constructor called");
        this.nsdManager = (NsdManager) context.getSystemService(Context.NSD_SERVICE);
        this.listener = listener;
        initializeDiscoveryListener();
    }

    private void initializeDiscoveryListener() {
        Log.d(TAG, "initializeDiscoveryListener()");
        discoveryListener = new NsdManager.DiscoveryListener() {
            @Override
            public void onDiscoveryStarted(String regType) {
                Log.i(TAG, "onDiscoveryStarted: type=" + regType);
                discoveryActive = true;
                if (listener != null) listener.onNsdDiscoveryLifecycleChange(true, regType);
            }

            @Override
            public void onServiceFound(NsdServiceInfo service) {
                Log.i(TAG, "onServiceFound: RAW - Name='" + service.getServiceName() + "', Type='" + service.getServiceType() + "', Port='" + service.getPort() + "'");
                Log.d(TAG, "onServiceFound: Current Filter - expectedType='" + currentServiceTypeToDiscover + "', expectedName='" + serviceNameFilter + "'");

                if (currentServiceTypeToDiscover == null || currentServiceTypeToDiscover.isEmpty()) {
                    Log.e(TAG, "onServiceFound: currentServiceTypeToDiscover is null/empty. Cannot filter.");
                    return;
                }
                String foundServiceTypeNormalized = service.getServiceType().replaceFirst("\\.$", "");
                String expectedServiceTypeNormalized = currentServiceTypeToDiscover.replaceFirst("\\.$", "");
                Log.d(TAG, "onServiceFound: Normalized types - Found='" + foundServiceTypeNormalized + "', Expected='" + expectedServiceTypeNormalized + "'");

                if (foundServiceTypeNormalized.equalsIgnoreCase(expectedServiceTypeNormalized)) {
                    Log.d(TAG, "onServiceFound: Type MATCHED: " + foundServiceTypeNormalized);
                    if (serviceNameFilter != null && !serviceNameFilter.isEmpty() &&
                            !service.getServiceName().equalsIgnoreCase(serviceNameFilter)) {
                        Log.d(TAG, "onServiceFound: Type matched, but Name MISMATCH. FoundName='" + service.getServiceName() + "', ExpectedName='" + serviceNameFilter + "'. Ignoring for resolve queue.");
                        return;
                    }
                    Log.i(TAG, "onServiceFound: MATCH! Name='" + service.getServiceName() + "'. Adding to resolve queue.");
                    if (listener != null) listener.onNsdServiceCandidateFound(service);
                    addToResolveQueue(service);
                } else {
                    Log.d(TAG, "onServiceFound: Type MISMATCH. FoundType='" + foundServiceTypeNormalized + "', ExpectedType='" + expectedServiceTypeNormalized + "'.");
                }
            }

            @Override
            public void onServiceLost(NsdServiceInfo service) {
                Log.w(TAG, "onServiceLost: Name='" + service.getServiceName() + "', Type='" + service.getServiceType() + "'");
                if (listener != null) listener.onNsdServiceLost(new DiscoveredService(service));
                resolveQueue.remove(service);
            }

            @Override
            public void onDiscoveryStopped(String serviceType) {
                Log.i(TAG, "onDiscoveryStopped: type=" + serviceType);
                discoveryActive = false;
                resolveQueue.clear();
                isCurrentlyResolving = false;
                if (listener != null) listener.onNsdDiscoveryLifecycleChange(false, serviceType);
            }

            @Override
            public void onStartDiscoveryFailed(String serviceType, int errorCode) {
                Log.e(TAG, "onStartDiscoveryFailed: type=" + serviceType + ", errorCode=" + errorCode);
                discoveryActive = false;
                if (listener != null) listener.onNsdDiscoveryFailed(serviceType, errorCode);
            }

            @Override
            public void onStopDiscoveryFailed(String serviceType, int errorCode) {
                Log.e(TAG, "onStopDiscoveryFailed: type=" + serviceType + ", errorCode=" + errorCode);
                discoveryActive = false;
                resolveQueue.clear();
                isCurrentlyResolving = false;
                if (listener != null) listener.onNsdDiscoveryLifecycleChange(false, serviceType);
            }
        };
    }

    private void addToResolveQueue(NsdServiceInfo serviceInfo) {
        Log.d(TAG, "addToResolveQueue: Attempting to add '" + serviceInfo.getServiceName() + "'");
        if (!resolveQueue.contains(serviceInfo)) { // Simple contains check, NsdServiceInfo might need proper equals
            resolveQueue.offer(serviceInfo);
            Log.d(TAG, "addToResolveQueue: Added '" + serviceInfo.getServiceName() + "'. Queue size: " + resolveQueue.size());
            processNextInResolveQueue();
        } else {
            Log.d(TAG, "addToResolveQueue: Service '" + serviceInfo.getServiceName() + "' already in queue.");
        }
    }

    private void processNextInResolveQueue() {
        synchronized (this) {
            if (isCurrentlyResolving) {
                Log.d(TAG, "processNextInResolveQueue: Already resolving. Queue size: " + resolveQueue.size());
                return;
            }
            if (resolveQueue.isEmpty()) {
                Log.d(TAG, "processNextInResolveQueue: Queue is empty.");
                return;
            }
            isCurrentlyResolving = true;
        }

        NsdServiceInfo serviceToResolve = resolveQueue.poll();
        if (serviceToResolve == null) {
            Log.w(TAG, "processNextInResolveQueue: Polled null from non-empty queue (race condition?)");
            synchronized (this) { isCurrentlyResolving = false; }
            return;
        }

        Log.i(TAG, "processNextInResolveQueue: Attempting to resolve '" + serviceToResolve.getServiceName() + "'. Remaining in queue: " + resolveQueue.size());
        if (nsdManager == null) {
            Log.e(TAG, "processNextInResolveQueue: NsdManager is null! Cannot resolve.");
            finishResolvingAndProcessNext();
            return;
        }
        nsdManager.resolveService(serviceToResolve, new NsdManager.ResolveListener() {
            @Override
            public void onResolveFailed(NsdServiceInfo serviceInfo, int errorCode) {
                Log.e(TAG, "onResolveFailed: Service='" + serviceInfo.getServiceName() + "', ErrorCode=" + errorCode);
                if (listener != null) listener.onNsdResolveFailed(serviceInfo, errorCode);
                finishResolvingAndProcessNext();
            }

            @Override
            public void onServiceResolved(NsdServiceInfo serviceInfo) {
                String hostAddress = (serviceInfo.getHost() != null) ? serviceInfo.getHost().getHostAddress() : "N/A";
                Log.i(TAG, "onServiceResolved: Name='" + serviceInfo.getServiceName() + "', Host='" + hostAddress + "', Port='" + serviceInfo.getPort() + "'");
                if (listener != null) listener.onNsdServiceResolved(new DiscoveredService(serviceInfo));
                finishResolvingAndProcessNext();
            }
        });
    }

    private void finishResolvingAndProcessNext() {
        Log.d(TAG, "finishResolvingAndProcessNext()");
        synchronized (this) {
            isCurrentlyResolving = false;
        }
        processNextInResolveQueue();
    }

    public void discoverServices(String targetServiceNameFilter, String serviceTypeToScan) {
        Log.i(TAG, "discoverServices: Requested. FilterName='" + targetServiceNameFilter + "', Type='" + serviceTypeToScan + "'");
        if (nsdManager == null) {
            Log.e(TAG, "discoverServices: NsdManager is null!");
            if (listener != null) listener.onNsdDiscoveryFailed(serviceTypeToScan, -100); // Custom error
            return;
        }
        if (serviceTypeToScan == null || serviceTypeToScan.isEmpty()) {
            Log.e(TAG, "discoverServices: Service type to scan cannot be null or empty.");
            if (listener != null) listener.onNsdDiscoveryFailed("", NsdManager.FAILURE_BAD_PARAMETERS);
            return;
        }

        if (discoveryActive) {
            Log.d(TAG, "discoverServices: Discovery already active for '" + currentServiceTypeToDiscover + "'. Stopping it first.");
            // This stop is asynchronous. The new discovery will be attempted immediately after.
            // This might lead to onDiscoveryStopped being called after the new one has started if not careful.
            // However, NsdManager should handle multiple calls.
            nsdManager.stopServiceDiscovery(discoveryListener);
            // discoveryActive will be set false in its callback
        }

        this.serviceNameFilter = targetServiceNameFilter;
        this.currentServiceTypeToDiscover = serviceTypeToScan.endsWith(".") ? serviceTypeToScan : serviceTypeToScan + ".";
        Log.d(TAG, "discoverServices: Setting scan parameters - Type='" + currentServiceTypeToDiscover + "', NameFilter='" + this.serviceNameFilter + "'");

        try {
            Log.d(TAG, "discoverServices: Calling nsdManager.discoverServices()...");
            nsdManager.discoverServices(currentServiceTypeToDiscover, NsdManager.PROTOCOL_DNS_SD, discoveryListener);
        } catch (Exception e) {
            Log.e(TAG, "discoverServices: Exception during nsdManager.discoverServices call: " + e.getMessage(), e);
            discoveryActive = false;
            if (listener != null) listener.onNsdDiscoveryFailed(currentServiceTypeToDiscover, NsdManager.FAILURE_INTERNAL_ERROR);
        }
    }

    public void stopDiscovery() {
        Log.i(TAG, "stopDiscovery: Requested.");
        if (nsdManager == null) {
            Log.e(TAG, "stopDiscovery: NsdManager is null!");
            return;
        }
        if (discoveryListener != null && discoveryActive) {
            try {
                Log.d(TAG, "stopDiscovery: Calling nsdManager.stopServiceDiscovery() for type: " + currentServiceTypeToDiscover);
                nsdManager.stopServiceDiscovery(discoveryListener);
            } catch (IllegalArgumentException e) {
                Log.w(TAG, "stopDiscovery: IllegalArgumentException: " + e.getMessage() + ". Already stopped or listener invalid?");
                discoveryActive = false; // Force state update
                resolveQueue.clear();
                isCurrentlyResolving = false;
                if (listener != null && currentServiceTypeToDiscover != null) {
                    listener.onNsdDiscoveryLifecycleChange(false, currentServiceTypeToDiscover);
                }
            }
        } else {
            Log.d(TAG, "stopDiscovery: No active discovery to stop, or listener is null, or discoveryActive is false. Current discoveryActive=" + discoveryActive);
            if(discoveryActive) { // If flag was somehow stuck true
                discoveryActive = false;
                if (listener != null && currentServiceTypeToDiscover != null) {
                    listener.onNsdDiscoveryLifecycleChange(false, currentServiceTypeToDiscover);
                }
            }
        }
    }

    public void tearDown() {
        Log.i(TAG, "tearDown: Called.");
        if (nsdManager != null) {
            stopDiscovery();
        }
        this.listener = null;
        // this.nsdManager = null; // Let it be GC'd if context is gone. System service.
        Log.d(TAG, "NsdHelper torn down.");
    }

    public boolean isDiscoveryActive() {
        return discoveryActive;
    }
}

#################### START OF FILE: app\src\main\res\drawable\ic_stat_message.xml ####################

<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24.0"
    android:viewportHeight="24.0"
    android:tint="?attr/colorControlNormal">
  <path
      android:fillColor="@android:color/white"
      android:pathData="M20,2L4,2c-1.1,0 -1.99,0.9 -1.99,2L2,22l4,-4h14c1.1,0 2,-0.9 2,-2L22,4c0,-1.1 -0.9,-2 -2,-2zM18,14L6,14v-2h12v2zM18,11L6,11L6,9h12v2zM18,8L6,8L6,6h12v2z"/>
</vector>

#################### START OF FILE: app\src\main\res\drawable\ic_stat_service.xml ####################

<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24.0"
    android:viewportHeight="24.0"
    android:tint="?attr/colorControlNormal"> <!-- Or a specific color -->
  <path
      android:fillColor="@android:color/white"
      android:pathData="M12,2C6.48,2 2,6.48 2,12s4.48,10 10,10 10,-4.48 10,-10S17.52,2 12,2zM12,20c-4.41,0 -8,-3.59 -8,-8s3.59,-8 8,-8 8,3.59 8,8 -3.59,8 -8,8zM13,7h-2v6h2V7zm0,8h-2v2h2v-2z"/>
</vector>

#################### START OF FILE: app\src\main\res\layout\activity_main.xml ####################

<?xml version="1.0" encoding="utf-8"?>
<androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:padding="16dp"
    tools:context=".MainActivity">

    <TextView
        android:id="@+id/textViewAppTitle"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="@string/app_name"
        android:textSize="22sp"
        android:textStyle="bold"
        app:layout_constraintTop_toTopOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent" />

    <com.google.android.material.textfield.TextInputLayout
        android:id="@+id/textInputLayoutEspAddress"
        style="@style/Widget.MaterialComponents.TextInputLayout.OutlinedBox"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:layout_marginTop="16dp"
        app:layout_constraintTop_toBottomOf="@id/textViewAppTitle"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        android:hint="ESP32 Address (IP or hostname.local)">

        <com.google.android.material.textfield.TextInputEditText
            android:id="@+id/editTextEspAddress"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:inputType="textUri|textNoSuggestions"
            android:textColor="?android:attr/textColorPrimary"
            android:singleLine="true"/>
    </com.google.android.material.textfield.TextInputLayout>

    <LinearLayout
        android:id="@+id/layoutConnectionButtons"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:orientation="horizontal"
        android:layout_marginTop="8dp"
        app:layout_constraintTop_toBottomOf="@id/textInputLayoutEspAddress"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent">

        <Button
            android:id="@+id/buttonConnectManual"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:text="Connect"
            android:layout_marginEnd="4dp"/>

        <Button
            android:id="@+id/buttonDisconnect"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:text="Disconnect"
            android:layout_marginStart="4dp"
            android:enabled="false"/>
    </LinearLayout>

    <Button
        android:id="@+id/buttonStartStopDiscovery"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:layout_marginTop="8dp"
        android:text="Scan Network for ESP32"
        app:layout_constraintTop_toBottomOf="@id/layoutConnectionButtons"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent"/>

    <TextView
        android:id="@+id/textViewDiscoveredServicesTitle"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Discovered (tap to use):"
        android:layout_marginTop="12dp"
        android:textSize="16sp"
        android:textStyle="italic"
        android:visibility="gone"
        app:layout_constraintTop_toBottomOf="@id/buttonStartStopDiscovery"
        app:layout_constraintStart_toStartOf="parent"/>

    <androidx.recyclerview.widget.RecyclerView
        android:id="@+id/recyclerViewDiscoveredServices"
        android:layout_width="0dp"
        android:layout_height="0dp"
        android:layout_marginTop="4dp"
        android:visibility="gone"
        app:layout_constraintTop_toBottomOf="@id/textViewDiscoveredServicesTitle"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintBottom_toTopOf="@+id/guidelineLogArea"
        app:layout_constraintHeight_max="200dp"
        app:layout_constraintVertical_bias="0.0"
        tools:listitem="@layout/list_item_discovered_service"
        tools:itemCount="2"/>

    <androidx.constraintlayout.widget.Guideline
        android:id="@+id/guidelineLogArea"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:orientation="horizontal"
        app:layout_constraintGuide_end="120dp"/>

    <TextView
        android:id="@+id/textViewStatus"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:text="Status: Idle"
        android:layout_marginBottom="4dp"
        android:textSize="14sp"
        app:layout_constraintBottom_toTopOf="@id/textViewLastMessage"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent" />

    <TextView
        android:id="@+id/textViewLastMessage"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:text="Last WS Msg: None"
        android:layout_marginBottom="8dp"
        android:textSize="12sp"
        app:layout_constraintBottom_toTopOf="@id/buttonSaveLog"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent"/>

    <Button
        android:id="@+id/buttonSaveLog"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:text="Save Activity Log"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent" />

</androidx.constraintlayout.widget.ConstraintLayout>

#################### START OF FILE: app\src\main\res\layout\list_item_discovered_service.xml ####################

<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:orientation="vertical"
    android:padding="12dp"
    android:background="?android:attr/selectableItemBackground">

    <TextView
        android:id="@+id/textViewServiceName"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:textSize="16sp"
        android:textStyle="bold"
        android:textColor="?android:attr/textColorPrimary" />

    <TextView
        android:id="@+id/textViewServiceAddress"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:textSize="14sp"
        android:textColor="?android:attr/textColorSecondary" />
</LinearLayout>

#################### START OF FILE: app\src\main\res\values\colors.xml ####################

<?xml version="1.0" encoding="utf-8"?>
<resources>
    <!-- Theme Colors for MyBasicApp -->
    <color name="my_app_primary">#1A535C</color> <!-- A dark teal/green, adjust to your liking -->
    <color name="my_app_primary_dark">#0E3F47</color> <!-- A darker shade for status bar -->
    <color name="my_app_accent">#F7B801</color> <!-- An accent color, e.g., a gold/yellow -->

    <!-- Standard Android/Material Colors (can be used as fallbacks or for other UI elements) -->
    <color name="purple_200">#FFBB86FC</color>
    <color name="purple_500">#FF6200EE</color>
    <color name="purple_700">#FF3700B3</color>
    <color name="teal_200">#FF03DAC5</color>
    <color name="teal_700">#FF018786</color>
    <color name="black">#FF000000</color>
    <color name="white">#FFFFFFFF</color>

    <!-- Text Colors -->
    <color name="text_on_primary">#FFFFFF</color>
    <color name="text_on_accent">#000000</color>
</resources>


#################### START OF FILE: app\src\main\res\values\strings.xml ####################

<resources>
    <string name="app_name">Mr Coopers ESP32</string>

    <!-- For Original Notification Channel (can be repurposed or kept if distinct features) -->
    <string name="channel_name">ESP32 Notifications</string>
    <string name="channel_description">Notifications received from the local ESP32 device.</string>

    <!-- For New HTTP Notification Channel -->
    <string name="channel_name_http">ESP32 HTTP Data</string>
    <string name="channel_description_http">Notifications for data polled from ESP32 via HTTP.</string>
</resources>

#################### START OF FILE: app\src\main\res\values\themes.xml ####################

<?xml version="1.0" encoding="utf-8"?>
<resources xmlns:tools="http://schemas.android.com/tools">
    <!-- Base application theme. -->
    <style name="Theme.MyBasicApp" parent="Theme.MaterialComponents.DayNight.DarkActionBar">
        <!-- Primary brand color. -->
        <item name="colorPrimary">@color/my_app_primary</item>
        <item name="colorPrimaryVariant">@color/my_app_primary_dark</item> <!-- Used for status bar by default -->
        <item name="colorOnPrimary">@color/text_on_primary</item> <!-- Text/icon color on primary color -->

        <!-- Secondary brand color (accent color). -->
        <item name="colorSecondary">@color/my_app_accent</item>
        <item name="colorSecondaryVariant">@color/my_app_accent</item> <!-- Can be a darker/lighter shade of accent -->
        <item name="colorOnSecondary">@color/text_on_accent</item> <!-- Text/icon color on secondary color -->

        <!-- Status bar color. -->
        <!-- By default, uses colorPrimaryVariant. You can override it explicitly. -->
        <item name="android:statusBarColor" tools:targetApi="l">?attr/colorPrimaryVariant</item>

        <!-- Customize your theme here. -->
        <!-- For example, to remove the action bar if you're using a Toolbar in your layout: -->
        <!-- <item name="windowActionBar">false</item> -->
        <!-- <item name="windowNoTitle">true</item> -->

        <!-- You can also define other attributes like windowBackground, textColor, etc. -->
        <!-- <item name="android:windowBackground">@color/white</item> -->
    </style>

    <!-- Optional: A theme for a splash screen if you implement one -->
    <!--
    <style name="Theme.MyBasicApp.Splash" parent="Theme.SplashScreen">
        <item name="windowSplashScreenBackground">@color/my_app_primary</item>
        <item name="windowSplashScreenAnimatedIcon">@mipmap/ic_launcher_round</item> Comment out if no round launcher or use ic_launcher
        <item name="windowSplashScreenAnimationDuration">1000</item>
        <item name="postSplashScreenTheme">@style/Theme.MyBasicApp</item>
    </style>
    -->
</resources>

#################### START OF FILE: app\src\main\res\xml\backup_rules.xml ####################

<?xml version="1.0" encoding="utf-8"?>
<full-backup-content>
    <!-- TODO Remove the following backup rules src/main/AndroidManifext.xml#fullBackupContent-->
    <!-- <include domain="sharedpref" path="."/> -->
    <!-- <exclude domain="sharedpref" path="device.xml"/> -->
</full-backup-content>


#################### START OF FILE: app\src\main\res\xml\data_extraction_rules.xml ####################

<?xml version="1.0" encoding="utf-8"?>
<data-extraction-rules>
    <cloud-backup>
        <!-- TODO: Add cloud backup rules here. -->
        <!--
        <include domain="sharedpref" path="."/>
        <exclude domain="sharedpref" path="device.xml"/>
        -->
    </cloud-backup>
    <device-transfer>
        <!-- TODO: Add device transfer rules here. -->
        <!--
        <include domain="sharedpref" path="."/>
        <exclude domain="sharedpref" path="device.xml"/>
        -->
    </device-transfer>
</data-extraction-rules>


#################### START OF FILE: build.gradle ####################

// Top-level build file where you can add configuration options common to all sub-projects/modules.
plugins {
    // Define the Android Gradle Plugin version. 'apply false' means it's not applied to the root project,
    // but makes this version available to sub-projects like ':app'.
    // AGP 8.4.0 is a stable version compatible with Gradle 8.5.
    id("com.android.application") version "8.4.0" apply false

    // If you were using Kotlin (which this project is not, based on .java files and dependencies):
    // id("org.jetbrains.kotlin.android") version "1.9.23" apply false // Check for latest compatible Kotlin version
}

#################### START OF FILE: gradle\wrapper\gradle-wrapper.properties ####################

distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-8.6-bin.zip
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists

#################### START OF FILE: gradle.properties ####################

# Gradle JVM ARGS
# org.gradle.jvmargs=-Xmx2048m -Dfile.encoding=UTF-8 # Optional: Adjust memory if needed

# AndroidX Properties
android.useAndroidX=true
android.enableJetifier=true


#################### START OF FILE: settings.gradle ####################

pluginManagement {
    repositories {
        google()
        mavenCentral()
        gradlePluginPortal()
    }
}
dependencyResolutionManagement {
    repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)
    repositories {
        google()
        mavenCentral()
    }
}

rootProject.name = "MyBasicApp"
include ':app'
